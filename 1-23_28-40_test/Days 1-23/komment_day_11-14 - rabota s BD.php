
	<?php
	echo '<hr><hr><br><h2>Модуль №11.11-14:  Работа с базой данных</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #11.1-2 - Подготовительный этап, Миграции (День 11)</h3><hr><hr>' . "<br>";
		//!Урок 1: Подготовительный этап
		/*
			В этом уроке создадим БД и рассмотрим основные настройки БД в Laravel
			Создадим БД => "laravel_Rusakov"
			Заполнять БД будем через миграции. О них в слуд уроке. 

			Основные настройки БД в Laravel
				Файл с настройками БД "config\database.php"
				Список настроек:
					1) default - отвечает за СУБД, используемую в БД.  
					'default' => env('DB_CONNECTION', 'mysql'),
						где,
							DB_CONNECTION - параметр файла .env 
							mysql - названеи СУБД для управление БД. 
					2) connections - объект с поддерживаемыми СУБД в Laravel
						'sqlite' => [...], 'mysql' => [...], 'pgsql' => [...], 'sqlsrv' => [...],
						2.1) sqlite	- самый приметивный вариант СУБД
							Суть этой СУБД в том, что вся БД хранится в отдельном файле. 
						2.2) mysql	- самый распространенный вариант СУБД
					3) Основные настройки СУБД
						3.1) host - адрес БД 
						3.2) port - порт хоста
						3.3) database - название БД
						3.4) username - логин к БД
						3.5) password - пароль к БД
						3.6) unix_socket, charset - кодировки БД по-умолчанию
						3.7) prefix - парамет, добавляющий ко всем таблицам прификс (это нужно для бзопасности).
					4) 'migrations'  - название таблицы с миграциями
					5) redis - хранилище с данными аля ключ-значение. 

				Большинство перечисленный настроек находятся в файле ".env" - его и нужно заполнять. 
				Из файла "database.php" настройки бурется в случаи отсутствия оных в первом файле.
		*/

		//!Урок 2: Миграции
		/*
			Миграция - это своего рода система контроля версий структуры БД (таблиц).
			Модель создается в терминале.

			TODO ВАЖНО! Создавать миграции нужно в осмысленном порядке. 
			Миграции создаются в последовательном порядке.
			Например таблица Comments связана с таблицей Posts. Если сначала создать миграцию комментариев, а потом миграцию постов, то выведется ошибка. 
			Так как требуется, чтобы комментарии по очередности были после постов.
		
			СОЗДАНИЕ МИГРАЦИИ
				Выполним созданную миграцию, в результате чего в БД будет создана новая таблица. 
				На момент создания таблицы - уже имелось несколько миграций. Они отвечают за создание нскольких таблиц в БД - некоторые из них являются системными.
				Команда выполнения имеющихся миграций:
				Пример: 
				php artisan make:model Article -m
					ИЛИ
				php artisan make:migration create_coments_table
				где, 
					php artisan				- обращение к помошнику
					make:model				- команда создания модели 
					Article					- название модели
					-m							- опция создания миграции при создании таблици 

			НАПОЛНЕНИЕ ТАБЛИЦЫ ПЕРЕД МИГРАЦИЕЙ
			Пример: 
				$table->string("title"); //255
				$table->mediumText("anons");
				$table->longText("text");
				$table->integer('post_id')->unsigned();
				$table->boolean("");
				$table->integer("");
					Где аргументы - это название строки, а методы указывают на тип данных в поле создаваемой таблицы. 
					Дополнительно к создаваемым полям можно приписывать свойства типа:
						->index() - поле индексируемо
						->unique() - недопустимо одинаковое содержание в полях
						->nullable() - допустимо наличие нуля в поле
						->default() - значение по-умолчанию 

				TODO ЗАМЕТКА: Если требуется в создаваемой таблице исключить поля даты создания и редактирования, то в модели таблицы прописывается строка:
				public $timestamps = false; 
				При добавлении данных в таблицу при отсутствии в миграции метода $table->timestamps(); - будет выдаваться ошибка

			ЗАПУСК МИГРАЦИИ
				php artisan migrate
				Эта команда запускает все изменения в папке с миграциями в БД

				TODO ВАЖНО! При выполнении команды миграции может выдаться ошибка. 
				Она связана с тем, что при установки PHP 8 может отсутствовать PDO функционал.
				Комнада проварки PDO функционала на наличие:
				php -i | grep "PDO drivers" 
				Ошибка исправляется вписанием строки либо их разкомментированием в файл pgp.ini: 
				"extension  = pdo_mysql" или "extension=php_pdo".

			СЛУЖЕБНЫЕ МИГРАЦИИ И ТАБЛИЦЫ
				При установки laravel дополнительный устанавливаются миграции и таблици для работы фреймворка. Например для очередей, ошибок выполняния задач.
					"articles" 						- созданная таблица
					"falied_jobs"					- системная таблица. В ней указываются неудачные миграции.
					"migration"						- таблица со списком миграций
					"password_resets"				- таблица авторизации (для восстановления пароля пользователя)
					"password_access_tokens"	- таблица авторизации (для восстановления пароля пользователя)
					"users" 							- таблица авторизации

			ПРОВЕРКА СТАТУСА МИГРАЦИИ
				php artisan migrate:status
				Ввыодит данные из служебной таблицы 'migration'.

			ОТМЕНА МИГРАЦИИ
			Для отмены миграции прописывается команда в терминале:
			Пример:
				php artisan migrate:rollback --step=1
				где, 
					php artisan			- обращение к помошнику
					migrate:rollback	- команда отката миграции
					--step=1				- число шагов отката миграции. 1 - вернуть предудущий вид, 2 - вернуть вид до предыдущего.

				Команда удаления всех шагов миграций:   
					php artisan migrate:reset

			ОБНОВЛЕНИЕ МИГРАЦИИ
				Этот способ предпочтитеьнее в виду меньшего количества операций
					php artisan migrate:refresh == reset + migrate 
					php artisan migrate:fresh == refresh, но производит удаление таблиц без обращения к методу "down". Т.е. напрямую. 
					Команда удаляет изменения и запускает миграции без удаленных изменений. 
					Т.е. refresh не будет работать в случаи удаленный файлов с миграциями, а fresh будет. 
					TODO ВАЖНО! команда "fresh" удаляет все таблицы в базе и даже те, которы были созданы вручную - без миграций. 
					Поэтому в БД рекомендуется хранить таблицы только одного проекта.

			УДАЛЕНИЕ СТРОКИ ЧЕРЕЗ МИГРАЦИЮ
			Для удаления строк в таблице достаточно в файле миграции таблици удалить лишнии строки и запустить миграцию снова. 

			ДОБАВЛЕНИЕ ДАННЫХ В ТАБЛИЦУ
			Ин офрмацию в таблицу можно добавить через интерфейс PHPMyAdmin. 
			А можно через терминал. Команда добавления даных в талицу:
			Для этого нужно задействовать несколько команд. 
				Пример вызова интерфейса для работы с моделью таблицы:
					php artisan tinker 
					где,
					php artisan		- обращение к помошнику
					tinker			- обращение к комнадному интерфейсу для работы с проектом. Например для создания нового объекта на основе модели таблицы. 
											Новый объект - создается как правило для создания новой записи в таблицу в БД. 
				Пример для создания объекта таблицы:
				$article = new App\Models\Article();
					где, 
						$article  						- новый объект 
						new App\Models\Article();	- класс-модель на основе которой создается объект

				
			*/

	echo '<hr><hr><br><h3>Laravel - #12.1-2 - Использование Seeder, Отправка запросов через фасад DB (День 12)</h3><hr><hr>' . "<br>";
		//!Урок 1:  Использование Seeder
		/*
			Миграфии нужны для быстрого составления структуры талицы, но не ее содержания. 
			Таблицу можно наполнять и вручную, однако при удалении таблиц и миграций тогда пропадут и внесенные данные. 
			За наполнение таблицы тестовыми данными отвечают сидеры (Seeder). 
				После восстановления структыры таблицы - она наполняется при запуске сидеров без необходимости ручного наполнения. 
				Адрес сидеров: "database\seeders". 

			СОЗДАНИЯ СИДЕРА
				php artisan make:seeder CommentSeeder
					где, 
						CommentSeeder - название сидера
						Comment - название таблицы/модели
						Seeder - суфикс прилагемый при создании сидера
				TODO ЗАМЕТКА: рекомендуется в имя сидера заключать имя модели таблицы, к которой создается сидер и суффикс, указывающий на создание сидера. 

			ОБЗОР СИДЕРА
				TODO ЗАМЕТКА: Помимо созданного сидера уже имеется сидер "DatabaseSeeder". Именно он будет срабатывать при запуске сидера, ссылаясь на созданный сидер. 
				В каждом сидере имеется только метод "run", срабатывающий при запуске сидера. 
				Пример ссылки на созданный сидер из сидера "DatabaseSeeder":
					$this->call([
							CommentSeeder::class, 
					]);
					где,
						call - меотд ссылающийся на сидеры. Массив с сидерами - аругмент метода
						CommentSeeder::class - вызываемый сидер
					TODO ЗАМЕТКА: созданный сидер находится в одном пространстве имен с сидерем "DatabaseSeeder", поэтому дополнительных подключений не требуется. 
			
			НАПОЛНЕНЕ СИДЕРА
				Вообще для работы сидеров используются "фейкеры" для герерации случайных имен/адресов - данных, но сейчас показывается упрощенный вариант работы. 
				Ниже будет показаны два варианта запроса к БД через сидеры, но только потому, что так можно, а не нужно. Они учебные и не используются на практике.
				Но предпочтительно наполнять сидеры с использованием моделей фейкеров и фабрик. 
				Если коротка на данный момент кажется, что фабрика это посредник между моделью и сидером.

				$names = ['Freed', 'Helga', 'Nicolas', 'Василий', 'Григорий'];
				for ($i=0; $i < 100; $i++) { 
					$post_id = mt_rand(1, 10);
					$name = Arr::random($names); //хелпер, работы с массивом (метод "random" выбирает случайны элемент). 
					$text = Str::random(mt_rand(30, 100)); //хелпер, генерации текста (метод "random" выбирает одно из предложенных значений). 
					$created_at = date('Y-m-d H:i:s');
					$updated_at = $created_at;
					
					1-й способ написания запоса
					DB::insert('INSERT INTO `comments` (`post_id`, `name`, `text`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?, ?)',	[
						$post_id, $name, $text, $created_at, $updated_at
					]);

					2-й способ написания запоса (предпочтительнее)
					DB::table('comment')->insert([
						'post_id' => $post_id, 
						'name' => $name, 
						'text' => $text, 
						'created_at' => $created_at, 
						'updated_at' => $updated_at
					]);
				}
			
			ЗАПУСК СИДЕРА
				php artisan db:seed - запуск сидера
					ЛИБО
				php artisan migrate:refresh/fresh --seed - перезапись миграции и запуск сидера
		*/

		//!Урок 2:  Отправка запросов через фасад DB
		/*
			В этому уроке разберемся как взаимодействовать с данными в БД через Laravel. 
			Для работы с БД в Laravel используется фассад "DB". Хотя на практике им практически не придется пользоваться. 
			Только в случаи супер сложных запросов с JOIN, котрые сложно будет составить через построитель запросов.
				В этом разберем первый способ (с синтаксисим SQL) из предыдущего урока, а второй (через посторитель запросов) в следующем. 
				Для взаимодействия с БД в этот раз создадим контроллер. 
				Очистим таблицу, наполненную в предыдущем уроке через сидер. 

					Примеры использования основных методов фассада DB:
						Пример с DB::selsct():
							DB::select('SELECT * FROM `comments`');
						Пример с DB::update():
							DB::update('UPDATE `comments` SET `post_id` = ? WHERE `post_id` = ?', [4, 10]); //значения массива это соотетственно 1-й и 2-й вопросы
						Пример с DB::insert():
							DB::insert('INSERT INTO `comments` (`post_id`, `name`, `text`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?, ?)',	[
								$post_id, $name, $text, $created_at, $updated_at
							]);
						Пример с DB::delite():
							DB::delete('DELETE FROM `comments` WHERE `name` = :name', ['name' => 'Freed']);
						Пример с DB::transaction():
							DB::transaction(function(){
								DB::insert('INSERT INTO `comments` (`post_id`, `text`) VALUES (?, ?)',	[2, 'Lorem, ipsum dolor.']);
								DB::update('UPDATE `comments` SET `post_id` = ? WHERE `post_id` = ?', [4, 10]);
							});

						TODO ЗАМЕТКА: метод transaction() принимает в качестве аргумента collback-функцию с методами, которые должны быть выполнены обязательно вместе. В случаи ошибки при выполнении одного из методов - результат второго метода отменяется. Закрепляется результат только успешного выполенния всех методов в связке.
							Эта функция может понадобиться, когда нужно чтобы у каждого зарегистрированного пользователя принимался секретный вопрос, без которого регистрация пользователя недопустима. Если не так, то пришлось бы удалять пользователя вручную. 

						ВЫВОД ДАННЫХ
							Перед выводом создадим больше строк в БД (5) через сидер:
								php artisan migrate:fresh --seed

							Набор выводимых данных является масивом. 
							TODO ЗАМЕТКА: переменная с содержимым запроса является массивом, а каждый элемент массива является объектом. 
								Функция для проверки типа аргумента: gettype($dataComment/$var);
							foreach ($dataComment as $var) {
								echo 'Айдишник: '.$var->id.'<br>';
								echo 'Айдишник поста: '.$var->post_id.'<br>';
								echo 'Имя: '.$var->name.'<br>';
								echo 'Текст: '.$var->text.'<br>';
								echo 'Время создания: '.$var->created_at.'<br>';
								echo 'Время обновления: '.$var->updated_at.'<br>';
								echo '-_-_-_-_-_-_-_-_-_-_-_-'.'<br>';
							}
		*/

	echo '<hr><hr><br><h3>Laravel - #13.1-1 - Построение запросов (День 13)</h3><hr><hr>' . "<br>";
		//!Урок 1: Построение запросов
		/*
			В прошлом уроке мы строили запросы через пропись SQL синтаксис. Сегодня разерем построение построители запосов. 
			Запрос через построители подпразумевает функцию "DB::table('tableName');", после которой следует запрос в виде метода, а не SQL кода.
			
			ОСНОВЫНЕ ОПЕРАЦИИ построителя запросов (QueryBuilder):
				1) ->insert();
					Аргументом выступает массив, где ключ == поле таблици, значение ключа = значение поля.
					Пример с ->insert();
						DB::table('comment')->insert([
							'post_id' => '5',
							'name' => 'Леха',
							'text' => 'некоторый текст'
						]);
					где,
						table - функция обращения к таблице
						insert - метод запроса
						post_id/name... - название полей таблицы
						5/Леха... - значения полей таблицы
						TODO: ЗАМЕТКА: в таблицу может понадобиться записать несколько строк. В таком случаи через в методе "insert" заносится многомерный массив из несколько массивом, каждый из который заполнен данными новой строки.
						Пример:
							DB::table('comment')->insert([
								['post_id' => '2', 'name' => 'Леха', 'text' => 'некоторый текст1'],
								['post_id' => '5', 'name' => 'Вася', 'text' => 'некоторый текст2'],
								['post_id' => '6', 'name' => 'Федя', 'text' => 'некоторый текст3']
						]);
				2)	->update();
					Метод "update" работает вкупе с выборкой в отличии от метода "insert()", которому выборка не нужна. 
					Выборка имеет аргумент в виде поля и его значения в таблице. 
					Аргументом выступает массив, где ключ == поле таблици, значение ключа = значение поля.
					Пример с ->update();
						DB::table('comments')->where('post_id', 5)->update([
							'post_id' => '2'
						]);
					где,
						['post_id' => '2'] - аргумент метода обновления
						Смысл записи в замене в таблице полей 'post_id' со значением == 5 на значение 2. 
				3)	->increment();
					Аргументом выступают поле таблицы с типаом данных "число" и целое число, на которое повышается в аргументе. 
					Пример с ->increment();
						DB::table('comments')->where('post_id', 2)->increment('post_id', 10);
					где,
						increment - метод повышения числа
						10	- значение на которое повышается выбранное число. Итого поля 'post_id' == 2 становятся 'post_id' == 12
				4) ->delete();
					Аргумент не обязателен. Удаляет строки, найденные выборкой. 
					Пример с ->
						DB::table('comments')->where('post_id', 12)->delete();
				5) ->select();
					Аргументом выствпает название нужного поля или массив из выводимых полей строки. 
					Пример:
						а) DB::table('comments')->select('id')->where('post_id', 3)->get(); 
						б) DB::table('comments')->select(['post_id', 'name'])->where('post_id', 3)->get(); 
					TODO ЗАМЕТКА: метод select() позволяет выводить конкретные нужные значения строки, а не всю строку сразу.

				ВЫБОРКА ЗАПРОСА
					Методы фассада DB	по извлечению данных
						1) ->get();
							Метод вывода информации из выборки. Может работать без методе "where()", тогда будет выводиться вся таблицы. 
							Пример с ->get();
							а) $comments = DB::table('comments')->get(); //без метода выбоки
							б) $comments = DB::table('comments')->where('post_id', 1)->get(); //с методом выборки
						TODO ЗАМЕТКА: переменная, вмещающая в себя данные полученные через построитель запросов называется "КОЛЛЕКЦИЕЙ", но работают с ней как с массивом. 
						2) ->first();
							Метод выводит одну первую записи из выборки. Может работать без методе "where()", тогда будет выводиться вся таблицы. 
							Пример с ->get();
								а)$comments = DB::table('comments')->where('post_id', 1)->first(); // вывод одной записи, подпадающий в выборку
								б)$comments = DB::table('comments')->first(1); //вывод записи с ID == 1
						TODO ЗАМЕТКА: переменная, вмещающая в себя данные полученные через построитель запросов методом first() уже является объектом, а не "КОЛЛЕКЦИЕЙ".
						3) ->where();
						а/в) Аргементами выствпают название поля, значение поля и знак сравнения (>, <, <= ...). Или оператор "LIKE".
						д) whereBetween() - значения равные от а до б.
						е) whereNotBetween() - значения НЕ равные от а до б.
						ё) whereIn() - значения равные а или б.
						ж) whereNotNull() - поле не ровно нулю
						з) whereNull() - поле ровно нулю
						и) Orwhere() - метод пишушийся в паре с методом where(), с которым связывается оператором "OR" (ИЛИ).
						к) where(function($query){...}->OrWhere() - вывод двойного условия 
						л) 
						м)

						Метод используется в связке с методоми обработки/вывода данных. 
						TODO ЗАМЕТКА: Для добавления второго и более условия выборки - прописывается еще один метод ->where('if_1')->where('if_2'); вслед за первым.
						Пример с ->where();
							а) DB::table('comments')->where('post_id', '>', 1)->first(); вывод значения больше == > 1
							б) DB::table('comments')->where('post_id', 4)->get(); вывод значений == 4
							в) DB::table('comments')->where('post_id', 'LIKE', %нн%)->get(); вывод значений, содержащих в имени "нн"
							г) DB::table('comments')
								->where('post_id', 'LIKE', %нн%)
								->where('post_id', '>', 4)->get(); запись нескольких условий выборки
							TODO ЗАМЕТКА: между двумя условиями метода ->where()->where() подразумевается оператор "AND". 
							д) DB::table('comments')->whereBetween('id', [2, 4])->get(); вывод значений равных от 2 до 4
							е) DB::table('comments')->whereNotBetween('id', [2, 4])->get(); вывод значений НЕ равных от 2 до 4
							ё) DB::table('comments')->whereIn('id', [2, 4])->get(); вывод значений равных 2 ИЛИ 4
							ж) DB::table('comments')->whereNotNull('post_id')->get(); выыод строк, где поле не ровно нулю
							з) DB::table('comments')->whereNotNull('post_id')->get(); выыод строк, где поле ровно нулю 
							и) DB::table('comments')
								->where('post_id', 3)
								->Orwhere('post_id', '=>', 5)->get(); запись нескольких условий выборки
							к)	DB::table('comments')->where(function($query){
									$query->where('post_id', 6)->where('name', 'Helga');
								})->OrWhere('post_id', 3)->get();
								Эта запись эквивалентна этой:  'where(`post_id` = 6 and `name` = 'Helga') OR `post_id` = 3';
							TODO ЗАМЕТКА: для записи более сложных запросов в методе выборки пишется callback-функция с условием выборки. 
							л) 
							м)
						4) ->orderBy()/orderByDesc();
						Аргументмо является поле, по которому проводится сортировка. 
						Пример:
							а) DB::table('comments')->orderBy('name')->get(); //вывод строк по сортировки по полю
							б) DB::table('comments')->orderBy('name')->orderBy('post_id')->get(); //вывод строк по сортировки по двум полям
								Т.е. внутри строк отсортированных по одному полю включается следующая сортировака по второму полю.
							в) DB::table('comments')->orderBy('name', 'desc')->get(); //вывод строк по полю в обратной сортировки
							г) DB::table('comments')->orderByDesc('name')->get(); //вывод строк по полю в обратной сортировки
							TODO ЗАМЕТКА: обратный порядок сортировки в методе orderBy() задает второй аргумент 'desc'.
						5) ->inRandomOrder();
						Метод вводит в случайном порядке строки. 
						Пример:
							DB::table('comments')->inRandomOrder()->get();
						6) ->limit();
						Аргументом выствпает число записей над которыми будет проиведены операции
						Пример:
							$comments = DB::table('comments')->limit(5)->offset(3)->get();
						7) ->offset();
						Аргументом выствпает число записей, которые будут игнорироваться при выводе. 
						Пример:
							$comments = DB::table('comments')->limit(5)->offset(3)->get();
						8) ->count();
						Метод выводит число. 
						TODO ЗАМЕТКА: Метод ->count() извелекает дыннеданные так же как и методы ->get(), ->exists() и ->first(). Поэтому они не ставялся в одном запросе.
							а) DB::table('comments')->count(); //вывод количества записей
							б) DB::table('comments')->where('post_id', 1)->count(); //вывод количества записей из выборки
						9) ->min();
						Аргументмо метода выступает поле, минимальное значение которого нужно вывести. 
						Пример:
							DB::table('comments')->min('post_id'); 
						10) ->max();
						Аргументмо метода выступает поле, максимальное значение которого нужно вывести. 
						Пример:
							DB::table('comments')->max('post_id'); 
						11) ->avg();
						Аргументмо метода выступает поле, среднее значение которого нужно вывести. 
						Пример:
							DB::table('comments')->avg('post_id'); 
						12) ->sum();
						Аргументмо метода выступает поле, суммарное значение которого нужно вывести. 
						Пример:
							DB::table('comments')->sum('post_id'); 
						13) ->exists();
						Метод выводит булево значение о наличии хотя бы одного поля с данным значением. 
						Пример:
							$comments = DB::table('comments')->where('post_id', 1)->exists();
						
						При написании запросе через QueryBuilder бывает проблематично найти ошибку в написанном запросе. 
						14) ->dd();
						Метод dd() при применении к запросу выводит его форматв SQL синтексисе. 
						Пример:
							Написание запоса через QueryBuilder => 
								DB::table('comments')->where('post_id', 1)->dd();
							Вывод содержимого запроса на экран через функцию => 
								"select * from `comments` where `post_id` = ?"
							Подставляемые значения в запрос =>
								array:1 [ 
									0 => 1
								▼]
							
							Этот метод стоит вызывать при ошибках запроса или не ожидАемом результате. 
						TODO ВАЖНО! Это метод, который часто используется для отладки. О нем стоит помнить. 
						15) ->chunk();
						Метод разбивает коллекцию на несколько более мелких коллекций заданного размера.
						TODO ЗАМЕТКА: Метод "chunk()" нужен для избежания нехватки оперативной памяти, когда изначально выводимая коллекция весьма объЁмна. На очень большой запросы ее може не хватить, поэтому он дробится на более мелкие и выводится по частям.
						Допустим нужно извлечь все записи таблицы с сортировкой по "id". 
						Аргументами метода являются во первых - количество записей в отдельной группе, во вторых - замыкание с переменной, хрянящее записи в колличестве первого аргумента, т.е. коллекцию. В теле замыкания пишится код вывода полученных записей. 
						Предварительно до помещения в замыкание переменная с коллекцией не объявляется.
						Пример:
							DB::table('comments')->orderBy('id')->chunk(2, function($comments){
								foreach ($comments as $comment) {
									print_r($comment);
									echo '<br>';
								}
								echo 'Chank end<br><hr>';
							});
							где,
								2 - количество записей в передаваймой в замыкание коллекции
								$comments - передаваемая коллекция
								foreach(...){...} - вывод коллекции
								echo 'Chank end<br><hr>'; - завершение иттерации вывода первой пачки данных в виде малой колекции, записанных в замыкание (2 шт).
							16) ->lazy();
							Это возможно более удобный аналог "chunk();", но и более медленный, так как большие запросы делятся на подколлекцию с 1-м элементом. Метод максимально экономит оперативку и нагружает БД. 
							Т.е. запись lazy()->each(function($comment){...}); == chunk(1, function($comments){...};
							Аргументом выстапет переменная, хранящая запись строки.
							Пример:
								DB::table('comments')->orderBy('id')->lazy()->each(function($comment){
									print_r($comment);
									echo '<br><hr>';
								});
							Так как в малую коллекцию кладется только один элемент/строка, то для ее вывода цикл не требуется. 

							ИТОГО: текущего набора методов для построаения бОльшего количества запросов вполне себе достаточно.
							Что до InnerJoin'в, то на практике они встречаются редко и с информацией по ним можно ознакомиться в докумнетации.							
		*/

	echo '<hr><hr><br><h3>Laravel - #14.1-1 - Навигация по страницам (День 14)</h3><hr><hr>' . "<br>";
		//!Урок 1: Навигация по страницам
		/*
			Пагинация без фреймворка требует самостоятельного расчета количества страниц, записей, формирования ссылок на страницы. 
			В laravel доступ ко всему этому полагается через метода paginate(); Он является последним методом запроса так же как get() || first();
			Он прилагается к запросу к БД, формируя данные нужные для пагинации дполученных данных из запроса. 
			Аргументом метода paginate(); является число строк, выводимых на странице. 
			Метод возвратщает объект (НЕ коллекцию), имеющий доступ к методом настройки пагинации на странице.
			
			Пример:
				$comments = DB::table('comments')->paginate(10);
					return view('pagination', ['comments' => $comments]);
				где,
					$comments - объект пагинации, которому доступны методы работы с пагинацией в шаблоне
				TODO ЗАМЕТКА: объект пагинатора так же реализует интерфейс итератора. Т.е. прогоняется через цикл как массив. 
				
			Обычно для вывода ссылок пагинации требуется отдельаня верстка и это так, но она может выводится за счет встроенного в laravel фреймворка tailwind css.
				Есть и другие (например bootstrap 4), но рассмотрим tailwind.
			TODO ЗАМЕТКА: если же требуется самому пропиать верстку пагинации - для этого прописывается команда: "php artisan vendor:publish --tag=laravel-pagination". 
				Эта команда копирует директорию работы с пагинации из захрамов laravel в указанную нами папку и дает ей приоритет чтения. Такой же прием уже использовался в теме "пользовательские страницы ошибок". 
				Этот шаблон и используется для отображения пагинации "resources\views\vendor\pagination\tailwind.blade.php".
				Рассмотрим методы прописанные в этом шаблоне и на их основе сделаем свою версию пагинации. 

			МЕТОДЫ ОБЪЕКТА-ПАГИНАТОРА
				1) ->currentPage(); - Метод вывода номера страницы. 
					Пример:
						<h1>Комментарии (Страница {{ $comments->currentPage() }})</h1> == Комментарии (Страница 1)
				2) ->links(); - Метод выводящий ссылки на страници пагинации (предыдщая следующая и т.д.)
					Пример:
						{{ $comments->links() }}
				3) ->hasPages(); Метод проверяет объект на наличие хотя бы одной страницы. 
					Пример:
						$paginator->hasPages();
				4) ->onFirstPage(); Метод проверяет нахождение на первой странице.
					Пример:
						$paginator->onFirstPage();
				5) ->hasMorePages(); Метод проверяет наличие оставшихся невыведенных страниц с учетом выведенных. 
					Пример:
						$paginator->hasMorePages();
				6) ->previousPageUrl(); Метод выводит ссылку на предыдущую страницу
					Пример:
						$paginator->previousPageUrl();
				7) ->nextPageUrl(); Метод выводит ссылку на слудующую страницу
					Пример:
						$paginator->nextPageUrl();
				8) ->firstItem(); Метод выводит порядковый номер выводимого списка у первого элемента на текущей странице. 
					Т.е. если выводимых элементов 20, а записей на странице 5, то на второй странице метод будет выводить 6. 
					Пример:
						$paginator->firstItem();
				9) ->lastItem(); Метод выводит порядковый номер выводимого списка у последнего элемента на текущей странице. 
					Т.е. если выводимых элементов 20, а записей на странице 5, то на второй странице метод будет выводить 10. 
					Пример:
						$paginator->lastItem();
				10) ->count(); Метод выводит число выводимых элементов на одной странице. 
					Пример:
						$paginator->count();
				11) ->total(); Метод выводит число всех выводимых элементов на страницах. 
					Пример:
						$paginator->total();

				Напришем отдельынй шаблон для пагинации и присоеденим его к основному шаблону.
				Пример:
					Ссылка в основном шаблоне на шаблон панигации:{{ $comments->links('mypagination') }}
					где,
						mypagination - шаблон пагинации
					TODO ЗАМЕТКА: в это место можно подключать шаблоны, также встроенные в laravel. Например тот же bootstrap-4/5: "vendor.pagination.bootstrap-5".
					Код в шаблоне пагнации:
						@if ($paginator->hasPages())
							<nav>
								{{-- Pagination Elements --}}
								@foreach ($elements as $element)
								{{-- "Three Dots" Separator --}}
								@if (is_string($element))
									<span> 
										<span>{{ $element }}</span>
									</span>
								@endif

								{{-- Array Of Links --}}
								@if (is_array($element))
									@foreach ($element as $page => $url)
											@if ($page == $paginator->currentPage())
												<span>
													<span>{{ $page }}</span>
												</span>
											@else
												<a href="{{ $url }}">{{ $page }}</a>
											@endif
									@endforeach
								@endif
							@endforeach
							</nav>
							@endif
				
				Выведенный список страниц:
					1 2 ... 7 8 9 10 11 12 13 ... 19 20
		*/
