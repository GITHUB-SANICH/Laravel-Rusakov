
<?php
	echo '<hr><hr><br><h2>Модуль №1.1-4:  Введение (День 1)</h2>' . "<br>";

	//!Урок 1: Как проходить курс?
	/*
		Курс разработан на прохождение за 40 дней. Поэтому темы урока будут получать пометку о порядковом номере для. 
		В заглавии первая цифра до точки обозначает первый день темы день. Остальные дни прохождения темы. 
		В каждом дне имеется несколько уроков. Цифра до точки будет означать день обучения. Первая цифра после точки - порядковый номер урока. 
		Доступ к следующему дню становится доступен после выполнения всех заданий предыдущего дня.
		По прохождению всего учебного материала курса - становится доступен финальный тест по выполнению которого - выдается сертификат по прохождению курса. 
		Для выполнения теста - ошибки недопустимы. Количество попыток для выполнения курса - неограничено.
	*/

	//!Урок 2: Особенности Laravel
	/*
		Приемущества Laravel:
			1. Открытый исходный код
			2. Универсальный (любой проект можно сделать на laravel) - на самом деле нет)
			3. Использование PHP
			4. Высокая безопастность из коробки 
			5. Поддержка MVC
			6. Подходит для Higload-проектов (легко масштабировать)
			7. Очень популярный
			8. Бесплатный 

		Как работает laravel изнутри:ъ
			1. Запрос от клиента поступает в index.php
			2. Создается экземпляр приложения Laravel
			3. Запрос передается в HTTP-ядно
			4. Запускается базовые механизмы: настройка логирования, обработка ошиболк и т.п.
			5. Происходит настройка провайдеров, включая маршрутизация
			6. Запрс передается маршрутизатору
			7. Муршрктизатор передает запрос посредникам (мидлварам - для фильтрации запросов например) 
			8. Маршрутизатиор передает запрос соответствующему коноотроллеру
			9. Посредник и контроллеры формулирубют ответ
			10. Ответ возвратщается клиенту

		Процесс создания сайта на Laravel
			1. Установка необходимого ПО
			2. Установка и настройка laravel
			3. Создание моделей, включая создание базы данных
			4. Настройка маршрутизации
			5. Создание шаблонов
			6. Создание контроллеров
			7. Обработка форм
			8. Различные мелочи (например, содание страницы 404)
	*/

	//!Урок 3: Установка необходимого ПО
	//!Урок 4: Установка Laravel
		/*
			Установка Composer
				php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
				php -r "if (hash_file('sha384', 'composer-setup.php') === '55ce33d7678c5a611085589f1f3ddf8b3c52d662cd01d4ba75c0ee0459970c2200a51f492d557530c71c15d8dba01eae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;"
				php composer-setup.php
				php -r "unlink('composer-setup.php');"
			Установка Laravel
				php composer.phar create-project laravel/laravel test
		*/

		echo '<hr><hr><br><h2>Модуль №2.2-10:  Основы Laravel</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #2.1-2 - Структура директорий, Конфигурирование (День 2)</h3><hr><hr>' . "<br>";
		//!Урок 1: Структура директорий
		/*
			Список папок и из назначений:
				app - это папка в которой находятся модели, контроллеры, провайдеры, классы по отслеживанию ошибок;  
			Провайдеры - это файлы, описывающие глобальный функционал. Например "RouteServiceProvider" - отвечает за процесс отслеживания URL адресов внутри проекта. 
			Итого: Папка "app" - рабочая папка в которой описывается работа моделей, контроллеров, провайдеров, посредников и возможно дополнительными файлами. 
		bootstrap - это папка, хранящая файл с классами, запускающимися вместе с проектом. 
			В этой папке не придется ничего менять. В этой папке находится файл "app.php", который запускается вместе с проектом.  
			В файле перечисляются/описываются классы, которые запускаются вместе с проектом. 
			Итого: папка отвечает за описание классов, запускающихся вместе с проектом. 
		config - это папка хранящая различные файлы конфигурации. Например файл подключения к БД с параметрыми подключения. 
			Или файл с настройками авторезации и регистрации, отправки почты и т.д. 
			Итого: папка хранит настройки работы сайта, которые могут отвеать за работы почты, авторизации или подколючения к БД. 
		database - папка, хранящая папку с миграциями и отвечает за описание всей базы данных.  
			В этой папки возможно понадобится папка "migration". В ней находятся разные файлы миграции. Они создаются автоматически. 
			Миграции - файл, в котором записана история изменения объектов БД (н.п. таблица). 
			Грубо говоря миграция - это система контроля версиий для объекта БД. 
				Когда разрабатываешь веб-приложение в команде на нескольких машинах, рано или поздно сталкиваешься с проблемой синхронизации кода проекта и базы данных. Для управления кодом есть системы контроля версий, в частности, git, а для СУБД придуманы миграции.
				Миграции позволяют управлять базой данных не заходя в интерфейс PHPMyAdmin. 
			seedrs - файл, позволяющий наполнить созданную таблицу данными. 
			Итого: папка database хранит в себе описания всей базы данных. 
			
		lang -  папка служит для разных языковых версий сайта. 
			Например есть возможность вывода отображения определенных ошибок на определенном языке. 
			Итого: папка служит для разных языковых версий сайта и языковых версий ошибок.  
		public - папка хранит в себе файлы, отображаемые для пользователя, а так же файл с настройкой сервера "htaccess". 
			Например index.php - этот файл не потребуется никак видоизменять, так как он занимается в основном подгрузкой других файлов. 
			В том числе файл app.php из папки bootstrap. Файлы index.php и app.php посути запускают проект. 
			Ничего в этой папки менять не придется. 
			Итого: папка хранит в себе файлы отображаемые на сайте. Здесь хрангиться также различные медиафайлы - то, что должен увидеть пользователь. 
		resources - папка рабочая, в которой прописывается css, js, views (а вней шаблоны с HTML файлами). 
			В папке views таки и находится шаблон стартовой страницы laravel. В ходе обучения разберем парядок вызова шаблонов и работу с ними. 
			Итого: папка хранит в себе HTML шаблоны, CSS, JS. 
		routes - папка предоставляет функционал, позволяющий работать с URL адресами проекта - то есть URL нашего сайта.
			Например в файле web.php описываются URL, отслеживаемые на сайте проекта. Например описывается условие перехода на шаблон главной страници при переходе по ссылке "/". 
			api - запрос по api
			channels - запрос по каналам
			console - запрос в консоль
			web - запрос
			Итого: в папке находятся файлы, позволяющие отслеживать переходы пользователя по разным URL адресам проекта.
		storage - это папка-хранилище, в ней находится кэш; файлы, созданные внутри проекта, логи. Так же в эту папку попадают файлы пользователя. 
			Итого: в папке хранатся разные сохраненные файлы, кэш и логи проекта. 
		tests - папка с классами UNIT тетированиея. 
			В папке уже имеется небольшой набор классов (в том числе базовый) для проверки работоспособности проекта и Unit тестирования впринцепи. 
			Итого: папка содержитклассы Unit тестирования. 
		vendor - папка хранит в себе скаченные библиотеки через Composer. 
			Итого: папку трогать не нужно. 
		По ходу работы с проектом он может наполнятся дополнительными папками и файлами - например политикой - папка с правами
	ФАЙЛЫ: 
		.editorconfig - файл с настройками текстового редактора. 
			Итого: трогать файл не стоит. 
		.env - файл важный, так как в нем указываются глобальные настройки длоя всего проекта. 
			Например название проекта, секретный ключ  - этот ключ нужен для безопастности проекта - он встраивается в подпись для каждой формы.
			Это обеспечивает безопастную передачу данных на сайте. 
			APP_DEBUG - нужен для вывода или отключения вывода ошибок на вебсайте. Его лучше отключить, если сайт находится на хостинге. Так как вывод ошибок считается лазейкой в безопастности. Эту настройук можно включить при работе на локальном сервере для правок. На боевом не стОи.
			APP_URL - настройка с URL сайта. 
			Имеются настройки подключения к БД (порт, название БД и т.д.). Настройки для SMTP сервера. 
		.env.example - файл используется в качестве файла примера, чтобы вы знали, какие пары KEY = VALUE вам нужны для вашего проекта. Чаще всего его 		используют для копирования в файл .env и последующего изменения значений.
		.gitattributes, .gitignore - файлы с настройками игнорируемых файлов на локальный и удаленный репозитории git'а. 
		.styleci.yml - файл, в котором находятся настройки нескольких базовых контейнеров при работе с докером. Пример: JS, finder, laravel. 
		artisan - файл-помошник при работе с laravel. Файл трогать не нужно, в нем перечислины настройки этого помошника. 
		composer.json - описание зависимостей библиотек в проекте  
		composer.phar - главный файл Composer 
		composer.lock - логи работы в Composer 
		package.json - файл, аналогичный файлу composer.json. Но composer.json - нужен для описания зависимостей библиотек для серверной части, 
			а 	package.json - для зависимости клиентской части. В нем тоже описываются разные библиотеки, но для корректной работы клиентской части. 
			Например Bootstrap или SASS. Библиотеки, описанные в package.json можно так же установить через NPM (другой пакетный менеджер). 
			С этим файлом будем работать в  момент создания дизайна для проекта.
		phpunit.xml - файл с настройками для Unit тестированиюя внутри проекта.  
		README.md - файл, нужный для выгрузки проекта в репозиторий. Из него создается основная страница на удаленном репозитории. 
			В файле имеется текстовое описания содержимого проекта. 
		webpack.mix.js - файл, конвертирующйи JS и CSS файлы и из папки "resources" внутрь папки "чpublic". 
			Эта конвертация сделает JS, CSS файлы написаныне через SASS или View/React в понятный для браузера формат. 

		Запоминать все папки, файлы и их назначения сложно и не нужно, так как с основынми из них еще предстоит работать, а стальные не нуждаются 	 вболее подробном объяснении, так как с ними работать почти не придется.  
		
		TODO ВАЖНО! Команды остановки локального сервера: ctrl+c (в терминале). Тогда при перезагрузки страницы проект не запустится.  
		*/
			

	//!Урок 2: Конфигурирование
	/*
		Настройки Laravel находятся в папке "config". Там находятся настройки для всего приложения - кеширование, логирование, почта и.т.д.
			К этой папке будем периодически обращаться по ходу обучения и надобности.
		В общем файл с настройками выглядет как функция retern, возратщающая ключ (настройка) и его значение.
		Часто файлы из папки config ссылаются на файл .env. (например конфиг "app") Т.е. дополнительон считывать и парсить этот файл для других конфигов не нужно. 
			Пример:
				'name' => env('APP_NAME', 'Laravel'),
				где, name - настройка, env - файл с параметром,  APP_NAME - название с параметром, 'Laravel - значение.
		Так же в файле app есть настройкаи часового пояса (timezone), языка сайта (local).
			Local можно накостылить и записать русский перевод в английской версии сайта, но это не про качество. 
			name	- имя проекта
			url	- ссылка на проект
			env	- среды выполнения приложения (продакшен или локал)
			debug	- вывод или отсутствие вывода ошибки на страницу
			fallback_locale - настройка с языком, выбранным в случаи отсутствия записи в языке, указнном в Local.
			faker_locale	- язык для фейковой таблицы.
			providers	- важная настройка, подключающая провайдеры

		Некоорые параметры отсутствуют в файле .env, поэтому они вжесткую прописываюстя в вайле app.php
		Пространства имен фреймворка и приложения
		iluminate - часть пространства имен настроек, относящихся к фреймворку
		App - часть пространства имен, относящаяся к проекту
		.env - файл важный, так как в нем указываются глобальные настройки длоя всего проекта. 
	*/

	echo '<hr><hr><br><h3>Laravel - #3.1-2 - Знакомство с Artisan и режим обслуживания, Маршрутизация (День 3)</h3><hr><hr>' . "<br>";
		//!Урок 1:  Знакомство с Artisan и режим обслуживания
		/*
			1) В этом уроке научимся вводить и выводить сайт из режима обслуживания. 
			2) Использовать artisan. Его файл предстваляет собой обычный php скрипт. 

			КОМАНДЕ ПЕРЕХОДА В РЕЖИМ ОБСЛУЖИВАНИЯ:
				php artisan down
				Команда обслуживания по определенному ключу:
					php artisan down --secret="mysecret-123456"
					где,
					--secret 			- атребут объявления ключа доступа к сайту в режиме обслуживания
					mysecret-123456	- ключ доступа к сайту в режиме обслуживания
					Пример ссылки, открывающей доступ к сайту в режиме обслуживания:
						https://site.ru/mysecret-123456
						Доступ к сайту в режиме обслуживания предоставляеся мидлваром, настроенным через artisan
			КОМАНДЕ ВЫХОДА ИЗ РЕЖИМА ОБСЛУЖИВАНИЯ:
				php artisan up
			
			Функкционал работы с сайтом в режиме обслуживания через пароль (--secret="") обеспечивается посредниками (midlware), так как фильтрует запрос. 
			РЕЖИМ ОБСЛУЖИВАНИЯ закрывает доступ к приложению во время технических работ/обновлений в целях безопастности. И чтобы пользователи не видели никаких ошибок во время правок. 
		*/

		//!Урок 2: Маршрутизация
		/*
		В этом уроке будут разобраны маршрутизация, правила маршрутизации; мидлвары и как с ними работать.

		Настройки маршрутищации указаны в файле "app\Providers\RouteServiceProvider.php", который ссылаеися на файл "routes\web.php".
			При необходимости можно создать и самим дополнительные файлы с настройками маршрутизации и ссылаться на наих в провайдере. 
		Можно перечислять через функцию "match" типы запросы, которые будет обрабатывать URL => Rote::match(['get', 'post'], /contracts, function(){});
		Или прописать выполнение всех запросов => Rote::any(['get', 'post'], /contacts, function(){});
		Пример обработки динамического урла =>  Rote::get(/user/{id}, function($id){});
			В случаи наличия одинакового адреса маршрутов - приоритет чтения предоставляется самому нижнему в списке маршруту. 

		REQUEST	- это служебный класс, зависимостей, работающий с телом запроса. Через него можно вывести оттельное значенеи из запоса. 
			Rote::get(/user/{id}, function($id, REQUEST $requests){
				echo $requests->patch(); //вывод id пользователя
			});

		Можно прописывать маршрутизация с необазательными параметрами:
			Rote::get(/user/{id?}, function($id='not found user'){
				return 'user: '.$id;
			})->where('id', ['0-9']+);
			где, 
				"?" - проверка на наличие, 
				$id='' - значение параметра по-умолчанию.
				)->where('id', ['0-9']+); - регулярное выражение, обязывающее подставлять только числа. 
					ИЛИ )->whereNubber('id');	- проверка на тип число
					ИЛИ )->whereAlpha('messange'); - проверка на тип строки			
				Допустима проверка на несколько параметров - например на сообщение. Но для этого есть отдельные средства в контролере.
			
		Для каждого прописынного маршрута можно прописывать определенные имена - псевданимы, но об этом позже.
			Пример: )->name('news_id');
		
		Пример редиректа в случаи если определенная страница переехала на другой адрес:
			Rote::redirect('/before_str{id}', 'after_str{id}'); //301
			Rote::permanentRedirect('/before_str{id}', 'after_str{id}'); //302
		Есть два редиректа это 301 (пример выше) и 302: времено и навсегда. 
	
	
		*/

	echo '<hr><hr><br><h3>Laravel - #4.1-3 - Ограничение частоты запросов, Посредники, Контроллеры (День 4)</h3><hr><hr>' . "<br>";
		//!Урок 1:  Ограничение частоты запросов
		/*
			Для любого проекта требуется в целях оптимизации ставить ограничение по запросам.
			Настройки ограничения запросов находятся в провайдерах "app\Providers\RouteServiceProvider.php".

			Прмиер маршрута, обрамленного префиксом и посредником:
				Route::group(['prefix' => 'feedback', 'middleware' => 'throttle:test_RateLimiter'], function(){ //передача посреднику настройку ограничения запросов
					Route::get('/', function () {return 'feedback';});
					Route::get('/user', function () {return 'feedback-user';});
				});
		*/
		//!Урок 2: Посредники
		//?Задание №2.3 не пройдено:
		/*
			Создайте посредника, который будет пропускать запрос к созданному маршруту только при условии наличия параметра key=123456 (для получения параметра можно использовать конструкцию $request->input('key')).
			МАРШРУТ:
			Route::middleware("throttle:test_RateLimiter")->group(function () {//передача посреднику настройку ограничения запросов
				Route::get('/controller-first/{key}', [App\Http\Controllers\FirstController::class, 'index']);
			});
			ПОСРЕДНИК:
			class CheckLocalhost
			{
				public function handle(Request $request, Closure $next): Response
				{
					if($request->ip() == '127.0.0.1') return $next($request); //пропуск запросу по определенному IP	
					if($request->input('key') == 12345) return $next($request);
					abort('404'); //при отсутствии нужного IP выдавать error 404
				}
			}
		*/
		/*
		Middleware - разновидность классов, работающих с запросами фильррую/дополняя его и т.д.
		Например если запрос выходил за рамки допустимого размера - от он отбраковывается мидлваром.
		В Laravel уже имеется достаточно своих посредников, но можно создавать и свои через artisan => php artisan make:middleware CheckLocalhost
		Создадим посредник, фильтрующий пользователей по IP.
			Пример:	
				public function handle(Request $request, Closure $next): Response
				{
					if($request->ip() == '127.0.0.1') return $next($request); //пропуск запросу по определенному IP	
					abort('404'); //при отсутствии нужного IP выдавать error 404
				}
				где, $next($request); - разрешение на дальнейшее выполнение запроса
		Но чтобы посредник заработал его нужно зарегистрировать в файле "app\Http\Kernel.php". 
		Пример:	
			'checklocalhost' => \App\Http\Middleware\CheckLocalhost::class,

		Проверка работы посредника:
			

		В дальнейшем к мидлвару возможно понадобиться обращаться и для удобства они обертуты в псевданим в файле "laravel\app\Http\Kernel.php".
			Пример:  'auth' => \App\Http\Middleware\Authenticate::class,
				где, 
					'auth' - псевдоним мидлвара
					\App\Http\Middleware\Authenticate::class - мидлвар 

		Вызов группы мидлваров может происходить при вызове префиксов. Обращаясь к псевдониму "web" или "api" вызывается группа мидлваров. 
			Пример: 
			protected $middlewareGroups = [
         'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            // \Illuminate\Session\Middleware\AuthenticateSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
         ],

         'api' => [
            // \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
            'throttle:api',
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
         ],
      ];
		Вызов мидлваров префикса api будет вызван в файле Providers\RouteServiceProvider.php если ссылка будет иметь вид например: "localhost.com/api"
		В файле Providers\RouteServiceProvider.php прописаны мидвары группы 'web' ко всем правилам маршрутизации в файле web.php. 

		В этом курсе работы с API не подразумеваетс и можно было бы удалить мидлвары и функции в файле RouteServiceProvider.php, но не будем.

	1. Цикл HTTP запросов в Laravel
		а) Запросы прописываются в файле laravel\routes\web.php => 
		б) Перенаправляется в laravel\public\index.php => 
		в) Затем перенаправляются в мидлвары, хрянящиеся в файле laravel\app\Http\Kernel.php => 
		г) Когда произошло бращенеи к нужным мидлварам, запрос направляется в файл laravel\app\Providers\RouteServiceProvider.php => 
		д) В конечном счете  запрос возвратщается обратно в файл laravel\routes\web.php, где настраивается принятие запроса, обращение к котроллерам и вывод view-шаблонов.

		Консольная команда, отображающая все правила маршрутизации в приложении:
		php artisan route:list

	2. Создание своего Middleware. 
		Мидлвар создается через artisan команду: 
			php artisan make:middleware - создание мидлвара
			php artisan make:middleware GoogleRecaptcha - создание мидлвара с валидацией гуглрекапчи
		Новый мидлвар находится в папке laravel\app\Http\Middleware\GoogleRecaptcha.php

		В новосозданном мидлваре будет проверятся наличие примерного/учебного параметра "r" в запросе, отсутствие которого выводит ошибку 403:
			if (!$request->has("r")) {
				abort(403);
			}

		В файле "app\Http\Kernel.php" нужно прописать псевдоним для нового мидлвара: "'r' => GoogleRecaptcha::class,".
		В случаи отсутствия этого параметры при подключенном мидлваре будет вывордится ошибка 403.
		Если же ссылка будет иметь вид "localhost.com/?r=1" с подключенным мидлваром, то ошибка 403 выводиться не будет.

	3. Подключение мидлвара. 
	Подключение мидлвара происхочет чреез метод "middleware()"
		Пример: 
			Route::get('/', function () {
				return view('welcome');
			})->middleware("r"); - подключенный мидлвар к отправляемому запросу
	Можно подключать несколько мидлваров через массив: ->middleware(["r"]);

	4. Работа с маршрутизацией в фале web.php. Группы маршрутизации по префиксу и роутам.
		Создадим контроллер: php artisan make:controller IndexController
		Пропишем в нем только возврат главного шаблона сайта, а роут будет ссылаться на этот контроллер. 
			Пример:
				Route::get('/', [App\Http\Controllers\IndexController::class, 'index'])->name('home');
			
			Желательно каждому правилу маршрутизации задавать имя как выше в примере (->name('home');), так как во время ветски это упростит прописание ссылок в шмблонах. 
			Например вместо прописания полного правила маршрутизации достаточно будет прописать "\route('home);" 'это будет коротким аналогом вышенаписанного правила маршрутизации.
			Помимо минимализации кода это позволяет при смене ссылки в маршрутизации менять ее только в ней, а не во всех шаблонахв, в которых эта ссылка быда указана - так как в шаблонах указывается только всевдоним на нужное правило (route).
		
		Кроме того роуты-правила маршрутизации можно объединять в группы. 
			Пример:
				//группа маршрутизации, в которой применяется мидлвар "r"
				Route::middleware("r")->group(function(){
				//Правила маршрутизации, к которой применяются правила мидлвара "r"
					Route::get('/', [App\Http\Controllers\IndexController::class, 'index'])->name('home');
					Route::post('/contact_form', [App\Http\Controllers\ContactController::class, 'index'])->name('contact_form');
				});

		Еще есть возможность объединять правила маршрутизации в группы по префиксу. Чтобы не повторяеть его во всех URI роутов. Вместо news/{{id}} указывается {{id}}.
			Пример:	
				//группа роутов в каждом из которых имеется префикс "news"
				Route::prefix("news")->group(function(){
					//Правила маршрутизации, к которой применяются правила мидлвара "r"
						Route::get('/', [App\Http\Controllers\Newsontroller::class, 'index'])->name('news');
						Route::post('/{id}', [App\Http\Controllers\NewsController::class, 'index'])->name('news_id');
				});
		
		так же можно првефиксы и мидлвары засовывать в одну группу. 
			Пример: 
				Route::middleware("r")->prefix("news")->group(function(){}
		*/

		//!Урок 3: Контроллеры
		/*
			Команда создания контрллера:
				php artisan make:controller NameController --invokable
				--invokable - необязательынй параметр. Он создает в контроллере метод __invoke().
				Он нужен, когда маршрут не указывает функцию, обрабатывающую запрос. 
				
				Пример записи маршрута для вызова метода "__invoke" в контроллере:
					Route::get('/request', App\Http\Controllers\FirstController::class); 
		*/

	echo '<hr><hr><br><h3>Laravel - #5.1-2 - Шаблоны, Компоновщики шаблонов (День 5)</h3><hr><hr>' . "<br>";
		//!Урок 1: Шаблоны
		/*
			Шаблоны создаются в папке: "resources\views"
			Пример переда данных в шаблон из контроллера:
			
				public function testView(Request $request)
				{
				1-й способ
					return view('example')
						->with('a', 'Shalom')
						->with('b', 'Hello');
				}   
				2-й способ
				return View::make('example', ['a' => 'Shalom', 'b' => 'Hello']);
				3-й способ
				return view('example', ['a' => 'Shalom', 'b' => 'Hello']);
				где, a/b - ключ, Shalom/Hello - значения, example - название шаблона, View - фассад, make - меотд фассада

				СОЗДАНИЕ ГЛОБАЛЬНЙО ПЕРЕМЕННЙО
					Если данные нужны для вывода на множестве страниц - для этого создается глобальная переменная. 
					Она создается в файле "app\Providers\AppServiceProvider.php", методе "boot".
					Пример: View::share('global_var', 'Значение глобальной переменной "global_var"');
					Вызов глобальной переменной: <p>Global: <?=$global_var?></p>
		*/
		//!Урок 2: Компоновщики шаблонов
		/*
			Компоновщики шаблонов - инструмент, делающий данные доступными только для определенных шаблонов. 
			Компоновщие передает данные в шаблон, когда он (шаблон) открывается в проекте. 
			Комноновшик объявлается в файле "app\Providers\AppServiceProvider.php" через фассад View::composer();
			Пример:
				Объявление компоновщика:
					View::composer('example', function($view){
							$view->with('composer_data', 'pass');
					});
					где,
						$view - объект с параметрами, передаваемыми в шаблон "example"
						example	- отслеживаемый шаблон
							Можно перечислить множество шаблонов для компановщика, но тогда они должны быть пересичленны в массиве
						composer_data	- передаваемый параметр
						pass	- значение параметра
				Вызов компоновщека в шаблоне:
					@php
						if (isset($composer_data)) echo '<p>Composer Data:'. $composer_data.'</p>';
					@endphp
					или
					@if (isset($composer_data))
						{{'Composer Data: '.$composer_data}}
					@endif


			ТАКОЙ подход наполнения шаблонов нарушает 1-й принцип SOLID, поэтому по-хорошему нужно создавать отдельный провайдер с компановщиками.
			Либо создать отдельный класс компановщик, на который будут ссылаться провайдер. Это лучше еще и потому, что класс при необходимости может обратиться к БД.
			
			ХРАНЕНИЕ КОМПОНОВЩИКА
				Папка с компоновщиком - создается сомостоятельно (папки не создаются автоматически через artisan): 
					Указананя в этом классе информация будут передаваться в шаблон, а провайдер будет только к нему (классу) обращаться для передачи в шаблон. 
						app\View\Composers\ExampleComposer.php 
					Это произвольная ссылка, и класс с компановщиком можно создать, где угодно. 
				
				ФУНКЦИОНАЛ КОМПОНОВЩИКА:
					namespace App\View\Composers;
					use Illuminate\View\View;
					class ExampleComposer
					{
						public function compose(View $view){
							$view->with('composer_data', 'push ExampleComposer');
						}
					}   

				Ссылка на класс-компановщик в провайдере:
					View::composer('example', App\View\Composers\ExampleComposer::class); //ссылка на класс-компановщик

				РЕЛАИЗАЦИЯ КОМПОНОВЩИКА В ШАБЛОНЕ:
					@if (isset($composer_data))
						{{'Composer Data: '.$composer_data}}
					@endif
				
			ИТОГО: компановщик стоит использовать, когда нужно передавать дополнительные данные группе шаблонов. 
				Это можно сделать через глобальные переменые, но это бОльшая нагрузка на производительность и больЕЕ ожидание. Так что, когда требуется какая либо информация всего для нескольких шаблонов - профитнее испольозвать компановщик. Глобальные переменные предназначены для более масштабного использования. 
				При создании компановщику нужно: 
					1) Фассад "View::composer" в провайдере с шаблонами получатилями с сылкой на компановщик. 
					2) Сам комановщик с данными, передаваймыми в шаблон.
				
		*/

	echo '<hr><hr><br><h3>Laravel - #6.1 - Шаблоны Blade (День 6)</h3><hr><hr>' . "<br>";
		//!Урок 1: Шаблоны Blade
		/*
			В этом уроке затронем работу с blade шаблонами в laravel. 
			ПЕРЕДАЧА ДАННЫХ В ШАБЛОН:
				Для передачи информации в шаблону задействуется контроллер. Пропишем в нем данные, которые будем передавать в шаблон. 
				Есть два формата передачи данных в шаблон:
				Первый:
					Пропишем данные в контроллере главной страницы и передача дынных в нее через метод "compact".
					Пример:
						public function index_metod (){
							$title = 'Главная страница сайта';
							return view('static/index', compact('title'));
						}
						где, 
						$title	- переменная, с передаваемыми данными 
						compact	- метод передачи данных
						title		- название переменной, которая передается в шаблон 
					Получение данных в шаблоне:
					Пример:
						{{ $title }}
						где, 
						{{ }}	- функциональная часть шаблона в котором омжно было бы записать разные операции. 
						В нем можно прописывать разные операции, условия - в общем php код. 
						{-- --}	- запись комментария, невидимого на экране
				Второй: 
				Помима метода "compact" есть еще метод "with". 
				Пример: 
					public function about_metod (){
						$title = 'О нас';
						return view('static/about')->with('header', $title);
					}
					header			- (необязательный параметр) имя-псевдоним, которое передается шаблону
					$title			- модержимое имени-псевдонима
					{{ $header }}	- вызов содержимого имени-псевдонима внутри шаблона
				
				ПЕРЕДАЧА ДАННЫХ В ШАБЛОН МАССИВА (множество переменных)
					public function about_metod (){
						$data = [
							'title'	=> 'Страница про нас',
							'params'	=> ['BMW', 'Audio', 'Volvo']
						];
						return view('static/about')->with($data); //можно было оформить так: with('header', $data);
					}
					Метод  with принимает только значнеие без псевдоимен ($data). 

					В шаблоне достаочно указать только ключ массива без указания самого массива. 
					Пример: 
						<!--	При псевдоимени достаточно было бы указать $header При массиве же достаточно указать ключ передаваемых данных-->
						{{ $title }} 
					При необходимости вывода всего массива в шаблоне - можно использовать стандартные PHP скобки, но это не лучшая практика. 
					В блейд шаблонах для этого уже заготовлены специальные втсавки без необходимости использования стандартных скобок. 
					Пример: @if, @foreach. 
					@if(count($params) > 0)
						<p>У нас больше чем 0 эллементов:</p>
						<ul>
							@foreach($params as $el)
								<li>{{ $el }}</li>
							@endforeach
						</ul>
						@else
							<p>Передаваемый массив пуст</p>
					@endif
					где, 
					@if		- объявление условия
					@endif	- объявление конца условия
					@foreach	- объявление цикла
					@foreach	- объявление конца цикла
					@include('child', ['data' => ['a' => $a, 'b' => $b]])		- подключение шаблона
					@includeWhen($boolean, 'view.name', ['some' => 'data'])	- подключение шаблона и передача в него данных при выполнении условия
					@includeUnless($boolean, 'view.name', ['some' => 'data'])- подключение шаблона и передача в него данных при не выполнении условия
					Для вывода на экран оператор "echo" не требуется. 	
					
					Пример перевода массива или объекта в JSON-строку
					<script>
						let x = {{ Js::from([1, 2, 3]) }};
					</script>

					TODO ВАЖНО! Такая конструкция написания кода используется для повышения безопстности {{}}, так как она не пропускает теги и скрипты. 
		*/

	echo '<hr><hr><br><h3>Laravel - #7.1-3 - Наследование шаблонов, Создание собственных директив, Компоненты (День 7)</h3><hr><hr>' . "<br>";
		//!Урок 1: Наследование шаблонов
		/*
			На сайте может быть множество одинаковых шаблонов с минимальными отличиями. 
			Чтобы избавиться от постоянного дублирования этих частей в Laravel имеется наследование шаблонов.  
			
			СОЗДАНИЕ СЕКЦИЙ В ШАБЛОНЕ И ИХ ПОДКЛЮЧЕНИЕ
				Для создадим шаблон главной страницы, в которой в зависимости от страницы будет передаваться код. 
				Путь: "resources\views\layout\main.blade.php" создания шаблона главной страницы. 
				Папка "layout" будет содержать весь повторяющийся код. 
				Шаблоны (файлы с расширением blade.php) laravel имеют множество различных директив/функций:
				TODO ВАЖНО! Названия секция не должны повторяться внутри шаблона. 
					Пример: @yield('content') - функция объявления секции в шаблоне. 
					где, 
					@yield		- функция объявления метки-секции для шаблонов наследников
					('content')	- название секции в шаблоне (без спец.символов)
				В шаблоне, который принимает повторяющийся код прописывается функция:
				Пример: @extends('layout\main'), 
					где, 
					@extends				- функция наследования кода от родителя - шаблона
					('layout\main')	- адрес шаблона из которого наследуется код
				После в шаблоне наследнике следует код, который нужно наследовать из секции шаблона-родителя. 
				Пример: 
				@section('content')
					HTML код
				@endsection
				где, 
				@section		- начинающийся тег с содержимым секции
				('content')	- название шаблона, в котоырй передается сдержимое
				@endsection - закрывающийся тег с содержимым секции
				

				Конструкция section отвечает за возможность показывать секцию на главной странице и вносить в нее свои данные дочерним шаблонам.
				section - это только метка, сделанная для наследников, которая может обтображать контент в родтеле, а может и не отображать. 
				Примеры:
					1) Секция отображается и на главной странице и в дочерхних за счет окончания show
					@section('left')
						<div>Основное меню</div> 
					@show
					2) Секция отображается только в наследниках
					@section('left')
						@parent
						<div>Дочерний блок</div> 
					@endsection
					где,
						@parent - метка в секции наследника, которая позволяет дополнять контент родительсокй секции не заменяя его. 

		*/
		//?Задание №7.2 не пройдено:
		//!Урок 2: Создание собственных директив
		/*
			В laravel имеется множество директив в шаблонах blade (например @if), но можно создавать и свои. 
				Новые директивы регистрируются в файле "app\Providers\AppServiceProvider.php" в метода "boot()". 
				Для объавления своей директивы понадобится подключить фассад 'Blade::" - "use Illuminate\Support\Facades\Blade;";
			
			ОБЪЯВЛЕНИЕ ДИРЕКТИВЫ
				public function boot()
				{
					Blade::directive('nameNewDirective', function (str $param) {
						return "<?php echo 'Прописанный текст: <b>$param</b>'; ?>";
					});
				}
				где,
					Blade	- фассад работы с директивами
					directive	- метод объявления новой директивы
					nameNewDirective	- название новой директивы
					function($arg){...}	- collback, срабатывающий при вызове новой директивы
					
				TODO ВАЖНО! Директива по-сути вызывает обычный PHP/HTML код, который можо будет не прописывать в шаблоне
			ВЫЗОВ ДИРЕКТИВЫ:
				@directiveTest(текст);
		*/
		//!Урок 3: Компоненты
		/*
			Кмпоненты позволяют уменьшить дублирование кода - они альтернатива наследования шаблонов. 
			А так же компоненты инкапсулитьвать часть кода инкапсулитьвать для дальнейшего многократного использования. 
				Создано новое текстовое удачное поле в форме, которое хотелось бы использовать во всех формах.
				Но тогда при изменении CSS в поле - придется прбегать все формы и менять стили. Поэтому лучше такие вставки как поле в форме делать в виде компанентов. 
			
			КОМАНДА СОЗДАНИЯ КОМПОНЕНТА:
				php artisan make:component MyInput
			TODO ЗАМЕТКА: не обязательно создавать класс для компанента - коспанент можно создавать вручную, но тогда смысла от него будет не так много. 
			При создании компанента создается и папка хранения компанентов
			МЕСТО ХРАНЕНИЯ КОМПОНЕНТОВ:
				Класс компанента: 
					app\View\Components\MyInput.php
				Компаненты можно использовать и без класса, но более сложные компаненты удобнее использовать в связке с классом. 

				Шаблон компанента:
					resources\views\components\my-input.blade.php

			В шаблоне пишется код, который нужно дублировать множество раз. Например поле input: 
				<input type="text" class="input-text" placeholder="Вызываемое поле из компанента" style="margin-top: 15px;">
			Этот компанент вызывается из blade-шаблона, к которому его нужно прикрепить. 
			Для этого создадим роут с вызовом шаблона, который будет вызывать компонент. 

			ВЫЗОВ КОМПАНЕНТА:
				<p><b>Шаблон с вызовом компанента:</b></p>
				<form action="">
					<input type="text" name="" id="" placeholder="Поле №1" style="margin-top: 10px;"><br>
					<input type="text" name="" id="" placeholder="Поле №2" style="margin-top: 10px;"><br>
					{{-- Вызываемый компонент --}}
					<x-my-input/>
				</form>
				где,
					<x-		- объявление вызова компанента
					my-input	- назавание компанента
					/>			- закрытие компанента
			
			ПЕРЕДАЧА ПАРАМЕРОВ В КОМПАНЕНТ:
				Вызвая компонент  через контроллер-компанент - есть возможность паралельно передавать в него данные/поля, которые будут меняться в зависимости от вызывающего шаблона. 
				Например "тип поля" => private $inputText; И "значение" => private $value;
				В контроллере за составление компанента и передачу данных в него отвечает метод "render";
				Посути вызов компанента это обращение к контроллеру за вызовом компанента. 

				TODO ВАЖНО! Особенностью компанента является то, что при составлении компанента (перед выводом он составляется - рендерится), через метод контроллера "render" - передавать данные в компанент как при вызове обычного шаблона не нужно. Компанента автоматически получает доступ к полям своего контроллер, если его поля в публичном доступе = public.

				Получение параметров в компаненте:
					<input type="{{$inputType}}" class="input-text"  style="margin-top: 15px;" placeholder="Вызываемое поле из компанента" value="{{$valueTest}}">
					где,
						$inputType - новое название атребута для поля
						$valueTest - новое название атребута для поля

			ВЫЗОВ КОМПАНЕНТА С ВОЗМОЖНОСТЬЮ УКАЗАНИЯ ПАРАМЕТРОВ:
				<x-my-input input-type='text' value-test='Переданное значение' />
				где,
					input-type				=> замененное название атрибута (в формат "input-type" могут переводиться поля типа $inputType)
					text						=> введенное значение атребута (при отсутствии - принимает значение переданное при рендеринге в  компанент). 
					value-test				=> замененное название атрибута 
					Переданное значение	=> введенное значение атребута (при отсутствии - принимает значение переданное компанентом). 

				TODO ЗАМЕТКА: в проекте компаненты можгут храниться десятками. Поэтому рекомендуется производить рзабивку компанентов на дериктории. 
					Например: компаненты относящиеся к форме хранятся в папке "resources\views\components\forms\my-input.blade.php". 

			ПРИМЕР ВЫЗОВА КОМПАНЕНТА ИЗ ДИРЕКТОРИИ:
				<x-forms.my-input input-type='text' value-test='Переданное значение' />
			
			ДОБАВЛЕНИЕ ПАРАМЕТРОВ КОМПАНЕНТУ ИЗ ШАБЛОНА
				Если указать в шаблоне дополнительыне атрибуты для компанента - они не отобразятся, если эти атрибуты не указаны в компаненте. 
				Чтобы значение атребутов в компаненте внетри шаблона воспринимались и показавались на экране - нужно в компаненте прописать атребут (например placeholder).
				Т.е. атребуты в компаненте при вызове не получится прописать, если предварительно они не были прописаны в компаненте при объявлении. 
				Если значения атребутов вжескую прописаны при объявлении компанента - заменить их значение при вызове компанента в шаблоне тоже не получится. 
				
				В шаблоне можно прописывать значение атребутов если атребуты были предварительно прописаны в файле компанента и имеет значение примерно:
				placeholder="{{ $attributes['placeholder'] }}"

				Пример:
					<input type="{{$inputType}}" class="input-text"  style="margin-top: 15px;" placeholder="{{ $attributes['placeholder'] }}" value="{{$valueTest}}">
					где, 
						placeholder - название атребута в шаблоне
						$atributes['placeholder'] - масив с метками, в которые вносятся данные, которые могут перекрыть значения самого компанента
						'placeholder' - метка, за внесения данных в копаненте
					
					TODO ВАЖНО! Если не прописать эту запись в компаненте ({{$attributes['placeholder']}}), то записи в заблоне, вызывающем компанент - не будут заменять значения по-умолчанию компанента. 
						Т.е. атребуты в слоте и в компаненте при вызове не получится прописать, если предварительно они не были прописаны в компаненте при объявлении. 
						Если значения атребутов вжескую прописаны при объявлении компанента - заменить их значение при вызове тоже не получится. 

			Вызов компанента можно производить и без привязанного к нему класса при создании компанента. 
			Пример вызова компанента без контроллера:
				Объявление компанента:
					<p style="color:brown;">{{$attributes['message']}}</p>
						или
					<input type="text" name="nama" placeholder="Имя" value="{{$attributes['value-input']}}"></input><br>
						или
					<input class="input-type" type="{{$inputType}}" value="{{$value}}" placeholder="{{$attributes['placeholder']}}">
				
				Вызов компанента:
					<x-error-simple message="сообщение об ошибке"/>
						или
					<x-fitback-form value-input="Имя в поле"/>
						или
					<x-my-input input-type="text" value="Содержимое поля"/><br>
					<x-my-input input-type="text" value="{{$a}}"/><br>
		*/

	echo '<hr><hr><br><h3>Laravel - #8.1-4 - Слоты, Макеты, Объект Request, Объект Response (День 8)</h3><hr><hr>' . "<br>";
		//!Урок 1: Слоты
		/*
		СЛОТ - это механизм, позволяющий внедрять в компанент дополнительный текст или HTML код. В компаненте может находится множество слотов. 
		На основе слотов и компанентов создаются макеты сайтов. Но об этом в следующей теме.  
			Пример:
				Объявление компанента с слотом:
					<div>
						<p style="color: #c00;">{{$slot}}</p>
					</div> 
				Вывод компанента с слотом:
					<x-error-message>
						<i>Выыод ошибки</i>
					</x-error-message>
					где, 
						<i>Выыод ошибки</i> == слот

				TODO ВАЖНО! Слотом в компаненте считается никак не помеченная информация при выводе компанента в шаблоне. 
					Второй и далее слот должет иметь обозначение/название. 
					
				TODO ВАЖНО! Рекомендуется объявлять слот через переменную $slot, только если в макете имеется только один слот. 
					При множестве слотом лучше задавать всем слотам имя (переменную).	
		
		ОБЪЯВЛЕНИЕ СЛОТОВ
		В компаненте может быть множество слотов. 
			Первый слот после объявлении не требует обозначения в шаблоне при вызове. Второй и далее - требует.
			TODO ВАЖНО! Првый слот должен быть прописан в виде переменной $slot в файле компанента. Второй и далее слоты прописываются пролизвольной переменной. 
			Пример объявления 1-го слота в компаненте:
				<p style="color: #c00;">{{$slot}}</p>
				где,
					$slot - переменная, вмещающая содержимое компанента в шаблоне
				
			Пример объявления 2-го слота в компаненте (суммарно 2):
				<h3 class="{{ $header->attributes['class'] }}">{{ $header }}</h3>
				<div>
					<p style="color: #c00;">{{ $slot }}</p>
				</div>
				где,
					$header		- метка + название для второго слота
					$header->	- пометка, что атребут относится к слоту "header"
					['class']	- метка для атребута класс
					attributes	- массив, со списком атребутов слота
				TODO ВАЖНО! Новые атребуты в слоте и компаненте при вызове в шаблона не получится прописать, если предварительно атребуты не были прописаны в файле компанента. 

		ВЫЗОВ КОМПАНЕНТОВ В ШАБЛОНЕ: 
			Вызов второго и далее слота происходит через пропись парного тега "<x-slot></x-slot>"
			<x-error-message>
				<x-slot class="my-class" name="header">
					<p>Хедер</p>
				</x-slot>
				<i>Текст компанента со слотом</i>
			</x-error-message>
			где,
				<x-error-message></x-error-message>	 - вызов компаненте со слотами
				error-message - название вызванного компанента
				<i>Текст компанента со слотом</i>	- содержимое первого слота (так как не имеет пометки с именем слота, то считается по=умолчанию 1-м слотом)
				<x-slot ... ></x-slot> 					- вызов второго слота 
				header										- название второго слота
			TODO ВАЖНО! Второй и далее слот при вызове обязательно должен иметь атребут "name" c названием слота, который помечен переменной в компаненте. 
			TODO ВАЖНО! $slot - глобальная переменная компанента, не требующая обозначения в шаблоне.
		*/
		//!Урок 2: Макеты
		/*
		Макет - это сборник слотов. 
			КОМАНДА СОЗДАНИЯ МАКЕТА:
				php artisan make:component MainLayout

			МЕСТО НАХОЖДЕНИЯ МАКЕТА-КОМПАНЕНТА:
				app\View\Components\MainLayout.php
			Т.е. там же, где и контроллер компанента.

			МЕСТО НАХОЖДЕНИЯ ШАБЛОНА МАКЕТА_КОМПАНЕНТА:
				resources\views\components\main-layout.blade.php
			Т.е. там же, где и сами компаненты.

			Но лучше не смешивать макеты сайта и компоненты, котоыре будут использоваться на сайте в одном месте.
			Шаблоны макета лучше перенести в отдельную созданную вручную папку: 
				"resources\views\layouts\main-layout.blade.php";
			Но тогда в методе контроллера макета нужно поменять путь вызова шаблона:
				"layouts.main-layout"
			Теперь "main-layout" можно подключать через тег. 
			Ранее мы уже создали макет сайта, используя наследование шаблонов через (@yield) и (@section).
			Так как макеты это один из аналогов построения структуры сайта, то создадим похожий обрацез на тот, что ранее создавался через директивы наследование шаблонов 
			(@yield) и (@section).

				МАКЕТ С ДИРЕКТИВАМИ:
					<!DOCTYPE html>
					<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
					<head>
						<title>@yield('title', 'Заголовок страницы')</title>
					</head>
					<body>
						<div>Шапка сайта</div>
						<div>
							@section('left')
								<div>Основное меню</div> 
							@show
						</div>
						<div>@yield('content')</div>
						<div>Подвал</div>
					</body>
					</html>

				МАКЕТ С КОМПАНЕНТАМИ/СЛОТАМИ:   
					<!DOCTYPE html>
					<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
					<head>
						<title>{{$title ?? 'Заголовок страницы'}}</title>
					</head>
					<body>
						<div>Шапка сайта</div>
						<div>
							<div>Основное меню</div> 
							{{$left}}
						</div>
						<div>
							{{$content}}
						</div>
						<div>Подвал</div>
					</body>
					</html>

					ДОЧЕРНЯЯ СТРАНИЦЫ МАКЕТА С НАСЛЕДОВАНИЕМ:
						@extends('extendsview')
						@section('title')
							Главная страницы
						@endsection
						@section('left')
						@parent
							<div><b>Различные банеры - дочерняя секция "extendsview => index"</b></div>
						@endsection
						@section('content')
							<p>Основной конттент страницы</p>
						@endsection

					ДОЧЕРНЯЯ СТРАНИЦЫ МАКЕТА СО СЛОТАМИ:
						<x-main-layout>
							<x-slot name="title">Главная страницы</x-slot>
							<x-slot name="left">
								<div><b>Различные банеры - дочерний компанент "indexlayout => main-layout"</b></div>
							</x-slot>
							<x-slot name="content">
								<p>Основной конттент страницы</p>
							</x-slot>
						</x-main-layout>


			Если коротко вся тема компанентов/слотов/макетов - это аналог сборки страниц через наследование шаблонов (@yield) и селектов (select).
			Выбор того или иного метода построения макета - это дело вкуса. 
		*/
		//!Урок 3: Объект Request
		/*
			Request (запрос) - это объект для работы с запросом.
			Он позволяет проверять параметры на наличие и содержание, выводить заголовок, проверять IP с которого был отправлен запос и т.д.
			Чаще всего request используется при обработки форм. 
			С его помощью передаются данные в БД, но в этом уроке для наглядности будет выводить даныне запроса в контроллере. 

			МЕТОДЫ ОБЪЕКТА REQUEST:
			return $request-> ...
				1) header(); Метод выводит строку в виде заголовка запроса. 
					Аргуметом выступает свойство заголовка запроса. Именно заголовок запроса, а не текстовый заголовок.
					Пример:
						$request->header('Host'); ==  127.0.0.1:8000
				2) method(); Метод выводит тип HTTP запрос, которым были отправлен данный зайпрос. Аргумент у метода отсутствует.
						Пример:
							$request->method(); ==  GET
				3) isMethod(); Метод выводит результат проверки (1 или '') на наличие HTTP метода, которым отправлялся запрос. 
					Аргуметом выступает название проверяемого HTTP метода.
						Пример:
							$request->method('POST'); ==  false
				4) ip(); Метод вывода IP, с которого был отправлен запрос. Аргумент у метода отсутствует.
						Пример:
							$request->ip(); ==  127.0.0.1
				5) path(); Метод выводит информацию о пути запроса. Аргумент у метода отсутствует.
						Пример:
							$request->path(); ==  request
				6) url(); Метод вывода URL кроме параметров запроса. Аргумент у метода отсутствует.
						Пример:
							$request->url(); ==  http://127.0.0.1:8000/request
				7)  fullUrl(); Метод вывода URL вместье с параметрами запроса. Аргумент у метода отсутствует.
						Пример:
							$request->url(); ==  http://127.0.0.1:8000/request?a=12&b=typ
				8)  fullUrlWithQuery(); Метод добавления дополнительных параметров в запрос. 
					Аргумент выступает ассоциативный массив, где ключ - параметр запроса, значение ключа - значение параметра.
						Пример:
							$request->fullUrlWithQuery(['par1' => 'var1']); == http://127.0.0.1:8000/request?a=12&b=typ&par1=var1
				9)  input(); Метод вывода всех параметров запроса.
					Аргумент может выступать параметры или массив параметров, котоыре нужно вывести.
						Пример вывода всех паарметров запроса:
							$request->input() == ['a' => '12', 'b' => 'typ']; 
						Пример вывода конкретного паарметроа запроса:
							$request->input('a') == 12 
						Пример присвоения результата метода е переменной:
							$a = $request->input('a', 0);
								где, 'a' - параметр запроса, 0 - значение переменной в случаи отсутствия параметра. 
						TODO ВАЖНО! ->input() выводит все параметры запроса, но в примере имеются только парамтеры передаваемые через HTTP запрос GET.
				10) query(); Метод вывода параметров запроса, отображенных в адресной строке. Т.е. через HTTP метод GET. Метод query() похож на массив $_GET();
					Аргумент у метода отсутствует.
						Пример:
							$request->query() == ['a' => '12', 'b' => 'typ'];
				11) has(); Метод проверки запроса на наличие парамтера.
					Аргументом выступает проверяемый на наличие параметр в запросе.
						Пример:
							$request->has('par') == true
				12) filled(); Метод проверки параметра в запросе пустоту.
					Аргументом выступает проверяемый на наличие параметр в запросе.
						Пример:
							$par = 'var';
							$request->filled($par) == true

				Это не все методы объекта request, но это наиболее часто использующиеся методу. Особенно "ip", "input", "".

		*/
		//!Урок 4: Объект Response
		/*
			Response (ответ)	- объект возврата ответа. 
				Как в request так и responce хранятся тело запроса/ответа и заголовки. 
					Ответ и запрос состоят из заголовка и тела запроса.
					Заголовок несет в себе дополнительную информацию например в виде статуса и типа ответа, дополнительные команджы например в виде редиректа.
					Заголовок нужен браузеру - это "служебная информация".
					Тело запроса это результат обработанного запроса - обычно в тем хранятся запрашиваемые данные. 
				Статусов запросов бывает множество, но дастаточно понимать в какой группе нахдится запрос: 100, 200, ... 500.

			Примеры вызова Rsaponse:
				1) response(); Метод вызова ответа. Первым агрументом може выступать тело запроса, а вторым статус ответа. 
					Пример:
						response('Тело запроса', 200); == "Сожержимое тела запроса"
						response('Сожержимое тела запроса', 200)->header('Content-type', 'text/plain') == "Сожержимое тела запроса"
						где, 	Тело запроса/Сожержимое тела запроса - это содержимое тела запроса, 
								200 - статус ответа
								->header	- метод присваения новых параметров к запросу
								Content-type	- параметр текста в заголовке
								text/plain		- тип текста, игнорирующий теги

					Так же к запросу можно приписывать метод добавления заголовка. 
					Пример:
						response('Тело запроса', 200)->header('Content-type', 'text/plain');
						где, Content-type - параметр заголовка, text/plain - значение параметра (это параметр с типом текста - т.е. не HTML, т.е. теги не воспринимаются). 
				2) response()-json(); Метод возврата ответа в виде JSON-объекта. 
					Аргументом выступает ассоциативный/многомерный массив. 
					Пример:
						Response::json(['par1' => 'var1', 'par2' => ['var2.1', 'var2.2', 'var2.3'], 'par3' => true]) == {"par1":"var1","par2":["var2.1","var2.2","var2.3"],"par3":true}
					TODO ЗАМЕТКА: можно обращаться к объекту response и через фассад "Response". 
				3) response()->download(); Метод запуска скачивания файла у отправителя запроса. Буть то PDF, архив или иной файл. 
				Аргументом выступает путь к скачиваемому файлу. 
					Пример:
						response()->download('H:\SERVAK\OPEN_SERVER_pgu\OSPanel\domains\Laravel-Rusakov\README.md');
				4) response()->file(); Метод показа содержимого файла без скачивания у отправителя запроса. 
				Аргументом выступает путь к отображаемому файлу. 
					Пример:
						response()->file('H:\SERVAK\OPEN_SERVER_pgu\OSPanel\domains\Laravel-Rusakov\README.md');
		*/

	echo '<hr><hr><br><h3>Laravel - #9.1-3 - Работа с URL, Сессии, Обработка исключений (День 9)</h3><hr><hr>' . "<br>";
		//!Урок 1: Работа с URL
		/*
			В уроке разберем работу с URL. 
			Для работы с URL понадобится функция "url();"
			Так же как и у Request - у url(); тоже есть свой фассад URL::
			Через функцию "url()->" можно вызывать другие функции по работе с URL.
				1) current(); Функция возвратщает текущий URL. 
					Пример:
						url()->current(); == http://127.0.0.1:8000/testurl
				2) full(); Аналог current();
					Пример:
						url()->full(); == http://127.0.0.1:8000/testurl
				3) previous(); Выводит предыдущий открытый URL
					Пример:
						url()->previous(); == http://127.0.0.1:8000/testurl - предпоследняя открытая страница
				4) route(); Вызывает URL, прописанный в роутах с псевдонимом. 
					Аргументом является псевданим ссылки. Например в файле web.php => Route::get('/testurl', ..., '...'])->name('tUrl');
					Пример:
						route('tUrl'); == http://127.0.0.1:8000/testurl
							Если нужно было бы передать в URL параметр.
						route('tUrl', ['url' => 15]); == http://127.0.0.1:8000/testurl/id=15
						где, tUrl - псевданим ссылки
				5) signedRoute(); Метод передачи данных по секретной ссылке. Обычно требуется для передачи данных для подтверждения например почты. 
					URL::signedRoute ссыллается на ссылку/псевданим "activate", которая запускает метод "viewActivate" для проверки подписи.
					Аргументом выстыпает псевданим ссылки и массив с передаваемыми параметрами по ссылке. 
					Пример:
						URL::signedRoute('activate', ['id' => 1]) == http://127.0.0.1:8000/activate?id=1&signature=c29522c6d3ecd3c2e635f4f54900550fa1a5350a8db7ab5aada258ec61c1d2cd
						где, activate - псевданим ссылки в файле web.php;  ['id' => 1] - передаваемые параметры
						Но для надежности нужно прописывать проверку подписи URLa, на то что он подписан нами. 					
						Обычно это проверка пишется в методе на котоырй ссылакется подписываемая ссылка-псевданим. 
					Пример проверки:
						public function viewActivate(Request $request){
							if ($request->hasValidSignature()) {
								return 'Ссылка успешно подписана: '.$request->id;
							}
							abort(401);
						}
						где, 
							viewActivate - метод ссылки - псевданима "activate". 
							$request->hasValidSignature() - проверка ссылки на подленность подписи
							$request->id - вывод переданного параметра в сслыку

						TODO ЗАМЕТКА: для проверки подписей в Laravel есть специальные посредники, которые уопрощают проверку подписей. 
						Пример проверки подписи через мидлвар:
							Route::get('/activate', [App\Http\Controllers\FirstController::class, 'viewActivate'])->middleware('signed')->name('activate');
				6) temporarySignedRoute(); Аналог "signedRoute", но с установкой времени работы подписи. 
					Аргументом является псевдоним ссылки, время работы ссылки, передаваемые параметры по ссылке.
					Пример:
						URL::temporarySignedRoute('activate', now()->addMinutes(5), ['id' => 1]) == 
							где, 
								now()->addMinutes(5) - время работы подписи
								temporarySignedRoute - метод установки времени работы подписи/ссылки
								now() - метод работы со времнеем
								->addMinutes(5) - метод установки минут
		*/
		//!Урок 2: Сессии
		/*
			session()->all() - вывод всех переменных сессии в виде массива
			где,
				session() - функция работы ссессиями
				all()	- функция вывода всех переменных в сессии
			2) exists(); - Функция проверки сессии на наличие переменной.
				Аргументом выступает проверяемая на наличие переменная в сессии. 
				Пример:
					session()->exists('var'); == false/true
			3) has(); - Функция проверки сессии на наличие переменной и ее пустоту (проверка на null).
				Аргументом выступает проверяемая на наличие переменная в сессии. 
				Пример:
					session()->has('var'); == false/true
			4) put(); - Функция добавления к сессии нового значения.
				Первым аргументом выступает название новой переменной, вторым его значение. 
				Пример:
					session()->put('var', 10); == var = 10;
					session('var');
			5) push(); - Функция добавления добавляет новое значение к существующему в сессии массиву.
				Первым аргументом выступает название массива/переменной, вторым его дополнительное значение. 
				Пример:
					session()->push('mass', "var4") == 
					session('var'); || session()->get('var');
			6) pull(); - Функция вывода и удаления существующего в сессии элемента.
				Аргументом выступает удаляемый из сессии элемент
				Пример:
					session()->pull('x');
			7) forget(); - Функция удаления существующего в сессии элемента без вывода.
				Аргументом выступает удаляемый из сессии элемент.
				Пример:
					session()->forget('x');
			8) forget(); - Функция удаления существующего в сессии элемента без вывода.
				Аргументом выступает удаляемый из сессии элемент.
				Пример:
					session()->forget('x');
				
			Пример реализации счетчика посещения страницы:
				$counter = session()->get('counter', 0);
				$counter++;
				session()->put('counter', $counter);
				return $counter;
					ИЛИ
				session()->increment('counter');
				return session()->get('counter');
		*/
		//!Урок 3: Обработка исключений
		/*
			В уроке поговорим о создании и обработке исключений. 
			Исключения нужны для предотвращения выполнения команд, когда того не подразумевает логика с последующим логированием этих ситуаций/кейсов.
			Путь до исключений: "app\Exceptions\Handler.php";
				Этот файл отвечает за прием и обработку исключений. 
				На практике им почти не приходится пользоваться, но знать о нем надо.
				В этом классе чаще всего придется работать с полем "protected $dontReport = [];"
				В этом поле прописываются классы, которые не должны обрабатываться в Laravel. 

				Так же интересен метод "register", перехватывающий все исключения:
					public function register(): void
					{
						$this->reportable(function (Throwable $e) {
						});
					}
					где,  $e - место хранения объекта с исклоючением 
						
				Свои ислючения создаются чреез artisan команду:
					php artisan make:exception NameException

				В созданных исключениях обычно нужно помнить о двух публичных методах: 
					1) context - он возвратщает ассоциативный массив с информацией о сработанном исключении, которая отображается в log-файле.
						Пример:
							public function context(){
								return ['exceptionInfo' => 'инфа о исключении'];
							}
					2) render - метод выполняющийся при срабатывании исключения. 
						Пример:
							public function render(){
								return 'My exception fron file "MyException"';
							}
				Для теста созддим контроллер и выбросим в нем исключение:
					use App\Exceptions\MyException;		
					public function testException(Request $request)
					{
						throw new MyException(); == 'My exception fron file "MyException"'
					}
					где,
						throw - объявление исключения
						new MyException() - создание объекта на основе класса с исключением
						My exception fron file MyException - данные/сообщение, выводимое при срабатывании исключения

					Адрес лог-файла: storage\logs\laravel.log
						Вот сообщение об исключении, отправляемое в логи:
							[2023-05-28 18:17:54] local.ERROR:  {"exceptionInfo":"инфа о исключении","exception":"[object] (App\\Exceptions\\MyException(code: 0):  at H:\\SERVAK\\OPEN_SERVER_pgu\\OSPanel\\domains\\Laravel-Rusakov\\app\\Http\\Controllers\\FirstController.php:105)
		*/


	echo '<hr><hr><br><h3>Laravel - #10.1-2 - Пользовательские страницы ошибок, Логирование (День 10)</h3><hr><hr>' . "<br>";
		//!Урок 1: Пользовательские страницы ошибок
		/*
			В Laravel есть свои шаблоны на случаи ошибок или действий пользовтеля. 
			Однако мы можем заменить эти шаблоны по-умолчанию на свои. 
			Для этого нужно получить доступ к шаблонам через команду artisan:
				php artisan vendor:publish --tag=laravel-errors 
				где,	
					vendor:publish - команда публикации
					--tag= - объявление публикуемых "вещей", как сказал лектор
					laravel-errors - шаблон в laravel
					errors - название дериктории в laravel, ответственной за ошибки
				Эта команда переносит нас в деркторию с шаблонами ошибок laravel:
					=> Copying directory [H:\SERVAK\OPEN_SERVER_pgu\OSPanel\domains\Laravel-Rusakov\vendor\laravel\framework\src\Illuminate\Foundation\Exceptions\views] to [H:\SERVAK\OPEN_SERVER_pgu\OSPanel\domains\Laravel-Rusakov\resources\views\errors]  DONE
				Происходит пренос файлов (перенос дерриктории) из первой дерриктории во вторую.  				
				Это дериктория с шаблонами ошибок.
				TODO ВАЖНО! Если файлы будут названы одинаково в обоих деррикториях, то теперь приоритет чтения будут даваться второй дерриктории. 
				Перепишем шаблон 404 (так как только ее будем редактировать) в новой дерриктории, а остальные файлы в ней удоляем, чтобы они брались из первой дерриктории.
					Возмет только код из файла "minimal.blade.php" и перенесем его в оставшийся файл "404.blade.php". Заменим наслудующие вставки yeld().
					И из шаблона welcome добавм пометку о языке: <html lang="{{ str_replace('_', '-', app()->getLocale()) }}">

		*/
		//!Урок 2: Логирование
		/*
			Логирование - нужно для своевременного отслживани ошибок и ведения их учета. 
				Лиги находятся в файле "config\logging.php".
				В файле размещен набор настроек для логирования. 

				НАСТРОЙКИ РАБОТЫ КАНАЛОВ ЛОГИРОВАНИЯ:
				1. Первая настройка "'default' => env('LOG_CHANNEL', 'stack')" - это канал, который будет использоваться по-умолчанию при попытки добавления сообщения в логи.
					где,
						default - настройка указывающая на дефолтный канал записи. 
						env - файл с главными настройками
						LOG_CHANNEL - парамтр в .env с названием дефолтного канала (если он указан)
						stack - название дефотного канала (запускается, если в .env не указан дефотный кана - по-умолчанию совпадают).

				2. Настройка с выводом предупреждением о использовании устаревших функций
					'deprecations' => [
						'channel' => env('LOG_DEPRECATIONS_CHANNEL', 'null'),
						'trace' => false,
					]
					где,
						null - канал, не обрабатывающий сообщение


			КАНАЛЫ ЛОГИРОВАНИЯ И ИХ НАСТРОЙКИ В ФАЙЛЕ ЛОГИРОВАНИЯ:
			Ниже настроек идет объект "channels" со списком каналов логрования:
				Некоторые параметры каналов могут повторяться, поэтому будут указываться только их основные различия.
				1) stack			- это дрейвер с возможностью передачи сообщения нескольким каналам. Посути это конфиг, как я понял. 
					Настройки канала:
						а) driver - определяет возможность отправки сообщения сразу нескольким каналам
						б) channels	- каналы, которым дополнительно могут отправляться сообщения с канала "stack". Значением выступает массив каналов. 
						а)	ignore_exceptions - игнорирование сообщений от исключений. Содержит булево значение. 
				2) single		- драйвер с путем отправки сообщения в логги. Походу это тоже конфиг. 
						а) path	- содержит функции с аргументом в виде путь до файла логирования. Сюда приходит уведомления об ошибках в логги. 
						б) level	- определяет уровень принимаемых для обработки сообщений. 'level' => env('LOG_LEVEL', 'debug'), где debug - уровень сообщения. 
						TODO ЗАМЕТКА: сообщения в логировании делятся на уровни (о них ниже). 
							Самый важный уровень "Emergency", а  самый низкий уровень приоритета => "debug".
				3) daily			- канал создает отдельные временные файлы для хранения логов, исчезающие через определенный срок, чтобы не хламить место одного файла.  
					а) path - путь до файла логов, который будет иметь название логов+дата создания логов. storage_path('logs/laravel.log'). 
					б) days - время жизни (в днях) созданного файла.
				4) slack			- испольуется для работы в команде, когда нужно, чтобы о какой либо ошибки узнали остальные разработчики. 
				Остальные каналы используются редко: papertrail, stderr, syslog, errorlog, null,  emergency. 
				
				Так же можно создавать и свои каналы. 
				Пример:
					'mychannel' => [
						'driver' => 'single',
						'path' => storage_path('logs/mylog.log'),
						'level' => env('LOG_LEVEL', 'debug'),
					]

			СОЗДАНИЕ УВЕДОБЛЕНИЙ ДЛЯ ЛОГ ФАЙЛА
				Для написания сообщений в логи в laravel есть специальный фассад "Log::"
					Этот фассад имеет методы по числу типов уровней сообщения в логги. О них ниже. 
					Пример отправки сообщения в логи:
						Log::debug('debug-level message'); //все, что в методе - сообщение отправляемое в лог
					Пример сообщения, отображенного в логах:
						[2023-05-29 18:59:03] local.DEBUG: debug-level message 
						где,
							local - локальный сервер
								На боевом сервере будет надпись "production" (прописано в .env(APP_ENV=local)
							DEBUG - уровень сообщения
							debug-level message - сообщение
						TODO ЗАМЕТКА: если хочется поменять слово в логах "production/local" на свое, то в канал "stack" прописывается новый параметр "name" со своим придуманным значением. 
							Пример: 
								'name' => 'СкороВПродакшн'. 						
							Хотя это и не обязательно - так просто можно)
					TODO ВАЖНО! Так как по умолчанию установлен канал "stack", в котором установлен канале "single", в котором указан путь 'path' => storage_path('logs/laravel.log'), то сообщение будет направлено именно в логи по адресу 'storage\logs\laravel.log'.

			ТИПЫ СООБЩЕНИЙ В ФАЙЛ ЛОГ ЧЕРЕЗ ФАССАД "LOG"
				На сайте "https://datatracker.ietf.org/doc/html/rfc5424" в пункте 6.2.1. PRI типы сообщения в логах:
				Перечисляются типы сообщений от самого приоритетному к менее приоритетному: 
				1) Emergency (Аварийная ситуация): system is unusable
						Пример передачии сообщения в контроллере:
							Log::emergency('system is unusable');
				2) Alert (Предупреждение): action must be taken immediately
						Пример передачии сообщения в контроллере:
							Log::alert('action must be taken immediately');
				3) Critical (Критические): critical conditions
						Пример передачии сообщения в контроллере:
							Log::critical('critical conditions');
				4) Error (Ошибка): error conditions
						Пример передачии сообщения в контроллере:
							Log::error('error conditions');
				5) Warning (Предупреждение): warning conditions
						Пример передачии сообщения в контроллере:
							Log::warning('warning conditions');
				6) Notice (Примечание): normal but significant condition
						Пример передачии сообщения в контроллере:
							Log::notice('normal but significant condition');
				7) Informational (Информационный): informational messages
						Пример передачии сообщения в контроллере:
							Log::info('informational messages');
				8) Debug (Отладка): debug-level messages
						Пример передачии сообщения в контроллере:
							Log::debug('debug-level message');

			ПЕРЕДАЧА СООБЩЕНИЯ В ЛОГИ ПО КАНАЛУ НЕ ПО-УМОЛЧАНИЮ (stack):
				Например для записи логов по каналу "daily". Для этого используется метод "channel()".
				Аргументом, которого является существующий канал передачи логов.
				Пример записи логов:
					Log::channel('daily')->info('сообщение по каналу "daily"');
				Пример вывода логов:
					[2023-05-29 19:51:51] local.INFO: Сообщение по каналу "daily"  
				TODO ВАЖНО! При передачи сообщения по каналу "daily" генерируется новый файл с логами к которому в суффикс приписывается время создания -  сообщения в нем.
				В следующий день передачи соосбщения через канал "daily" создается новый файл. 
				TODO ЗАМЕТКА: некоторые разработчики говорят, что больше предпочитают использовать канал "daily" для логирования. 
				Пример нового адреса с логами: 
					"storage\logs\laravel-2023-05-29.log"

				Пример передачи сообщения в логи по созданному вручную кналу:
				TODO ЗАМЕТКА: в логи можно передавать не только сообщение, но и данные, помещенные в массив. 
				TODO ЗАМЕТКА: если передачть сообщение с несуществующем файлом-логом, то при передаче сообщения он создатся автоматически.
				Пример:
					Log::channel('mychannel')->info('Сообщение по созданному вручную каналу "mychannel"', ['data' => 'значение массива с передаваемыми данными']);
				Пример вывода логов:	
					[2023-05-29 20:09:29] local.INFO: Сообщение по созданному вручную каналу "mychannel" {"data":"значение массива с передаваемыми данными"} 
			
			
		*/

		echo '<hr><hr><br><h2>Модуль №11.11-14:  Работа с базой данных</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #11.1-2 - Подготовительный этап, Миграции (День 11)</h3><hr><hr>' . "<br>";
		//!Урок 1: Подготовительный этап
		/*
			В этом уроке создадим БД и рассмотрим основные настройки БД в Laravel
			Создадим БД => "laravel_Rusakov"
			Заполнять БД будем через миграции. О них в слуд уроке. 

			Основные настройки БД в Laravel
				Файл с настройками БД "config\database.php"
				Список настроек:
					1) default - отвечает за СУБД, используемую в БД.  
					'default' => env('DB_CONNECTION', 'mysql'),
						где,
							DB_CONNECTION - параметр файла .env 
							mysql - названеи СУБД для управление БД. 
					2) connections - объект с поддерживаемыми СУБД в Laravel
						'sqlite' => [...], 'mysql' => [...], 'pgsql' => [...], 'sqlsrv' => [...],
						2.1) sqlite	- самый приметивный вариант СУБД
							Суть этой СУБД в том, что вся БД хранится в отдельном файле. 
						2.2) mysql	- самый распространенный вариант СУБД
					3) Основные настройки СУБД
						3.1) host - адрес БД 
						3.2) port - порт хоста
						3.3) database - название БД
						3.4) username - логин к БД
						3.5) password - пароль к БД
						3.6) unix_socket, charset - кодировки БД по-умолчанию
						3.7) prefix - парамет, добавляющий ко всем таблицам прификс (это нужно для бзопасности).
					4) 'migrations'  - название таблицы с миграциями
					5) redis - хранилище с данными аля ключ-значение. 

				Большинство перечисленный настроек находятся в файле ".env" - его и нужно заполнять. 
				Из файла "database.php" настройки бурется в случаи отсутствия оных в первом файле.
		*/

		//!Урок 2: Миграции
		/*
			Миграция - это своего рода система контроля версий структуры БД (таблиц).
			Модель создается в терминале.

			TODO ВАЖНО! Создавать миграции нужно в осмысленном порядке. 
			Миграции создаются в последовательном порядке.
			Например таблица Comments связана с таблицей Posts. Если сначала создать миграцию комментариев, а потом миграцию постов, то выведется ошибка. 
			Так как требуется, чтобы комментарии по очередности были после постов.
		
			СОЗДАНИЕ МИГРАЦИИ
				Выполним созданную миграцию, в результате чего в БД будет создана новая таблица. 
				На момент создания таблицы - уже имелось несколько миграций. Они отвечают за создание нскольких таблиц в БД - некоторые из них являются системными.
				Команда выполнения имеющихся миграций:
				Пример: 
				php artisan make:model Article -m
					ИЛИ
				php artisan make:migration create_coments_table
				где, 
					php artisan				- обращение к помошнику
					make:model				- команда создания модели 
					Article					- название модели
					-m							- опция создания миграции при создании таблици 

			НАПОЛНЕНИЕ ТАБЛИЦЫ ПЕРЕД МИГРАЦИЕЙ
			Пример: 
				$table->string("title"); //255
				$table->mediumText("anons");
				$table->longText("text");
				$table->integer('post_id')->unsigned();
				$table->boolean("");
				$table->integer("");
					Где аргументы - это название строки, а методы указывают на тип данных в поле создаваемой таблицы. 
					Дополнительно к создаваемым полям можно приписывать свойства типа:
						->index() - поле индексируемо
						->unique() - недопустимо одинаковое содержание в полях
						->nullable() - допустимо наличие нуля в поле
						->default() - значение по-умолчанию 

				TODO ЗАМЕТКА: Если требуется в создаваемой таблице исключить поля даты создания и редактирования, то в модели таблицы прописывается строка:
				public $timestamps = false; 
				При добавлении данных в таблицу при отсутствии в миграции метода $table->timestamps(); - будет выдаваться ошибка

			ЗАПУСК МИГРАЦИИ
				php artisan migrate
				Эта команда запускает все изменения в папке с миграциями в БД

				TODO ВАЖНО! При выполнении команды миграции может выдаться ошибка. 
				Она связана с тем, что при установки PHP 8 может отсутствовать PDO функционал.
				Комнада проварки PDO функционала на наличие:
				php -i | grep "PDO drivers" 
				Ошибка исправляется вписанием строки либо их разкомментированием в файл pgp.ini: 
				"extension  = pdo_mysql" или "extension=php_pdo".

			СЛУЖЕБНЫЕ МИГРАЦИИ И ТАБЛИЦЫ
				При установки laravel дополнительный устанавливаются миграции и таблици для работы фреймворка. Например для очередей, ошибок выполняния задач.
					"articles" 						- созданная таблица
					"falied_jobs"					- системная таблица. В ней указываются неудачные миграции.
					"migration"						- таблица со списком миграций
					"password_resets"				- таблица авторизации (для восстановления пароля пользователя)
					"password_access_tokens"	- таблица авторизации (для восстановления пароля пользователя)
					"users" 							- таблица авторизации

			ПРОВЕРКА СТАТУСА МИГРАЦИИ
				php artisan migrate:status
				Ввыодит данные из служебной таблицы 'migration'.

			ОТМЕНА МИГРАЦИИ
			Для отмены миграции прописывается команда в терминале:
			Пример:
				php artisan migrate:rollback --step=1
				где, 
					php artisan			- обращение к помошнику
					migrate:rollback	- команда отката миграции
					--step=1				- число шагов отката миграции. 1 - вернуть предудущий вид, 2 - вернуть вид до предыдущего.

				Команда удаления всех шагов миграций:   
					php artisan migrate:reset

			ОБНОВЛЕНИЕ МИГРАЦИИ
				Этот способ предпочтитеьнее в виду меньшего количества операций
					php artisan migrate:refresh == reset + migrate 
					php artisan migrate:fresh == refresh, но производит удаление таблиц без обращения к методу "down". Т.е. напрямую. 
					Команда удаляет изменения и запускает миграции без удаленных изменений. 
					Т.е. refresh не будет работать в случаи удаленный файлов с миграциями, а fresh будет. 
					TODO ВАЖНО! команда "fresh" удаляет все таблицы в базе и даже те, которы были созданы вручную - без миграций. 
					Поэтому в БД рекомендуется хранить таблицы только одного проекта.

			УДАЛЕНИЕ СТРОКИ ЧЕРЕЗ МИГРАЦИЮ
			Для удаления строк в таблице достаточно в файле миграции таблици удалить лишнии строки и запустить миграцию снова. 

			ДОБАВЛЕНИЕ ДАННЫХ В ТАБЛИЦУ
			Ин офрмацию в таблицу можно добавить через интерфейс PHPMyAdmin. 
			А можно через терминал. Команда добавления даных в талицу:
			Для этого нужно задействовать несколько команд. 
				Пример вызова интерфейса для работы с моделью таблицы:
					php artisan tinker 
					где,
					php artisan		- обращение к помошнику
					tinker			- обращение к комнадному интерфейсу для работы с проектом. Например для создания нового объекта на основе модели таблицы. 
											Новый объект - создается как правило для создания новой записи в таблицу в БД. 
				Пример для создания объекта таблицы:
				$article = new App\Models\Article();
					где, 
						$article  						- новый объект 
						new App\Models\Article();	- класс-модель на основе которой создается объект

				
			*/

	echo '<hr><hr><br><h3>Laravel - #12.1-2 - Использование Seeder, Отправка запросов через фасад DB (День 12)</h3><hr><hr>' . "<br>";
		//!Урок 1:  Использование Seeder
		/*
			Миграфии нужны для быстрого составления структуры талицы, но не ее содержания. 
			Таблицу можно наполнять и вручную, однако при удалении таблиц и миграций тогда пропадут и внесенные данные. 
			За наполнение таблицы тестовыми данными отвечают сидеры (Seeder). 
				После восстановления структыры таблицы - она наполняется при запуске сидеров без необходимости ручного наполнения. 
				Адрес сидеров: "database\seeders". 

			СОЗДАНИЯ СИДЕРА
				php artisan make:seeder CommentSeeder
					где, 
						CommentSeeder - название сидера
						Comment - название таблицы/модели
						Seeder - суфикс прилагемый при создании сидера
				TODO ЗАМЕТКА: рекомендуется в имя сидера заключать имя модели таблицы, к которой создается сидер и суффикс, указывающий на создание сидера. 

			ОБЗОР СИДЕРА
				TODO ЗАМЕТКА: Помимо созданного сидера уже имеется сидер "DatabaseSeeder". Именно он будет срабатывать при запуске сидера, ссылаясь на созданный сидер. 
				В каждом сидере имеется только метод "run", срабатывающий при запуске сидера. 
				Пример ссылки на созданный сидер из сидера "DatabaseSeeder":
					$this->call([
							CommentSeeder::class, 
					]);
					где,
						call - меотд ссылающийся на сидеры. Массив с сидерами - аругмент метода
						CommentSeeder::class - вызываемый сидер
					TODO ЗАМЕТКА: созданный сидер находится в одном пространстве имен с сидерем "DatabaseSeeder", поэтому дополнительных подключений не требуется. 
			
			НАПОЛНЕНЕ СИДЕРА
				Вообще для работы сидеров используются "фейкеры" для герерации случайных имен/адресов - данных, но сейчас показывается упрощенный вариант работы. 
				Ниже будет показаны два варианта запроса к БД через сидеры, но только потому, что так можно, а не нужно. Они учебные и не используются на практике.
				Но предпочтительно наполнять сидеры с использованием моделей фейкеров и фабрик. 
				Если коротка на данный момент кажется, что фабрика это посредник между моделью и сидером.

				$names = ['Freed', 'Helga', 'Nicolas', 'Василий', 'Григорий'];
				for ($i=0; $i < 100; $i++) { 
					$post_id = mt_rand(1, 10);
					$name = Arr::random($names); //хелпер, работы с массивом (метод "random" выбирает случайны элемент). 
					$text = Str::random(mt_rand(30, 100)); //хелпер, генерации текста (метод "random" выбирает одно из предложенных значений). 
					$created_at = date('Y-m-d H:i:s');
					$updated_at = $created_at;
					
					1-й способ написания запоса
					DB::insert('INSERT INTO `comments` (`post_id`, `name`, `text`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?, ?)',	[
						$post_id, $name, $text, $created_at, $updated_at
					]);

					2-й способ написания запоса (предпочтительнее)
					DB::table('comment')->insert([
						'post_id' => $post_id, 
						'name' => $name, 
						'text' => $text, 
						'created_at' => $created_at, 
						'updated_at' => $updated_at
					]);
				}
			
			ЗАПУСК СИДЕРА
				php artisan db:seed - запуск сидера
					ЛИБО
				php artisan migrate:refresh/fresh --seed - перезапись миграции и запуск сидера
		*/

		//!Урок 2:  Отправка запросов через фасад DB
		/*
			В этому уроке разберемся как взаимодействовать с данными в БД через Laravel. 
			Для работы с БД в Laravel используется фассад "DB". Хотя на практике им практически не придется пользоваться. 
			Только в случаи супер сложных запросов с JOIN, котрые сложно будет составить через построитель запросов.
				В этом разберем первый способ (с синтаксисим SQL) из предыдущего урока, а второй (через посторитель запросов) в следующем. 
				Для взаимодействия с БД в этот раз создадим контроллер. 
				Очистим таблицу, наполненную в предыдущем уроке через сидер. 

					Примеры использования основных методов фассада DB:
						Пример с DB::selsct():
							DB::select('SELECT * FROM `comments`');
						Пример с DB::update():
							DB::update('UPDATE `comments` SET `post_id` = ? WHERE `post_id` = ?', [4, 10]); //значения массива это соотетственно 1-й и 2-й вопросы
						Пример с DB::insert():
							DB::insert('INSERT INTO `comments` (`post_id`, `name`, `text`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?, ?)',	[
								$post_id, $name, $text, $created_at, $updated_at
							]);
						Пример с DB::delite():
							DB::delete('DELETE FROM `comments` WHERE `name` = :name', ['name' => 'Freed']);
						Пример с DB::transaction():
							DB::transaction(function(){
								DB::insert('INSERT INTO `comments` (`post_id`, `text`) VALUES (?, ?)',	[2, 'Lorem, ipsum dolor.']);
								DB::update('UPDATE `comments` SET `post_id` = ? WHERE `post_id` = ?', [4, 10]);
							});

						TODO ЗАМЕТКА: метод transaction() принимает в качестве аргумента collback-функцию с методами, которые должны быть выполнены обязательно вместе. В случаи ошибки при выполнении одного из методов - результат второго метода отменяется. Закрепляется результат только успешного выполенния всех методов в связке.
							Эта функция может понадобиться, когда нужно чтобы у каждого зарегистрированного пользователя принимался секретный вопрос, без которого регистрация пользователя недопустима. Если не так, то пришлось бы удалять пользователя вручную. 

						ВЫВОД ДАННЫХ
							Перед выводом создадим больше строк в БД (5) через сидер:
								php artisan migrate:fresh --seed

							Набор выводимых данных является масивом. 
							TODO ЗАМЕТКА: переменная с содержимым запроса является массивом, а каждый элемент массива является объектом. 
								Функция для проверки типа аргумента: gettype($dataComment/$var);
							foreach ($dataComment as $var) {
								echo 'Айдишник: '.$var->id.'<br>';
								echo 'Айдишник поста: '.$var->post_id.'<br>';
								echo 'Имя: '.$var->name.'<br>';
								echo 'Текст: '.$var->text.'<br>';
								echo 'Время создания: '.$var->created_at.'<br>';
								echo 'Время обновления: '.$var->updated_at.'<br>';
								echo '-_-_-_-_-_-_-_-_-_-_-_-'.'<br>';
							}
		*/

	echo '<hr><hr><br><h3>Laravel - #13.1-1 - Построение запросов (День 13)</h3><hr><hr>' . "<br>";
		//!Урок 1: Построение запросов
		/*
			В прошлом уроке мы строили запросы через пропись SQL синтаксис. Сегодня разерем построение построители запосов. 
			Запрос через построители подпразумевает функцию "DB::table('tableName');", после которой следует запрос в виде метода, а не SQL кода.
			
			ОСНОВЫНЕ ОПЕРАЦИИ построителя запросов (QueryBuilder):
				1) ->insert();
					Аргументом выступает массив, где ключ == поле таблици, значение ключа = значение поля.
					Пример с ->insert();
						DB::table('comment')->insert([
							'post_id' => '5',
							'name' => 'Леха',
							'text' => 'некоторый текст'
						]);
					где,
						table - функция обращения к таблице
						insert - метод запроса
						post_id/name... - название полей таблицы
						5/Леха... - значения полей таблицы
						TODO: ЗАМЕТКА: в таблицу может понадобиться записать несколько строк. В таком случаи через в методе "insert" заносится многомерный массив из несколько массивом, каждый из который заполнен данными новой строки.
						Пример:
							DB::table('comment')->insert([
								['post_id' => '2', 'name' => 'Леха', 'text' => 'некоторый текст1'],
								['post_id' => '5', 'name' => 'Вася', 'text' => 'некоторый текст2'],
								['post_id' => '6', 'name' => 'Федя', 'text' => 'некоторый текст3']
						]);
				2)	->update();
					Метод "update" работает вкупе с выборкой в отличии от метода "insert()", которому выборка не нужна. 
					Выборка имеет аргумент в виде поля и его значения в таблице. 
					Аргументом выступает массив, где ключ == поле таблици, значение ключа = значение поля.
					Пример с ->update();
						DB::table('comments')->where('post_id', 5)->update([
							'post_id' => '2'
						]);
					где,
						['post_id' => '2'] - аргумент метода обновления
						Смысл записи в замене в таблице полей 'post_id' со значением == 5 на значение 2. 
				3)	->increment();
					Аргументом выступают поле таблицы с типаом данных "число" и целое число, на которое повышается в аргументе. 
					Пример с ->increment();
						DB::table('comments')->where('post_id', 2)->increment('post_id', 10);
					где,
						increment - метод повышения числа
						10	- значение на которое повышается выбранное число. Итого поля 'post_id' == 2 становятся 'post_id' == 12
				4) ->delete();
					Аргумент не обязателен. Удаляет строки, найденные выборкой. 
					Пример с ->
						DB::table('comments')->where('post_id', 12)->delete();
				5) ->select();
					Аргументом выствпает название нужного поля или массив из выводимых полей строки. 
					Пример:
						а) DB::table('comments')->select('id')->where('post_id', 3)->get(); 
						б) DB::table('comments')->select(['post_id', 'name'])->where('post_id', 3)->get(); 
					TODO ЗАМЕТКА: метод select() позволяет выводить конкретные нужные значения строки, а не всю строку сразу.

				ВЫБОРКА ЗАПРОСА
					Методы фассада DB	по извлечению данных
						1) ->get();
							Метод вывода информации из выборки. Может работать без методе "where()", тогда будет выводиться вся таблицы. 
							Пример с ->get();
							а) $comments = DB::table('comments')->get(); //без метода выбоки
							б) $comments = DB::table('comments')->where('post_id', 1)->get(); //с методом выборки
						TODO ЗАМЕТКА: переменная, вмещающая в себя данные полученные через построитель запросов называется "КОЛЛЕКЦИЕЙ", но работают с ней как с массивом. 
						2) ->first();
							Метод выводит одну первую записи из выборки. Может работать без методе "where()", тогда будет выводиться вся таблицы. 
							Пример с ->get();
								а)$comments = DB::table('comments')->where('post_id', 1)->first(); // вывод одной записи, подпадающий в выборку
								б)$comments = DB::table('comments')->first(1); //вывод записи с ID == 1
						TODO ЗАМЕТКА: переменная, вмещающая в себя данные полученные через построитель запросов методом first() уже является объектом, а не "КОЛЛЕКЦИЕЙ".
						3) ->where();
						а/в) Аргементами выствпают название поля, значение поля и знак сравнения (>, <, <= ...). Или оператор "LIKE".
						д) whereBetween() - значения равные от а до б.
						е) whereNotBetween() - значения НЕ равные от а до б.
						ё) whereIn() - значения равные а или б.
						ж) whereNotNull() - поле не ровно нулю
						з) whereNull() - поле ровно нулю
						и) Orwhere() - метод пишушийся в паре с методом where(), с которым связывается оператором "OR" (ИЛИ).
						к) where(function($query){...}->OrWhere() - вывод двойного условия 
						л) 
						м)

						Метод используется в связке с методоми обработки/вывода данных. 
						TODO ЗАМЕТКА: Для добавления второго и более условия выборки - прописывается еще один метод ->where('if_1')->where('if_2'); вслед за первым.
						Пример с ->where();
							а) DB::table('comments')->where('post_id', '>', 1)->first(); вывод значения больше == > 1
							б) DB::table('comments')->where('post_id', 4)->get(); вывод значений == 4
							в) DB::table('comments')->where('post_id', 'LIKE', %нн%)->get(); вывод значений, содержащих в имени "нн"
							г) DB::table('comments')
								->where('post_id', 'LIKE', %нн%)
								->where('post_id', '>', 4)->get(); запись нескольких условий выборки
							TODO ЗАМЕТКА: между двумя условиями метода ->where()->where() подразумевается оператор "AND". 
							д) DB::table('comments')->whereBetween('id', [2, 4])->get(); вывод значений равных от 2 до 4
							е) DB::table('comments')->whereNotBetween('id', [2, 4])->get(); вывод значений НЕ равных от 2 до 4
							ё) DB::table('comments')->whereIn('id', [2, 4])->get(); вывод значений равных 2 ИЛИ 4
							ж) DB::table('comments')->whereNotNull('post_id')->get(); выыод строк, где поле не ровно нулю
							з) DB::table('comments')->whereNotNull('post_id')->get(); выыод строк, где поле ровно нулю 
							и) DB::table('comments')
								->where('post_id', 3)
								->Orwhere('post_id', '=>', 5)->get(); запись нескольких условий выборки
							к)	DB::table('comments')->where(function($query){
									$query->where('post_id', 6)->where('name', 'Helga');
								})->OrWhere('post_id', 3)->get();
								Эта запись эквивалентна этой:  'where(`post_id` = 6 and `name` = 'Helga') OR `post_id` = 3';
							TODO ЗАМЕТКА: для записи более сложных запросов в методе выборки пишется callback-функция с условием выборки. 
							л) 
							м)
						4) ->orderBy()/orderByDesc();
						Аргументмо является поле, по которому проводится сортировка. 
						Пример:
							а) DB::table('comments')->orderBy('name')->get(); //вывод строк по сортировки по полю
							б) DB::table('comments')->orderBy('name')->orderBy('post_id')->get(); //вывод строк по сортировки по двум полям
								Т.е. внутри строк отсортированных по одному полю включается следующая сортировака по второму полю.
							в) DB::table('comments')->orderBy('name', 'desc')->get(); //вывод строк по полю в обратной сортировки
							г) DB::table('comments')->orderByDesc('name')->get(); //вывод строк по полю в обратной сортировки
							TODO ЗАМЕТКА: обратный порядок сортировки в методе orderBy() задает второй аргумент 'desc'.
						5) ->inRandomOrder();
						Метод вводит в случайном порядке строки. 
						Пример:
							DB::table('comments')->inRandomOrder()->get();
						6) ->limit();
						Аргументом выствпает число записей над которыми будет проиведены операции
						Пример:
							$comments = DB::table('comments')->limit(5)->offset(3)->get();
						7) ->offset();
						Аргументом выствпает число записей, которые будут игнорироваться при выводе. 
						Пример:
							$comments = DB::table('comments')->limit(5)->offset(3)->get();
						8) ->count();
						Метод выводит число. 
						TODO ЗАМЕТКА: Метод ->count() извелекает дыннеданные так же как и методы ->get(), ->exists() и ->first(). Поэтому они не ставялся в одном запросе.
							а) DB::table('comments')->count(); //вывод количества записей
							б) DB::table('comments')->where('post_id', 1)->count(); //вывод количества записей из выборки
						9) ->min();
						Аргументмо метода выступает поле, минимальное значение которого нужно вывести. 
						Пример:
							DB::table('comments')->min('post_id'); 
						10) ->max();
						Аргументмо метода выступает поле, максимальное значение которого нужно вывести. 
						Пример:
							DB::table('comments')->max('post_id'); 
						11) ->avg();
						Аргументмо метода выступает поле, среднее значение которого нужно вывести. 
						Пример:
							DB::table('comments')->avg('post_id'); 
						12) ->sum();
						Аргументмо метода выступает поле, суммарное значение которого нужно вывести. 
						Пример:
							DB::table('comments')->sum('post_id'); 
						13) ->exists();
						Метод выводит булево значение о наличии хотя бы одного поля с данным значением. 
						Пример:
							$comments = DB::table('comments')->where('post_id', 1)->exists();
						
						При написании запросе через QueryBuilder бывает проблематично найти ошибку в написанном запросе. 
						14) ->dd();
						Метод dd() при применении к запросу выводит его форматв SQL синтексисе. 
						Пример:
							Написание запоса через QueryBuilder => 
								DB::table('comments')->where('post_id', 1)->dd();
							Вывод содержимого запроса на экран через функцию => 
								"select * from `comments` where `post_id` = ?"
							Подставляемые значения в запрос =>
								array:1 [ 
									0 => 1
								▼]
							
							Этот метод стоит вызывать при ошибках запроса или не ожидАемом результате. 
						TODO ВАЖНО! Это метод, который часто используется для отладки. О нем стоит помнить. 
						15) ->chunk();
						Метод разбивает коллекцию на несколько более мелких коллекций заданного размера.
						TODO ЗАМЕТКА: Метод "chunk()" нужен для избежания нехватки оперативной памяти, когда изначально выводимая коллекция весьма объЁмна. На очень большой запросы ее може не хватить, поэтому он дробится на более мелкие и выводится по частям.
						Допустим нужно извлечь все записи таблицы с сортировкой по "id". 
						Аргументами метода являются во первых - количество записей в отдельной группе, во вторых - замыкание с переменной, хрянящее записи в колличестве первого аргумента, т.е. коллекцию. В теле замыкания пишится код вывода полученных записей. 
						Предварительно до помещения в замыкание переменная с коллекцией не объявляется.
						Пример:
							DB::table('comments')->orderBy('id')->chunk(2, function($comments){
								foreach ($comments as $comment) {
									print_r($comment);
									echo '<br>';
								}
								echo 'Chank end<br><hr>';
							});
							где,
								2 - количество записей в передаваймой в замыкание коллекции
								$comments - передаваемая коллекция
								foreach(...){...} - вывод коллекции
								echo 'Chank end<br><hr>'; - завершение иттерации вывода первой пачки данных в виде малой колекции, записанных в замыкание (2 шт).
							16) ->lazy();
							Это возможно более удобный аналог "chunk();", но и более медленный, так как большие запросы делятся на подколлекцию с 1-м элементом. Метод максимально экономит оперативку и нагружает БД. 
							Т.е. запись lazy()->each(function($comment){...}); == chunk(1, function($comments){...};
							Аргументом выстапет переменная, хранящая запись строки.
							Пример:
								DB::table('comments')->orderBy('id')->lazy()->each(function($comment){
									print_r($comment);
									echo '<br><hr>';
								});
							Так как в малую коллекцию кладется только один элемент/строка, то для ее вывода цикл не требуется. 

							ИТОГО: текущего набора методов для построаения бОльшего количества запросов вполне себе достаточно.
							Что до InnerJoin'в, то на практике они встречаются редко и с информацией по ним можно ознакомиться в докумнетации.							
		*/

	echo '<hr><hr><br><h3>Laravel - #14.1-1 - Навигация по страницам (День 14)</h3><hr><hr>' . "<br>";
		//!Урок 1: Навигация по страницам
		/*
			Пагинация без фреймворка требует самостоятельного расчета количества страниц, записей, формирования ссылок на страницы. 
			В laravel доступ ко всему этому полагается через метода paginate(); Он является последним методом запроса так же как get() || first();
			Он прилагается к запросу к БД, формируя данные нужные для пагинации дполученных данных из запроса. 
			Аргументом метода paginate(); является число строк, выводимых на странице. 
			Метод возвратщает объект (НЕ коллекцию), имеющий доступ к методом настройки пагинации на странице.
			
			Пример:
				$comments = DB::table('comments')->paginate(10);
					return view('pagination', ['comments' => $comments]);
				где,
					$comments - объект пагинации, которому доступны методы работы с пагинацией в шаблоне
				TODO ЗАМЕТКА: объект пагинатора так же реализует интерфейс итератора. Т.е. прогоняется через цикл как массив. 
				
			Обычно для вывода ссылок пагинации требуется отдельаня верстка и это так, но она может выводится за счет встроенного в laravel фреймворка tailwind css.
				Есть и другие (например bootstrap 4), но рассмотрим tailwind.
			TODO ЗАМЕТКА: если же требуется самому пропиать верстку пагинации - для этого прописывается команда: "php artisan vendor:publish --tag=laravel-pagination". 
				Эта команда копирует директорию работы с пагинации из захрамов laravel в указанную нами папку и дает ей приоритет чтения. Такой же прием уже использовался в теме "пользовательские страницы ошибок". 
				Этот шаблон и используется для отображения пагинации "resources\views\vendor\pagination\tailwind.blade.php".
				Рассмотрим методы прописанные в этом шаблоне и на их основе сделаем свою версию пагинации. 

			МЕТОДЫ ОБЪЕКТА-ПАГИНАТОРА
				1) ->currentPage(); - Метод вывода номера страницы. 
					Пример:
						<h1>Комментарии (Страница {{ $comments->currentPage() }})</h1> == Комментарии (Страница 1)
				2) ->links(); - Метод выводящий ссылки на страници пагинации (предыдщая следующая и т.д.)
					Пример:
						{{ $comments->links() }}
				3) ->hasPages(); Метод проверяет объект на наличие хотя бы одной страницы. 
					Пример:
						$paginator->hasPages();
				4) ->onFirstPage(); Метод проверяет нахождение на первой странице.
					Пример:
						$paginator->onFirstPage();
				5) ->hasMorePages(); Метод проверяет наличие оставшихся невыведенных страниц с учетом выведенных. 
					Пример:
						$paginator->hasMorePages();
				6) ->previousPageUrl(); Метод выводит ссылку на предыдущую страницу
					Пример:
						$paginator->previousPageUrl();
				7) ->nextPageUrl(); Метод выводит ссылку на слудующую страницу
					Пример:
						$paginator->nextPageUrl();
				8) ->firstItem(); Метод выводит порядковый номер выводимого списка у первого элемента на текущей странице. 
					Т.е. если выводимых элементов 20, а записей на странице 5, то на второй странице метод будет выводить 6. 
					Пример:
						$paginator->firstItem();
				9) ->lastItem(); Метод выводит порядковый номер выводимого списка у последнего элемента на текущей странице. 
					Т.е. если выводимых элементов 20, а записей на странице 5, то на второй странице метод будет выводить 10. 
					Пример:
						$paginator->lastItem();
				10) ->count(); Метод выводит число выводимых элементов на одной странице. 
					Пример:
						$paginator->count();
				11) ->total(); Метод выводит число всех выводимых элементов на страницах. 
					Пример:
						$paginator->total();

				Напришем отдельынй шаблон для пагинации и присоеденим его к основному шаблону.
				Пример:
					Ссылка в основном шаблоне на шаблон панигации:{{ $comments->links('mypagination') }}
					где,
						mypagination - шаблон пагинации
					TODO ЗАМЕТКА: в это место можно подключать шаблоны, также встроенные в laravel. Например тот же bootstrap-4/5: "vendor.pagination.bootstrap-5".
					Код в шаблоне пагнации:
						@if ($paginator->hasPages())
							<nav>
								{{-- Pagination Elements --}}
								@foreach ($elements as $element)
								{{-- "Three Dots" Separator --}}
								@if (is_string($element))
									<span> 
										<span>{{ $element }}</span>
									</span>
								@endif

								{{-- Array Of Links --}}
								@if (is_array($element))
									@foreach ($element as $page => $url)
											@if ($page == $paginator->currentPage())
												<span>
													<span>{{ $page }}</span>
												</span>
											@else
												<a href="{{ $url }}">{{ $page }}</a>
											@endif
									@endforeach
								@endif
							@endforeach
							</nav>
							@endif
				
				Выведенный список страниц:
					1 2 ... 7 8 9 10 11 12 13 ... 19 20
		*/
		use function Termwind\style;

		echo '<hr><hr><br><h2>Модуль №15.15-19:  Модель</h2>' . "<br>";
		echo '<hr><hr><br><h3>Laravel - #15.1-2 - Создание модели, Фабрика (День 15)</h3><hr><hr>' . "<br>";
			//!Урок 1: Создание модели
			/*
	
			В Laravel используется ORM библиотека Eloquent: Getting Started, позволяющая не писать нативный запрос к базе. Это подходит к небольшим проектам. Библиотека делает запосы объекто ориентированными.
				TODO ЗАМЕТКА: библиотека производит отображение реляционную модель в объектную модель таблицы и обратно. 
					Т.е. Eloquent преобращует строку в таблице в объект и обратно. 
	
			МОДЕЛЬ - это класс объект которого взаимодействует с конкретной таблицей в БД.
				TODO ЗАМЕТКА: Чаще всего на практике запросы пишутся с использованием моедлей, а не составление SQL запросов и QueryBuilder'ы, как в прошлых уроках. 
					Т.е. обращения к определенной таблице осуществляется через определенную модель.
	
			
			При создании модели - может создается миграция на основе которой создается таблица. 
			Миграция опишит таблюцу внутри БД, а модель будет исполнять функционал связанный с таблицей под которую создавался. 
			Команда создания модели:
				Пример: 
				php artisan make:model Post -msc
				где, 
					php artisan				- обращение к помошнику
					make:model				- команда создания модели 
					Article					- название модели
					-m							- опция создания миграции при создании таблицы 
					-s							- опция создания сидера для наполения таблицы
					-с							- опция создания контроллера
					-f							- опция создания фабрики
					"m", "с", "f" и "s" могут выводиться по одиночки и в любом порядке.
					TODO ЗАМЕТКА: Чаще в опциях прописываются миграция, сидер, фабрика - без контроллера => "php artisan make:model Post -msf"
	
					В каждой созданой моделе появляется трейт, вызывающий фабрику.
					Пример:
						use HasFactory;
	
					TODO ЗАМЕТКА: в отличии от моделей фреймворка Django - в моделях Laravel не фигурируют ни таблицы, ни типы полей - для этого создаются миграции.
					TODO ЗАМЕТКА: При создании модели - создается таблица с названием модели во множественном числе. Пример: "Article" = "articles".
						
					ВАЖНЫЕ ЗАМЕТКИ ПО РАБОТЕ С МОДЕЛЬЮ/ТАБЛИЦЕЙ/МИГРАЦИЕЙ
					ИЗМЕНЕНИЕ НАЗВАНИЯ ТАБЛИЦЫ, ПРИВЯЗАННЙО К МОДЕЛИ
						Если сгенерированное название таблицы не подходит - его можно изменить в миграции, но так же в моделе нужно будет добавить поле с название таблицы, к которой она будет привязываться "protected $table = 'nameTable';".
						
					ОТКЛЮЧЕНИ ПОЛЕЙ С ДАТОЙ СОЗДАНИЯ И РЕДАКТИРОВАНИЯ
						Если в таблице не нужны поля создания и редактирования поля, то настройка "$table->timestamps();" комментрируется в миграции, а в моделе создается поле, отключающее этот функционал от таблицы во избежании ошибок. "public $timestamps = false;" 
	
					ИЗМЕНЕНИЕ ПЕРВИЧНОГО КЛЮЧА
						а) Для изменения первичного ключав моделе прописывается поле, указывающее его "protected $primaryKey = 'alias';".
						б) Для указания типа поля первичного ключа (н.п. если он хранит не числа) прописывается поле "protected $keyType = 'string';". 
	
					ЗНАЧЕНИЯ ПО-УМОЛЧАНИЮ В ТАБЛИЦЕ
						Значения по-умолчанию в таблцие можно указывать в миграции, но так же и в моделе и это удобнее. 
						Пример:
							protected $attributes = [
								'title' => 'newPost',
								'is_publish' => false
							];
			*/
	
			//!Урок 2: Фабрика
			/*
				Фабрика - это инструмент заполнения таблциы данными, используемый в сидере, делающий его удобнее. 
				Фабрика удачно сочитается с использованием библиотеке "facker", генерирующуй случайные данные. 
				Папка с фабриками:
					"database\factories\"
				Команда создания фабрики.
					Пример:
						php artisan make:factory PostFactory
							или
						php artisan make:model Post --factory / -f
							где,
								PostFactory - назвение фабрики
								--factory / -f - опции создания фабрики
	
				В созданной фабрике имеется только метод "definition()", возвратщающая массив данных для создаваемого объекта/модели.
				Фабрика имеет возможность генерации даных случайным образом через обращение к библиотеке "facker".
					Пример:
						return [
							'author' => $this->faker->name(),
							'title' => $this->faker->text(mt_rand(10, 30)), //генерация случайного колличества символов от 10 до 30
							'is_publish' => mt_rand(1, 2) == 1 //рандомный вывод числа, при котором 1 == true
						];
	
				TODO ЗАМЕТКА: объект "faker" доступен в фабрики по-умолчанию. Т.е. его подключать не нужно.  
				TODO ЗАМЕТКА: поля "created_at" и "updated_at" не заполняются, так как используется фабрика. 
				TODO ЗАМЕТКА: Ссылка на библиотеку "faker" "https://github.com/fzaninotto/Faker" с примерами использования методов объекта. 
	
				ВЫЗОВ ФАБРИКИ В СИДЕРЕ
					Для вызова фабрики модели ее нужно привязать к сидуру (модель), пространство имен.
					Пример прописи пространства имен модели в сидере:
						use App\Models\Post;
					TODO ЗАМЕТКА: Так как в моделе прописан трейт "HasFactory", связывающий ее с фабрикой - фабрика сама понимает, с какой моделью она связана. Так что достаточно привязки к сидеру только моедли, так как через сидер она наследует функционал нужной фабрики. 
					Пример обращения в сидере к фабрике чреез модель:
						public function run(): void
						{
							POST::factory()->count(10)->create();
						}
						где,
							POST - модель, к которой привязана фабрика
							factory() - метод вызова фабрики. Доступен модели через трейт "HasFactory".
							count() - метод, указывающий количество создаваемых записей/объектов. Аргументом является число. 
							create() - метод, записывающий значения созданных объектов в БД. 
						
						TODO ВАЖНО! Не забываем подключать к зупускающемуся по-умолчанию сидеру "DatabaseSeeder" в методе call([]) запускаемый сидер в примере "PostSeeder".
	
						Для сравнения ниже код напоняения таблицы без фабрики:
							$names = ['Freed', 'Helga', 'Nicolas', 'Василий', 'Григорий'];
							for ($i=0; $i < 200; $i++) { 
								$post_id = mt_rand(1, 10);
								$name = Arr::random($names); //хелпер, работы с массивом (метод "random" выбирает случайны элемент). 
								$text = Str::random(mt_rand(30, 100)); //хелпер, генерации текста (метод "random" выбирает одно из предложенных значений). 
								$created_at = date('Y-m-d H:i:s');
								$updated_at = $created_at;
	
								2-й способ передачи данных в таблицу
								DB::table('comments')->insert([
									'post_id' => $post_id, 
									'name' => $name, 
									'text' => $text, 
									'created_at' => $created_at, 
									'updated_at' => $updated_at
								]);
							}
	
						И код фабрики + сидера:
						return [
							'author' => $this->faker->name(),
							'title' => $this->faker->text(mt_rand(10, 30)), //генерация случайного колличества символов от 10 до 30
							'is_publish' => mt_rand(1, 2) == 1 //рандомный вывод числа, при котором 1 == true
						];
						POST::factory()->count(10)->create();
			*/
	
		echo '<hr><hr><br><h3>Laravel - #16.1-1 - Работа с моделями (День 16)</h3><hr><hr>' . "<br>";
			//!Урок 1: Работа с моделями
			/*
				РАБОТА В БД ЧЕРЕЗ МОДЕЛЬ
					Для начала работы с моделью талицы - ее нужно подключить. 
					Пример подключения модели к контроллеру:
						use App\Models\Post;
	
					СПОСОБЫ СОЗДАНИЯ ЗАПИСЕЙ В БД
						1) Объявление объекта модели
							Пример:
								$post = new Post();
								$post->author = 'Федор';
								$post->title = 'новый пост';
								$post->is_publish = false;
								$post->save();
								где,
									$post - объект модели
									author/title - название полей таблицы  
									save() - метод занесения записи в таблицу
									
						2) Использование фабрики модели
							Пример:
								$post = Post::factory()->make();
								echo '2-й способ записи: '.$post->author; //вывод поля со случайным значением
								$post->title = 'Добавленный пост';
								$post->save();
							TODO ЗАМЕТКА: $post->author - поле, генерирующее случайное значение каждый раз при обращении, потому, что выводится через фабрику.
	
						4) Изменения полей в таблице
							Пример:
								$post = Post::create(['author' => 'Ванек', 'is_publish' => true]); 
							TODO Заметка: метод create() не только создаст объект на основе добавленной записи, но и сразу добавит ее в БД. 
							НО такая запись выдаст ошибку: Add [author] to fillable property to allow mass assignment on [App\Models\Post]. 
								Что значит поле не добавлено в массив "fillable" в моделе. 
							TODO ВАЖНО! $fillable - это массив полей, значения которых можно изменять в таблице, и которые можно записывать в БД через фабрику. При попытки изменить поля, незаписанные в массиве $fillable - вывдится ошибка. Этот массив безопасных полей, созданный для ограждения запросов затрагивающих БД в целях безопасности. 
							//Этим полям можно устанавливать значения по-умолчанию.
							TODO ВАЖН!О Для в случаи заполненного в модели массива $fillable - в фабрике тоже должны быть указаны поля из этого масива, чтобы фабрике было разрешенол их обновлять.
							Пример заполнения массива:
								В моделе:
								protected $fillable = [
									'name',
									'email',
									'password',
								];
								
						ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ МОДЕЛИ И СПОСОБЫ ПОСТРАЕНИЯ ЗАПРОСА
							Принцип построения запросов через модель аналогичен принципе построение запросов через QueryBuilder'ы. 
							Но вместо фассада DB будет подставляться модель. 
	
							Методы вывода
							1) find(); Метод заносит в коллекцию строку с заданным Id для вывода.
								Аргументом являтся число Id выводимой строки.
								Пример:
									$post = Post::find(5);
									echo 'Вывод поля строки: "'.$post->title.'"<br>';
	
							2) findOrFail(); Аналог метода find(), но при отсутствии вносимого аргумента (Id) выдает ошибку 404.
								Пример:
									$post = Post::find(5);
									echo 'Вывод поля строки: "'.$post->title.'"<br>';
	
							3) all(); Метод заносит в коллекцию все строки таблицы.
								Аргументом являтся число Id выводимой строки.
								Пример:
									foreach (Post::all() as $post) {
										echo 'Вывод всех значений выбранного поля объекта: "'.$post->title.'"<br>';
									}
	
							Методы проверки на наличие изменений в объекте:
							4) ->isClean(); Метод проверяет модель на изменения после ее извлечения (после объявления объекта модели). 
								Возвратщает булево значение. True - если изменения не происходили. False - если происходили.
								Аргументом может выступать конкретное поле объекта. Т.е. изменялось либо конкретное поле. 
								Пример:
									echo 'Проверка объекта на изменения через "isClean()" '.$post->isClean().'<br>';
									echo 'Проверка объекта на изменения через "isClean()" '.$post->isClean('title').'<br>';
	
							5) ->isDirty(); Аналог метода "->isClean()", но при изменении объекта возвратщает True.
							Аргументом может выступать конкретное поле объекта.
								Пример:
									echo 'Проверка объекта на изменения через "isDirty()" '.$post->isDirty().'<br>';
	
							Метод сортировки:
							6) ->reject(); (отвержение) Метод исключает параметры из коллекции перед выводом объекта. Т.е. является фильтром.
								Это может потребоваться, когда в определеннй момент выполенния некоторые параметры для вывода больше не требуются, а создание нового запроса даст лишнюю нагрузку на БД.
								Аргументмо является callback функция, у которой аргументом является объект-коллекция. В теле замыкания прописывается поле с исключаемым значением.
									Пример испоьзования метода:
										$posts = Post::all();
										$posts = $posts->reject(function($posts){
											return $posts->author == 'Eladio Thiel';
										});
										foreach ($posts as $post) {
											echo 'Вывод всех значений поля объекта: "'.$post->author.'"<br>';
										}
	
							Меотды экономии оперативки:
							7) ->chunk(); Метод экономит оперативку, но и опционально загружает БД.
								Аргументмо первым аргументои является количество записей в одной мини-коллекции, вторым замыкание с аргументом дробимой коллекцией.
								В теле замыкания цикл с выводом мини-коллекции. 
									Пример испоьзования метода:
										Post::where('is_publish', 0)->chunk(3, function($posts){
											foreach ($posts as $post) {
												echo $post->author.'<br>';
											}echo '.............<br>';
										});
	
							8) ->cursor(); Аналог метода chunk(), но выводящий только одну запись == chunk(1, function($collection){...}). 
								Метод максимально экономит оперативку, но максимально нагружает БД. Так как обращения к ней идут после каждой записи.
									Пример испоьзования метода:
										foreach (Post::where('is_publish', 0)->cursor() as $post){
											echo $post->title.'<br>.............<br>';
										}
	
							Меотд обновления:
							9) ->update();
								Пример испоьзования метода:
									Post::where('id', '<', 5)->update(['is_publish' => 1]);
	
							Методы удаления:
							10) ->delete(); Метод удаления записи , указанной в выборке. 
								Пример испоьзования метода:
									Post::find(11)->delete();
	
							11) ->destroy(); Аналог метода delete(), но не требующий предварительной выборки
								Меод может принимать аргументы в виде номера Id (либо массива с Id) удаляемой записи без необходимости выборки.
								Пример испоьзования метода:
									Post::destroy(11); //удаление одной записи
									Post::destroy([5, 8, 9]); //удаление множества записей
							TODO ЗАМЕТКА: в случаи попытки удаления несуществующей записи - ошибка не выдается. 
	
							12) withTrashed(); Метод вывода записей, удаленных через мягкое удаление. 
								Пример испоьзования метода:
									$posts = Post::withTrashed()->get();
										ИЛИ
									$posts = Post::withTrashed()->where('id', '<', 5)->get();
										foreach ($posts as $post) {
											echo $post->author.'<br>^^^^^^^^^^^^^^<br>';
										}
	
					МЯГКОЕ УДАЛЕНИЕ/ФЕЙКОВОЕ УДАЛЕНИЕ
						МЯГКОЕУ ДАЛЕНИЕ - функционал позволяющий удалять записи буз полного ее стирания из БД, вешая пометку даты удаления записи. 
						Бывыют ситуации, когда нужно чтобы какая то запись не отображалась на сайте, однако, полное удаление остается весьма нежелательным. 
						В таком случаи проктикуется "мягкое удаление". 
						
						Для ввода возможности мягкого удаления требуется подключение трейта к модели:
						Подключени: 
								use Illuminate\Database\Eloquent\SoftDeletes;
							Вызов трейта в моделе:
								use SoftDeletes;
							TODO ВАЖНО! Поделюченный трейт подразумевеет, что в таблице уже есть поле, вмещающее дату удаления записи.
										
						Создание поля с датой мягкого удаления в миграции:
						$table->softDeletes();
						Созданое поле в таблице после обонвления запуска миграции:
						deleted_at
						
						Теперь при удалении записи например "Post::destroy(11);" - она перестанет отображаться на сайте, но не удаляется из БД.
						В поле "deleted_at" заносится дата удаления записи. 
	
						TODO ЗАМЕТКА: наличии мягкого удаления подразумевает возможность автоматического удаления записи через определенныый срок. 
						
	
				*/
	
		echo '<hr><hr><br><h3>Laravel - #17.1-2 - Аксессоры и мутаторы, Наблюдатели/Observers (День 17)</h3><hr><hr>' . "<br>";
			//!Урок 1: Аксессоры и мутаторы
			/*
				АКСЕССОР
					Аксессоры - это механизм, получающий доступ к свойствам, перед их запросом во внешнем коде. Т.е. переде выдачей из БД. 
						ИЛИ
					Аксессор преобразует значение атрибута объекта Eloquent при обращении к нему. 
					Т.е при обращении к значению свойству через Eloquent - срабатывает "аксессор" - функция, которая преоразовывает значение перед выводом.
	
					Аксессор может быть полезен, когда изменения с значениями свойст нужно будет производить достаточно часто, без необходимости прописи опции изменений свойства в методе контроллера. 
					
					Например "аксессоры" позволяют приводить даты в определенный формат перед выводом. Или выводить имя автора статьи в верхнем регистре.
	
					TODO ЗАМЕТКА: Аксессор и мутатор пишутся в моделе через публичный метод.
					Правило прописи назхвания аксессора - префикс "get" + "название ловимого свойства" + суффикс "Attribute". 
					Поэтому название аксессору и мутаторам важно давать согласно конвенции имен Laravel.
						Пример записи кода аксессора:
						public function getAuthorAttribute($val){
							return mb_strtoupper($val);
						}
						где,
							getAuthorAttribute - название акссесора
							get - префикс акксессора
							Author - название ловомого свойства
							Attribute - свойство, указывающее что функция является аксессором
							$val - ловимое значение
							mb_strtoupper - метод преобразования текста в верхний регистр
					
						Пример записи кода вывода свойства:
							$post = Post::find();
							echo $post->author; == МАКСИМИЛИАН ЛОУ V
	
					Акссесор можно оставлять пустым, но тогда толка в нем немного.
					
				МЕТАТОР
					Мутаотор - преобразует полученные данные перед записью их в БД. 
					Т.е. аналог аксессора, только наоборот. 
					TODO ЗАМЕТКА: правило прописи названия мутатора аналогично правило аксессора заисключением префикса set вместо get. 
					Пример записи мутатора:
						public function setAuthorAttribute($val){
							$this->attributes['author'] = $val;
							$this->attributes['title'] = 'Текст поста изменен автором - '.$val;
						}
						где,
							setAuthorAttribute - название мутатора
							set - префикс мутатора
							$val - вночимое значение
							$this-> - указатель на поле внутри объекта
							attributes - массив с свойством изменяемого поля
							author/title - название изменяемых полей
	
					Пример записи кода записи свойства в БД:
						$post = Post::find();
						echo $post->author; == МАКСИМИЛИАН ЛОУ V
						$post->author = 'Новый автор';
						$post->save();
						echo 'Новое название атвора: '.$post->author;
	
				СПОСОБЫ СВЕДЕНИЯ ТИПОВ ДАННЫХ
					Частенько в полях БД подразщумевающих тип данных "Boolean" вмещают цифры 1 и 0, т.е. типами Integer. 
					На практике хотелось бы, чтобы подразумевающиеся типы данных в поля и действительные совпадали. 
					Для исправления этой ситуации есть два способа: через аксессор или 
					Оба способа прописываются в моделе. 
	
					1-й способ (аксессор):
						public function getIsPublishAttribute($value){
							return (bool) $value;
						}
					2-й способ (массив "$casts"):
						protected $casts = [
							'is_publish' => 'boolean',
						];
						где,
							protected - обязательное правило приватности массива
							$casts - название массива (обязательное) для хранения типов данных полей таблицы
							is_publish - название поля таблицы
							boolean - устанавливаемое значение поля таблицы
	
					TODO ЗАМЕТКА: способ прописи типа данных полей таблицы в массиве/поле модели $casts - считается наиболее удобным.
					Такая система используется в проектах часто, особенно при работе с датой и временем. 
				
			*/
	
			//!Урок 2: Наблюдатели/Observers
			/*
				Наблюдатель ИЛИ Observer - это реализованный патерн проектирования, позволяющий отслеживать объект, находящийся в другом объекте. 
					При этом наблюдаемый объект о наюлюдателе не будет ничего знать.
					Наблюдатель может пригодится например при необходимости оповещения людей при определенных событиях в моделе либо для логировнаия.
					Observer создается, когда на большинство методов модели напрашивается наличие событий. Это нужно для того, чтобы не плодить кучу событий-event'ов или лешнего смешивания логики во множесте функций взаимодействующих с моделью.
	
				Команда создания наблюдателя:
					php artisan make:observer --model:Post
	
				Команда создания Observer:
					php artisan make:observer CommentObserver --model=\App\Models\Comment
					где, 
						make:observer 						- создание обсервера
						PostObserver 						- название обсервера
						Post									- название модели, к которой создается наюлюдатель
						--model=\App\Models\Post 	- модель к которой пикрепляется обсервер 
							ИЛИ
						--model=Post
					После создания класс появляется в папке "\app\Observers\PostObserver.php";				
	
				TODO ЗАМЕТКА: Наблюдатель имеет список функций, привязаных к CRUD операциям модели. 
	
				Список функций в наблюдателе:
					1) created			- срабатывает при создани записи таблицы
					2) updated			- срабатывает при обновлении поля/записи
					3) deleted			- срабатывает при удалении записи
					4) restored			- срабатывает при восстановлении записи после удаления (мягкого удаления)
					5) forceDeleted	- срабатывает при безвозвратном удалении записи
	
				TODO ВАЖНО! Чтобы наблюдатель заработал, помимо создания нужно привязать его к моделе в провайдере "app\Providers\EventServiceProvider.php".
					
				Привязка наблюдателя к модели:
					Привязка наблюдателя и модели производится в файле "app\Providers\EventServiceProvider.php" в методе "boot()".
					Предварительно к провайдеру нужно подключить и наблюдателя и модель:
						use App\Models\Post;
						use App\Observers\PostObserver;
					
					Пример подключения наблюдателя к моделе:
						public function boot(): void
						{
							Post::observe(PostObserver::class);
						}	
						
					Теперь при обновлении записи - сработает наблюдатель.
					Код в контроллере:
						$post = Post::factory()->make();
						$post->title = 'Пост создан чреез testObserver';
						$post->save();
					Код в наблюдателе:
						public function updated(Post $post): void
						{
							echo 'Запись наблюдателя: запись с ID == '.$post->id.' обнавлена.<br>';  == Запись наблюдателя: запись с ID == 11 создано.				
						}
					
				*/
	
		echo '<hr><hr><br><h3>Laravel - #18.1-2 - Отношение один к одному, Отношение один ко многим (День 18)</h3><hr><hr>' . "<br>";
			//!Урок 1: Отношение один к одному
			/*
				СОЗДАНИЕ МОДЕЛЕЙ И ИХ НАПОЛНЕНИЕ
					Для комбинированного вывода данных из несокльких таблиц - вместо оператора JOIN в Eloquent используются отношения между моделями. 
					Отношение выражается в соотношении информации таблиц моделей. Это делается во избежании раздувания размера таблиц.
					Например, когда через статью автора нужно определить время регистрации, авторизации, почту UTM-метки и т.д.
					В этом уроке разберем отношение "один к одному", а в следующем "один ко многим" затем и "многие ко многием".
					
					Содадим таблицы с клиентами и адресами c "один к одному/belongsTo" + миграции/фабрики/сидеры.
						php artisan make:model Client -msf
						php artisan make:model Address -msf
					
						В миграции адресов пропишем str адрес. В миграции клиентов str имя клиента, int address_id. 
						TODO ЗАМЕТКА: можно назвать поле с ID адреса и по другому (без суффикса _id), но потом в отношении моделей будет нужно указать это поле.
	
					В фабрике для таблиц создаем фейкеры:
						'adress' => $this->faker->address(); //Address
						'name' => $this->faker->name(), //Clients
						'address_id' => 'address_id' =>$this->faker->unique()->randomElement(range(1, 10))
						где,
							unique() - метод, генерирующий значение из массива, которое не будет повторяться
							randomElement() - метод выбирающий случайный элемент
							range() - функция генерирующая массив с числами от первого аргумента до второго
						Так как мы собираемся создавать таблицу, в которой адреса у клиентом не повторяются - мы прописали их уникальными. 	
						TODO ВАЖНО!: шаг генерации с уникальными значениями должен соответстовать количеству генерируемых записей в таблице. Иначе ошибка. 
							
					Прикрепляем к каждому сидуру свою фабрику:
						Address::factory()->count(10)->create();
						Client::factory()->count(10)->create();
					Подключаем созданные сидеры к главному сидеру:
						$this->call([...
							AddressSeeder::class, 
							ClientSeeder::class, 
						]);
					Запускаем миграции:
						php artisan migrate:fresh --seed
	
					Создаем контроллер с подключением к созданным моделям и можно начинать прописывать отношения в моделях. 
					
				НАСТРОЙКА ОТНОШЕНИй МЕЖДУ МОДЕЛЯМИ
					В модели с клиентами уже есть Id поля адресс. Через это поле и отношения моделей получим доступ к адресам. 
					Так как мы пропишем, что  у одного клиента может быть один адрес, то пропишем сявзь один к одному. 
					Отношение прописываются в функции моделе именем которой явялется имя таблицы, с которой прописываются отношения.
					
					Пример связи моделей Client и Address по схеме "один к одному":
						public function address(){
							return $this->belongsTo(Address::class);
						}
						где, 
							belongsTo				- метод указывающий ссылку по типу "один к одному"
							Address	- модель, с которой устанавливается связи и берется информация
	
					Пример связи моделей Address и Client по схеме "один к одному":
						public function client(){
							return $this->hasOne(Client::class);
						}
	
					TODO ЗАМЕТКА: методы отношений "belongsTo" и "hasOne" идентичны - просто имеют разные названия.
	
					TODO ВАЖНО! В примере выше Eloquent будет искать связь между address_id в модели Clients и id в модели Address. По умолчанию Eloquent определяет имя внешнего ключа по имени метода отношения, добавляя суффикс _id. Однако, если имя внешнего ключа модели Phone не address_id, передайте это имя вторым параметром в метод belongsTo():
	
					TODO ЗАМЕТКА: Как и для метода hasOne()/belongsTo() вы можете указать внешний и локальный ключи, передав дополнительные параметры в метод hasMany():
					
					При этом в связях "один к одному/один ко многим" первым выступает модуль в котором прописывается связь, в вторым число возможных связей.  
					Если у модуля User, прописывается сввязь например с кооментариями или статьями, то и в первом и во втором случаях это связи "один ко многим", так как у одного пользователя может быть мнодество статей и множество комментариев.
					А у одного комментария один автор и одна статья.  
	
					Когда связи установлены можно выводить информацию в статьях. 
					TODO ВАЖНО! При наличии отношений между моделями - тип передачи данных в шаблона чреез класс "DB" будет выдавать ошибку: поэтому при наличии этих отношений передавать информацию в шаблон через модель.
							Пример:
								Вариант с ошибкой:	$articles = DB::select('SELECT * FROM articles');
								Вариант без ошибки:	$articles	= Article::all();
	
					ВЫВОД ЗАПСИЕЙ
						Вывод записи адреса клиента в контроллере:
							$client = Client::find(1);
									echo 'Вывод имени клиента: '.$client->name;
									echo 'Вывод адреса клиента: '.$client->address->address;
							}
							где,
								$client->name - вывод имени клиента
								$client->address->address - вывод адреса клиента
								->address-> - название модели, привязанной к таблице "addresses"
								->address - название выводимого поля, к которому обращается $client
									Вывод имени клиента: Афанасьева Иммануил Дмитриевич
									Вывод адреса клиента: 494438, Магаданская область, город Москва, проезд Славы, 15
						
						Вывод записи клиента из таблицы с адресами в контроллере:
							
			*/
	
			//!Урок 2: Отношение один ко многим
			/*
				Отношение таблиц один ко многим подразумевает, что у одного элемента может быть множество связей с полем другой таблицы. 
				Например у одного автора клиента может быть множество заказов, в то время как у одного заказа может быть только один клиент.
	
				СОЗДАНИЕ МОДЕЛЕЙ И ИХ НАПОЛНЕНИЕ	
					php artisan make:model Order -msf - модель с заказами
	
					В миграции добавим поле с  Id клиента:
						$table->integer('client_id');
					В фабрике добавим пропишем его наполнение:
						'client_id' => mt_rand(1, 10) //так как у таблицы будет связь один ко многием, то уникальные значения полю ник чему
					
				НАСТРОЙКА ОТНОШЕНИй МЕЖДУ МОДЕЛЯМИ
					Отношения модели Order к Client
						public function client(){
							$this->belongsTo(Client::class); 
						}
	
					Отношения модели Client к Order
						public function orders(){
							return $this->hasMany(Order::class);
						}
	
					TODO ВАЖНО! Так как у клиента большое колличество заказов в при отношении один ко многим - в моделе прописывается множественное число таблицы: "orders", а не "order" если бы отношение было один к одному.
	
				ВЫВОД ЗАПИСЕЙ
					Вывод заказов клиента:
						$orders = Client::find(1)->orders;
						foreach ($orders as $order) {
							echo 'Вывод номера Id заказа клиента: '.$order->id.'<br>';
						}
					TODO ЗАМЕТКА: здесь так же указывается мнодественное число заказов, так как у клиента их много => "Client::find(1)->orders". 
	
					Вывод клиента заказа:
					$clien = Order::find(1)->client;
						echo 'Вывод клиента заказа: '.$clien->name.'<br>';
			*/
	
		echo '<hr><hr><br><h3>Laravel - #19.1-2 - Отношение многие ко многим, Ресурсный контроллер (День 19)</h3><hr><hr>' . "<br>";
			//!Урок 1: Отношение многие ко многим
			/*
			Отношения "многие ко многим" более сложное, но оно менее распрастранено. 
			Этот тип может пригодится в ситуации например, когда у множества заказав может быть множество товаров и у множества товаров может находиться в множестве заказов. 
					Т.е. заказ и товар жестко не привязаны друг к другу. 
					Т.е. и заказ может ссылаться на множество вмещаемых им товаров, так и товар на множество заказов, в которых сам находится.
					
					СОЗДАНИЕ МОДЕЛЕЙ И ИХ НАПОЛНЕНИЕ	
					Таблицы с заказами уже имеется - создадим таблицу с товарами:
						php artisan make:model Product -msf
						И создаем дополнительно модель-посредника между моделями с отношением "многие ко многим".
						php artisan make:model OrderProduct -msf
						
						Так как в таблице с товарами нельзя в одном поле указать множество заказов (order_id), как и в таблице заказов множество товаров (product_id), то создается 3-я таблица, которая будет посредником между таблицами со связью "многие ко многим". 
						TODO ВАЖНО! В отличии от прочих отношений - отношение "многие ко многим" подразумевает наличие 3-й таблицы-посредника между двумя первыми. 
						
						Создание 3-й модели-посредника:
							php artisan make:model OrderProduct -msf	
	
					TODO ВАЖНО! Модель 3-й таблицы создается из имен 1-й (Order) и 2-й (Prodect) моделей => php artisan make:model OrderProduct -msf	
						
					TODO ВАЖНО! Миграция задала названию таблицы-посредника во множественное число. Название должно содержать имя таблиц с отношением "многие ко многим" в единственном числе. 1-я тб. == "orders", 2-й тб. = "products", 3-я т.б = "order_product".
					
					TODO ВАЖНО! Так как название таблицы от предложенного миграцией изменено с множественного на единственное число, то в поле модели  "protected $table" нужно вписать желаемое название таблицы, котоыре было переправлено у миграции.
					
					Наполнение моделей:
					Product:
						$table->string('title', 255); -> Product
					OrderProduct:
						$table->integer('order_id');
						$table->integer('prodect_id');
					
					Переименуем в методе create() название таблицы с "order_products" на "order_product".
	
					Наполнение фабрик:
						Product:
							'title' => $this->faker->company() //допустим, продаются компании										
						OrderProduct:
							'order_id' => mt_rand(1, 30), //по числу записей в таблице заказов
							'product_id' => mt_rand(1, 10) //по числу товаров
	
					Наполнение сидов:
						Product:
							Product::factory()->count(10)->create();
						OrderProduct:
							OrderProduct::factory()->count(100)->create();
	
						Полключаем созданные сидеры к "database\seeders\DatabaseSeeder.php".
	
	
				НАСТРОЙКА ОТНОШЕНИй МЕЖДУ МОДЕЛЯМИ
					TODO ВАЖНО! Методы в моделях, содержащих связь с другими моделями - прописываются во множественном числе при связи "МКМ". 
					Отношения, прописываемые в моделях:
						Order:
							public function products(){
								return $this->belongsToMany(Product::class); 
							}
						Product:
							public function orders(){
								return $this->belongsToMany(Order::class); 
							}
						OrderProduct:
						
					TODO ЗАМЕТКА: Связь "многие ко многим" устанавливают метды "belongsToMany" и "hasMany" - они идентичны, но ставятся в разных связаннх моедлях.
				
				ВЫВОД ЗАПИСЕЙ
				TODO ЗАМЕТКА: в запросе моделей "МКМ" завершающая часть запроса должны быть в во множжетвенном числе: "->prodects/->orders".
					Вывод номера товара, где Id заказа = 1:
						$products = Order::find(1)->prodects;
						foreach ($products as $product) {
							echo 'Товар из заказа'.$product->title;
						}
					Вывод номера заказа, где Id товара = 1:
						$orders = Product::find(1)->orders;
						foreach ($orders as $order) {
							echo 'Вывод номера Id заказа, у которого товар имеет Id = 1: '.$order->id.'<br>';
						}
	
				ОСОБЕНОСТИ НАСТРОЙКИ ОТНОШЕНИЙ "МНОГИЕ КО МНОГИМ"
					1) Построение таблис с отношением "многие ко многием" подразумевает создание 3-й таблицы - посредника.
					2) Название созданной таблицы-посредника должно состоять из название 1-й и 2-й моделей в единственном числе => "order_product". 
					3) В созданное таблице должны находиться поля, указвающие на Id 1-й и 2-й таблиц: "order_id", "product_id".
					4) Название создаваемой таблицы-посредника должно быть в единственом числе: "order_product".
					5) Измененое название таблицы, отличное от варианта миграции - заносится в модель-посредник: protected $table = 'order_product';
	
			*/
	
			//!Урок 2: Ресурсный контроллер 
			/*
				Ресурсный контроллер (РК/ресурс) - контроллер направленный на обработку CRUD-операций определенной модели. 
				Обычно создается вместе с формой. 
				Пример создания РК:
					1-й способы создания ресурса:
						php artisan make:controller AddressController --resource --model=Address
					где,
						--resource - дополнительный атребут добавляющий контроллеру свое правило маршрутизации типа "resource". 
						--model - атребут, указывающий на модель к которой прикрепляется РК.
	
						Методы содержащиеся в РК:
							1) index()		- отвечает за вывод всех элемнетов
							2) create()		- выводит форму на создание/добавление
							3) store()		- принимает запрос от заполненой формы
							4) show()		- выводит передаваемую запись
							5) edit()		- открывает форму для редактирования записи
							6) update()		- обработка обновленной записи, отправленной из формы
							7) destroy()	- удаление записи (принимает только запросы на удаление)
				
					ПРАВИЛО МАРШРУТИЗАЦИИ ДЛЯ РК
						Для каждого метода можно создать вручную свое правило маршрутизации, но для ресурса есть запись, вмещающая все нужные методы.
						Добавим одно правило маршрутизации в файл "web".
						Пример:
							"Route::resource('addresses', App\Http\Controllers\AddressController::class);"
								где,
									resource - подразумевает множество правил маршрутизации
									addresses - ссылка на вызов ресурса
									TODO ЗАМЕТКА: методы, реагирующие на: GET запроc => index, show, edit; POST => store; PUT/PATCH => update; DELETE => destroy;
									TODO ЗАМЕТКА: по-умолчанию ссылка ведет на метод "index". Аргументом ссылки могут выступать методы РК, передаваемые GET методом.
										Методы show, edit подразумевают наличие аргумента:
											1) index: addresses/
											2) show: addresses/1
											3) edit: addresses/1/edit
											где,
												1 - Id, выводимой записи
												1/edit - Id редактируемой записи
									
							Данное правило маршрутизации вмещает в себя мноожество HTTP методов и методов созданного ресурса.
	
					ОТСЛЕЖИВАНИ ПРАВИЛА МАРШРУТИЗАЦИИ
						Чтобы отсделить созданное правило маршрутизации в проекте - пропишем команду: 
							TODO ЗАМЕТКА: php artisan route:list - команда отображения правил маршрутизации в проекте 
							Для в "web" отображается информация о множестве правилах маршрутищации, хотя в файле была запись только о РК (Route::resource(...)) : 
								GET|HEAD        addresses ....................addresses.index › AddressController@index  
								POST            addresses ....................addresses.store › AddressController@store  
								GET|HEAD        addresses/create .............addresses.create › AddressController@create  
								GET|HEAD        addresses/{address} ..........addresses.show › AddressController@show  
								PUT|PATCH       addresses/{address} ..........addresses.update › AddressController@update  
								DELETE          addresses/{address} ..........addresses.destroy › AddressController@destroy
								GET|HEAD        addresses/{address}/edit......addresses.edit › AddressController@edit  
								
					ОБРАЩЕНИЕ К РК ЗА ШАБЛОНОМ
						Код в контроллере:
							index:	
								return view('addresses.index', ['addresses' => Address::all()]);
							show:
								return view('addresses.show', ['address' => $address]);
							edit:
								return 'Показать форму для редактирования адреса: '.$address->address; Открывается по сыслке "addresses/ID/edit"
	
						Создадим шаблонs, которые будут выводиться в зависимости об обращения к ресурсу: index/show.
						index:
							<ul>
								@foreach ($addresses as $address)
									<li><a href="{{ route('addresses.show', ['address' => $address]) }}">{{$address->address}}</a></li>
								@endforeach
							</ul>
							где,	
								addresses.show - ссылка на адрес
								$address->address - названеи адреса
								['address' => $address] - псевданим аргумента и аргумент, передаваемые по ссылке							
			*/
	
			
	echo '<hr><hr><br><h2>Модуль №20.20-23:  Обработка форм</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #20.1-2 - Вывод форм, Валидация (День 20)</h3><hr><hr>' . "<br>";
		//!Урок 1: Вывод форм
		/*
			Создадим форму в этом уроке и рассмотрим процесс передачи данных из нее контроллеру. 
			Проверку переданых данных рассмотрим в следующем уроке. 
			Создадим контроллер: php artisan make:controller FormController
			И его маршрутизацию: Route::get('/testform', [App\Http\Controllers\FormController::class, 'testForm']);
			И маршрутизацию обработчика формы: Route::post('/testform/send', [App\Http\Controllers\FormController::class, 'send']);
			
			В процедуре создания формы нет ничего особенного. Laravel может предоставлять некоторые инструменты для работы с формой. 

			HTTP метод в форме можно укзать чрез директиву: @method('POST').

			CSRF ТОКЕН
			TODO ВАЖНО! В формы laravel нужно добавлять "@csrf" токен. Он нужен для безопастности. 
				Токен нужен, чтобы через форму методом POST не проходили несанкционированные запросы на сайт - без токена они работать не будут. 
				Перед выполнением запрос проходит через группу мидлваров "web". В ней есть мидлвар VerifyCsrfToken, которые проверяет наличие токена. Там токен и нужен. 

				Добавим в таблицу @csrf токен - он является проверочным ключом к запросу, поступающим через таблицу. 
				Запрос проходит в мидлвар "laravel\app\Http\Middleware\VerifyCsrfToken.php". В этот мидлвар можно вписать ссылки, которые/API, котоыре можно обрабатывать без наличия @csrf токена. 

		*/

		//!Урок 2: Валидация
		/*
				Принятые данные следует проверять прежде чем обрабатывать. 
				
				МЕТОДЫ ВАЛИДАЦИИ, ВЫВОДА ОШИБОК, СОХРАНЕНИЯ ЗНАЧЕНИЙ ПОЛЕЙ
				validate() - метод проверки данных из формы. Аргументом выступает массив с проверяемыми параметрами формы. Метод относится к объекту $request.
					Пример использования метода валидации:
						$validated = $request->validate([
							'name' => 'required|min:2|max:20',
							'text' => 'required|max:100',
							'bd' => 'nullable|data',
						]);
						где,
							request - объект со значениями из формы
							validate - метод валидации значений
							name/text/bd - проверяемые поля
							после знака => идут словия проверки полей
							$validated - массив с проверенными данными
						TODO ЗАМЕТКА: если валидация формы не пройдет, то метод validate() сделает редирект на страницу с формой, передавая в сессию причину ошибки валидации.
						TODO ЗАМЕТКА: код в контроллере после валидации начнет выполняться только после успешного её прохождения.
						TODO ЗАМЕТКА: метод validate() вызывает мнгновенный редирект на страницу с формой. Однако, может случиться ситуация, когда редирект не нужен. Для этого используется фассад "Validator", который не подразумевает редиректа - его можно настроить через условие после валидации.
							Пример:
								$validator = Validator::make($request->all(), [
									'image' => 'required|file|max:1024|mimes:jpg,png,gif'
								]);
				old() - функция Laravel, которая прописывается в шаблоне для сохранения значения поле после перезапуска страницы. Аргумент - название поля.
					TODO ЗАМЕТКА: Чтобы значение полей не сбрасывались при ошибках - в каждом поле в атребуте "value" вставим метод "old()" с атребутом поля.
					Пример: 
						value="{{ old('name') }}"

				1-й способ вывода (частных) ошибок валидации
				error() - директива вывода ошибки валидации у указанного поля. Аргумнет - поле формы. Тело директивы - сообщение, выводимое при провали валидации поля.
					TODO ЗАМЕТКА: Нижже каждого поля прописывается дерективу @error(''), аргументом которой является имя проверяемого поля. Деректива отобразит ошибку, ес	
					Пример: 
						@error('email')
							<p class="test-red-500">{{ $message }}</p>
						@enderror

				2-й способ вывода (всех) ошибок валидации
				Пример:
					@if ($errors->any())
						<h3>Ошибки при заполнении формы:</h3>
						<div>
							@foreach ($errors->all() as $message)
								<p>{{$message}}</p>
							@endforeach
						</div>
					@endif
					где,
						$errors->any() - проверка на наличие ошибок
						$errors->all() - массив с сообщениями всех ошибок

				Локализация ошибок
					По-умолчанию ошибки выводятся на английском. За это отвечает файл "lang\en\validation.php"
					Файл представляет из седя набор свойств (ошибок) и значений - локализаций/переводом. 
						Пример: 'email' => 'The :attribute must be a valid email address.',
					TODO ЗАМЕТКА: Для создания русской локализации ошибок достаточно создать клонировать папку "en", переименовать ее на "ru" и перевести все ошибки. 
					
					Для переименования полей в локализации ошибок - достаточно в объекте "attributes" создать запись: 
						ключ + значения, где ключ - старое назание, значение - новое название.
						Пример:	
							'attributes' => [
								'name' => 'имя',
							],

					Для переименования правила проверки в локализации для определенного поля - достаточно в объекте "custom" создать объект с названием проверяемого поля и создать в ней запись: 
						ключ + значения, где ключ + правило проверки, а ключ - старое назание, значение - сообщение, отображаемое в случаи не выполнения правила.
							Пример:	
								'custom' => [
									'name' => [ 
											'required' => 'Это очень важное поле, заполните его!'
									]
								],
					

		*/

	echo '<hr><hr><br><h3>Laravel - #21.1-2 - Класс запроса формы, Создание собственного правила валидации (День 21)</h3><hr><hr>' . "<br>";
		//!Урок 1: Класс запроса формы
		/*
			FormRequest (FR) - тип класса, проводящий валидацию формы.
			ВАЖНО! Для каждой создаваемой формы желательно создавать класс типа Form requests, чтобы ему делегировалась часть функционала с контроллера, связанный с валидацией, дополнения данных запросов, и.т. 
							
			В прошлом уроке данные из формы передавались в виде объекта класса Request.
			В текущем уроке данные из формы в виде объекта Request будет обрабатоваться классом Form requests. Это считается более правильным способом. 

			Команда создания класса проверки формы:
				php artisan make:request TestForm
					где,
						request - атребут, указывающий на проверку данных из формы
						CommentForm - название создаваемого класса
					Место созданного класса: "app\Http\Requests\TestForm.php"

				ПОДКЛЮЧЕНИЕ FR К ФОРМЕ
					1) Создаем маршрут:
						Route::post('/testform/sendbyrequest', [App\Http\Controllers\FormController::class, 'sendByRequest']);
						где,
							/testform/sendbyrequest - URL, указанынй в action формы

					2) Создаем метод в контроллере, передающий данные формы в FR:
						public function sendByRequest(TestForm $request){
							$validate = $request->validate();
							print_r($validate);
							return 'Форма проверена';
						}
						где,
							sendByRequest - функция, указанная в маршруте
							TestForm - класс - FR, в который передаются даныне из формы
							$request - объект с данными из формы
							$validate - массив с проверенными данными из формы

				СПОСОБЫ ИЗВЧЛЕЧЕНИЯ ДАННЫХ 
					Даныне формы извлекаются двумя методами:
						1) ->validate - меотд, обрамляющий провреенные даныне формы в массив.
							Пример:
								echo $validate['name'];
						2) ->safe - метод, обрамляющий провреенные даныне формы в объект. 
							Пример:
								echo $validate->name;
							В случаи провала валидации меотд safe() так же возвратщает обратно на страницу с формой. 

				МЕТОДЫ класса FR:
					1) authorize()	- проверка авторизации пользователя и докуск до формы только авторизованных, конкретных пользователей. Возвратщает булево значнеие.     
					Пример:
						public function authorize(): bool
						{
							return true;
						}
					2) rules()			- метод с массивом правил валидации формы, как в методе "validate()". Валидация проходит еще в момент инъекции в метод контроллера. 
					Пример:
						public function rules(): array
						{
							return [
								'name' => 'required|min:2|max:20',
								'text' => 'required|max:100',
								'text' => ['required', 'max:100'],
								'bd' => 'nullable|date',
							];
						}
						TODO ЗАМЕТКА: правила валидации можно прописывать как в строке => 'bd' => 'nullable|date',, так и в массиве => 'text' => ['required', 'max:100'].

					prepareForValidation	- выполняетя перед передачей запроса на проверку валидации. 
						Это нужно, чтобы при добавлении в запрос ID авторизоаванного пользователя, не пришлось делать через скрытое поле в форме. 
				

					ОПЦИОНАЛЬНЫЕ ПОЛЯ КЛАССА ПРОВЕРКИ ФОРМЫ	
						Настройка редиректа валидации
							TODO ЗАМЕТКА: метод validate() автоматом редиректил пользователя на форму после ее проверки. В классе FormRequest редирект настраиваемый на любой URL. За это товечает поле "redirect". Если же в маршрутах используются имена, то для них используется свойство "redirectRoute".
							1) За правило редиректа в классе отвевает поле "redirect".
								Пример: 
									protected $redirect = '/';
							2) За правило редиректа в классе отвевает поле "redirectRoute".
								Пример: 
								protected $redirectRoute = 'nameRoute';

						Параметр остановки валидации при первой ошибке
							3) protected $stopOnFirstFailure = true;


					ОПЦИОНАЛЬНЫЕ ФУНКЦИИ КЛАССА ПРОВЕРКИ ФОРМЫ	
						1) messages() - функция возвратщающая массив с переопределенными сообщениями об ошибках заполенния привязанной формы. 
							Пример:
								public function messages()
								{
									return [
										'name.required' => 'Поле :attribute обязательно для заполнения!',
										'name.min' => 'Такого имени не может существовать',
									];
								}
								где,
									name - название проверяемого поля
									min - параметр проверки поля
									:attribute - ссылка на название поля
							TODO ЗАМЕТКА: сообщения валидации прописываются и в файле локализации, но сообщения в методе привязаны конкретно к ошибкам определенной формы. Сообщения об ошибках, прописанные в методе имеют приоритет перед сообщениями в файле локализации (объект "custom") в случаи совпадения имен полей и параметров проверки. Это может пригодиться, когда поля разных форм часто совпадают, но различаются по сожержанию.
								
						2) attributes() - функция возвратщающая массив с переименованными полями формы, помещенными в сообщение об ошибке.
							Пример:
								public function attributes()
								{
									return [
										'name' => 'имя',
										'bd' => 'дата рождения',
									];
								}	
		*/

		//!Урок 2: Создание собственного правила валидации
		/*
			В Laravel уже имеется множество правил валидации, в нем есть возможность создавать свои правила.
			Используется это редко, но это есть. а 
			Команда создания файла с кастомными правилами валидации:
				php artisan make:rule MyRule
			Место хранения самодельных правил валидации: 
				"app\Rules\MyRule.php".

			TODO ВАЖНО! Данный урок актуален только для Laravel 8-й версии, так как указанные в уроке методы класса находятся только в ней. Так что урок на практике не пройден в виду наличия только 10-й версии фреймворка. 
			
			Методы класса с самодельными правилами валидации:
				1) passes() - проверяет полученное значение от формы на соответствие.
				2) message() - возвратщает сообщение об ошибке в случаи провала валидации.
					public function message(){
						return 'Это значение должно ровняться';
					}
					
			Чтобы прописанное правило в классе rule заработало - его нужно подключить к FormRequest классу, который вмещает в себя правила проверки полей формы. 
				Пример:	
					'test' => [new MyRule, required];
					где,
						test - название проверяемого поля
						new MyRule - класс с самописными правилами валидации
				TODO ВАЖНО! Самописные правила прилагаются к проверяемому полю, только если правила перечисляются в массиве.
			
			Вынесение самописных правил валидации в файл локализации
				1) Сначала нужно прописать новый параметр и текст ошибки в нужной локализации
				Пример:
					'myrule' => 'Значение поля :attribute не прошло проверку'
				2) Затем подключить этот параметр в файл самописной валидации "MyRule".
				Пример:
					return trans('validation.myrule');
		*/

	echo '<hr><hr><br><h3>Laravel - #22.1-1 - Взаимодействие с моделями через формы (День 22)</h3><hr><hr>' . "<br>";
		//!Урок 1: Взаимодействие с моделями через формы
		/*
			Это урок применения на практики знаний работы с валидацией формы. 
			Доработаем контроллер "AddressController" обработки данных формы, прописав функционал добавления создание и т.д. данных формы. 
			Формы на изменение и добалвение будут иметь минимальные различия. Каждая из форм будет вести на свой метод контроллера со своим отдельным валидатором. 
			После создания формы (она будет заплняться в зависимости от вызввавшего ее метода) создадим два валидатора. 
				TODO ЗАМЕТКА: два валидатора могет понадобиться, если к одному и тому же полю могут потребоваться разные правила проверки формы. 
				TODO ЗАМЕТКА: правило "unique:" - это важное правило валидации, допускающее значения поля таблицы до записи в БД, только если оно отсутстввуте в указанно таблице. Т.е. уникально. + Если бы название поля формы и таблицы различались бы, то правило "unique:" имело бы второй аргумент (через ","), с названием поля в таблице, в котором значение поля формы не должно повторяться. 
					Прмиер:	
						'address' => 'required|min:10|max:255|unique:addresses',
						где,
							address - поле формы
							unique - правило валидации
							:addresses - таблица, проверяемая на наличие значения из формы
							
			В контроллере пропишем вызов валидации:
			Создание адресов:
				public function store(StoreAddressRequest $request)
				{
					$validated = $request->safe(); преобразование validated в объект с полями из формы
					$address = new Address(); вызов объекта класса для вызова поля таблицы
					$address->address = $validated->address; помещение в поле таблицы проверенное поле формы
					$address->save(); сохранение результата
					return redirect()->route('addresses.index'); редирект
				}
			
			Редактирование адресов:
				public function update(UpdateAddressRequest $request, Address $address)
				{
					$validated = $request->safe();
					$address->address = $validated->address;
					$address->save();
					return redirect()->route('addresses.index');
				}

				TODO ЗАМЕТКА: так как было создано два отдельынй класса проверки формы для добавления значений и редактирования, то это позволило создать разные правила для каждой отдельной формы. Если бы при редактировании формы оставалось правило "unique:addresses", то это было бы ошибкой, если содержимое не поменяло бы, то пользователь не мог бы сохранить старое значение поля. 

			Удаление адресов
				Удаление производится через отправку HTTP метдоа "delete". Т.е. для этого понадобится отдельная форма с кнопкой. 
					public function destroy(Address $address)
					{
						$address->delete();
						return redirect()->route('addresses.index');
					}
					TODO ЗАМЕТКА: метод delete() подразумевает в себе метод save(), поэтому после удаления - результат сохраняется.
		*/

	echo '<hr><hr><br><h3>Laravel - #23.1-1 - Взаимодействие с файлами и их загрузка (День 23)</h3><hr><hr>' . "<br>";
		//!Урок 1: Взаимодействие с файлами и их загрузка
		/*
			В ходе урока разберемся как передавать файлы через форму и обрабатывать их.

			РАБОТА ФАЙЛОВОЙ СИСТЕМЫ 
				Настройкаи работы файловой системы Laravel находятся в файле "config\filesystems.php". 
				Настройки конфига файловой системы:
					1) 'default' => env('FILESYSTEM_DISK', 'local'),
						default - использует диск файловой системы, который используется по-умолчанию.
					2) "disks" - диски, используемые в laravel: "local", "public", "s3". 
						TODO ЗАМЕТКА: "disks" - способ хранения файлов. 
						2.1) local 
							2.1.1) driver - драйвер, указывающий место хранения файлов (локальный сервер или публичный).
							2.1.2) root - адрес хранения файлов
						2.2) public 
							2.2.1) url - ссылка на папку с файлами
							2.2.2) visibility - доствпно для открытия любому пользователю 
						2.3) s3 
							2.3.1) - 'driver' => 's3' - Amazon'овский вариант хранения файлов. + в том, что размер хранения такого способа неограничен, но это платно. 
					
					3) links' - символическая ссылка
						3.1) - public_path('avatars') - фейлокая ссылка, доступная пользователю, ведущая к файлам
						3.2) - storage_path('app/public/avatars') - действительная ссылка
					Это ссылки, которые доступны пользователю, однако, ведущие к другой папке с файлами. 
						TODO ЗАМЕТКА: Файлы, передаваемые через форму помещаюстя в папку "strage". Полизователю доступна только папка "public". Символичные ссылки перенаправляют на папку "storage". Можно создавать множество символичных ссылок. 
						TODO ВАЖНО!: по-умолчанию символические ссылки недоступны - посли их объявления их нужно подключить чреез комнаду: "php artisan storage:link".

			ФАССАД STARAGE::
				Для работы с файловым хранилищем нам понадибится фассад "Storage::". 
				Создадим новый маршрут. Через который будем обращатсья к нему.
				
				Методы фассада Starage
					1) put() - метод добавления файла. 1-й аругмент: название закачиваемого файла, 2-й аргумент: содержание файала.
						Пример:
							Storage::put('1.txt', 'Text...'); 
								ИЛИ
							Storage::disk('local')->put('1.txt', 'Text...'); без указания диска метод по-умолчанию подключает локальный диск
					TODO ЗАМЕТКА:	Файл появится в папке "storage\app\1.txt", так как она прописана в диске по-умолчанию, а символическая ссылка не перекрывает этот адрес.
					2) disk() - метод, указывающий на диск дбавления файла. Аргументом выствпает название диска. Скачиваемый файл можно поместить на множество дисков. 
						Пример:
							Storage::disk('public')->put('1.txt', 'Text...');
							Storage::disk('local')->put('1.txt', 'Text...');
					3) prepend() - метод добвляет в начало файла сожержимое 2-го аргумента. 1-й аргумент это название файла, с которым взаимодействует метод.
						Пример:
							Storage::disk('local')->prepend('1.txt', 'Begin');
					4) append() - метод добвляет в конец файла сожержимое 2-го аргумента. 1-й аргумент это название файла, с которым взаимодействует метод.
						Пример:
								Storage::disk('local')->append('1.txt', 'End');
								TODO ЗАМЕТКА: добавление в файл происходит без необходимости указывать перенос строки. Он вшит в метод.
					5) delete() - метод удаления файла. Может применяться без опасения ошибки, и в случаи отсутствия удаляемого файла. Аргумент: название удаляемого файла.
						Пример:
							Storage::disk('local')->delete('2.txt');
					6) copy() - метод копирования файла. 1-й аругмнет: название копируемого файла, 2-й аргумент: название скопированного файла.
						Пример:
							Storage::disk('local')->copy('1.txt', '2.txt');
					7) get() - метод чтения файла. Аргументом является название файла.  
						Пример:
							echo Storage::disk('local')->get('1.txt');
					8) url() - метод отображения URL файла. Аругментом выступает названеи файла. 
						Пример:
							echo Storage::url('1.txt').'<br>';
						TODO ЗАМЕТКА: ссылка имеет вид в зависимости от диска с которым она создавалась. Локальная - внутренний путь. Публичкая - публичная ссылка.
						Пример:
							Публичная ссылка на картинку: Storage::disk('public')->url($path)	=> http://localhost/storage/images/4vCA0Yk1tsq643IfWpCGlwrClUoM3kZ47po7GPu1.jpg 
							Локальная ссылка на картинку: Storage::url($path)	=> /storage/images/4vCA0Yk1tsq643IfWpCGlwrClUoM3kZ47po7GPu1.jpg
					
					9) putFile() - метод сохранения файла из формы в дерикторию.
						Пример:
							$path = Storage::disk('public')->putFile('images', $request->file('image'));
							где,
								public - драйвер
								images - директория, в которую сохраняется файл
								$request->file('image') - поле формы, которое вмещает сохраняемый файл
						TODO ЗАМЕТКА: данная заметка возвратщает путь до файла. 

						TODO ВАЖНО!  Файл доступен для пользователя и доступен в адрессной строке только через добавление с помощью диска "public" => disk('public'). 
						Если добавить 

					10) putFileAs() - метод сохранения файла из формы в дерикторию с возможностью задавать имя файлу.
						Пример:
							$path = Storage::disk('public')->putFileAs('images', $request->file('image'), 'fileName.png');
								TODO ЗАМЕТКА: данный метод сохранения используется, когда имя все же имеет генерируемую часть названия. Иначе оно перетерается.  

			ФОРМА ПЕРЕДАЧИ ФАЙЛА 
				В аттребуте "action" впишем => {{url()->current()}} - эта запись означает, что форма будет ссылаться на саму себя. 
					Хотя отсутствие адеса онзаначет тоже самое.
				В аттребуте "enctype" впишем => "multipart/form-data". 

				TODO ЗАМЕТКА: Laravel отслеживает даже замаскированные типы данных. Такеи как скрипты, замаскированные под картинки. 
				Методы работы с файлом из формы:				
					1) file() - метод указывает метод, с которым будут работать другие методы. Аргументом выступает название файла. 
						Прирмер:
							
					2) getClientOriginalName() - имя орегинального файла
						Прирмер:
							echo $request->file('image')->getClientOriginalName().'<br>';
					3) >getClientOriginalExtension() - вывод расширения файла
						Прирмер:
							echo $request->file('image')->getClientOriginalExtension().'<br>';
					4) extension() - расширение, определенное Laravel'ем (действительное)
						Прирмер:
							echo $request->file('image')->extension().'<br>';
					5) getSize() - вывод размера файла
						Прирмер:
							echo $request->file('image')->getSize().'<br>';
					6) getMimeType() - вывод типа файла
						Прирмер:
							echo $request->file('image')->getMimeType().'<br>';
					7) getHash() - вывод типа файла
						Прирмер:
							echo $request->file('image')->getHash().'<br>';

					После валидации файла сохраним его:
						$path = Storage::putFile('images', $request->file('image'));
		
				Пример кода добавления из другого курса:
						if ($request->hasFile('main_image')) {
							$file = $request->file('main_image')->getClientOriginalName();
							$image_name_without_ext = pathinfo($file, PATHINFO_FILENAME);
							$ext = $request->file('main_image')->getClientOriginalExtension();
							$image_name = $image_name_without_ext."_".time().".".$ext;
							$request->file('main_image')->storeAs('public/img/articles', $image_name);
						}else{
							$image_name = 'noimage.jpg';
						}
					где,
						$request	- даныне получаемые пользователем
						hasFile	- метод проверки поля на наличие файла
						file('')	- метод принимающий из переменной $request (смотреть выше) файл. В методе указывается поле формы из которой принимается файл.
						getClientOriginalName	- метод отображения полного имени файла
						$image_name_without_ext	- переменная, хранящая в себе название изображения
						pathinfo	- метод, получающий путь к файлу, обрезая формат файла
						($file, PATHINFO_FILENAME) - $file - название файла, PATHINFO_FILENAME - условие обрезания названия файла (все кроме имени файла).
						$ext		- переменная, хранящая в себе формат изображения
						getClientOriginalExtension	- метод обрезающий название файла до формата формата. 
						$image_name	- переменная хранящая в себе измененное-уникальное название файла форматом
						$request->file('main_image')->storeAs('public/img/articles', $image_name); - строка сохранения/загрузки файла
						storeAs	- метод загрузки файла 
						public/img/articles				- путь загрузки файла
						$image_name							- имя файла, под которым он загружается на сервер
						$image_name = 'noimage.jpg';	- в случаи если фото не прикреплено, прикрепляется картинка по-умолчанию. Оно будет добавлено позже. 
				*/

		
	echo '<hr><hr><br><h2>Модуль №24.24-27:  Регистрация и авторизация пользователей</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #24.1-2 - Установка Laravel Breeze, Регистрация пользователей (День 24)</h3><hr><hr>' . "<br>";
		//!Урок 1: Установка Laravel Breeze
		/*
			В ходе урока установим библиотку "Breeze". Она нужна для авторизации/регистрации пользователй. Это более безопасный вариант, когда авторизация пишется с нуля.
			Это сложная задача, которая в бОльшей части решает данная библиотека.
			Команда подключения библиотеки:
				composer require laravel/breeze --dev
			Команда запуска библиотеки:
				php artisan breeze:install
				Далее в ходе установки будут предлагаться разные настройки - согашаемся на только на blade.
			TODO ВАЖНО! Установка библиотеки "Breeze" перетирает существующий файл "web.php"/папку "routes" на прилагаемый из коробки библиотеки.
			TODO ЗАМЕТКА: Breeze позволяет из коробки создать каркас вашего приложения с помощью Vue или React и инерции - одностраничные приложения без создания API.
			TODO ЗАМЕТКА: Стек "Breeze" по умолчанию - это стек Blade, который использует простые шаблоны Blade для визуализации интерфейса вашего приложения.
			TODO ЗАМЕТКА: Установка библиотеки "Breeze" вместе с собой подразумевает установку CSS фреймворка "Tailwind", задающий стиль шаблонам.
			
			Наполним БД фейковыми данными и переходим к следующему уроку:
				1) Перепишем ссылку проекта в "env": APP_URL=http://127.0.0.1:8000
				2) Создадим новыую БД: laravel_Rusakov_2
				3) Создаем сидер: php artisan make:seeder UserSeeder
				4) Записываем в нем: User::factory()->count(10)->create();
				5) Миграция: php artisan migrate:fresh --seed
				6) Меняем локализацию для фейковых данных в "24-40\config\app.php": 'faker_locale' => 'ru_RU'
				7) В фабрике: $this->call([UserSeeder::class,]);

			В подключенной библиотеке имеются свои маршруты, контроллеры , шаблоны.
			Дитали работы библиотеки будем разобраны в рамках проходимого раздела.
		*/

		//!Урок 2: Регистрация пользователей
		/*
			В этом уроке не будем ничего писать, а просто ознакомимся с компанентами, кодом, в целом как происходит регистрация пользователя в библиотекее "Breeze".

			Файл routes\auth.php: 
				Route::middleware('guest')->group(function () {
					Route::get('register', [RegisteredUserController::class, 'create'])->name('register');
				где,	
					middleware('guest') - посредник, запускающий редирект для авторзованных пользователей

			Шаблон resources\views\auth\register.blade.php вмешает в себе компанент => resources\views\layouts\guest.blade.php
				Этот компанент - шаблон для неавторизованных пользователей. 
					{{ $slot }} - метка в шаблоне для гостей, в которую вставляется слот из шаблона "resources\views\auth\register.blade.php"

			Файл "\lang\en.json"
				Имеет набор атребутов, переводимый в локализации. Компаненты имеют ссылки на названия этих атребутов и переводятся в зависимо от локализации. 
					TODO ЗАМЕТКА: файл "en.json" вмеащет себя атребут и их перевод в зависимости от локализации. Ссылка на атребут в коде: __('Name').

			event(new Registered($user)); - событие уведомляющее о том, что но пользователь зарегистрирован. События еще будем разбирать. 

			return redirect(RouteServiceProvider::HOME); - редирект на страницу => public const HOME = '/dashboard';

		*/

	echo '<hr><hr><br><h3>Laravel - #25.1-2 - Подтверждение e-mail, Авторизация пользователей (День 25)</h3><hr><hr>' . "<br>";
		//!Урок 1: Подтверждение e-mail
		/*
			В этом уроке не будем практически ничего писать, но добавим в систему регистрации необходимость подтвержение e-mail'а. 
			
			НАСТРОЙКА SMTP сервера
				Так как мы пользуем локальынй сервер, то SMTP сервера у нас нет - пропишем адрес отправки собщения в лог-файл. 
					1) Настрока в файле .env: 
						а) MAIL_MAILER=smtp => MAIL_MAILER=log
						б) MAIL_FROM_ADDRESS="hello@example.com"
						Схема отправки писем еще будет изучаться, но пока достаточно и этого. 
						а) Запись 
						б) Получатель 
					2) Настройка модели пользователя:
						Имплементируем интерефейс/контракт к моделе и подключем его:
							implements MustVerifyEmail
					3) Добавление посредника/midllwar'а в маршруты, проверяющий подтверждение почты:
							Route::middleware(['auth', 'verified'])->group(function () { ... } .
							Это Laravel'ский посредник - его использовение не требует наличия библиотеки. 

				КОНТРОЛЛЕРЫ БИБЛИОТЕКИ ОТВЕЧАЮЩИЕ ЗА ПРОВЕРКУ ПОЧТЫ
					1) EmailVerificationPromptController - проверяет верификацию почты и выдает нужный шаблон
							redirect()->intended(RouteServiceProvider::HOME)
							Метод "intended" означаент, что пользователь редиректится на страницу HOME, если до редиректа у него не было прав на желаемую страницу. 
							Если права на желаемую страницу были, то редиректится туда откуда турнули.
					2) EmailVerificationNotificationController - передает нужный шаблон в случаи прохода и не прохода проверки верификации почты. 
						В случаи не прохода верификации возвратщает обратно с переменной, помещенной в сессию: return back()->with('status', 'verification-link-sent');
					3) VerifyEmailController - 
						->middleware(['signed', 'throttle:6,1']) - требование подписи запроса + разрешение делать запрос 6 раз в минуту

				ИТОГО:
					ШАГИ ВЕРИФИКАЦИИ EMAIL
						1) Адрес записи сообщения в лог и отправка на указанную почту:
							Настрока в файле .env: 
								а) MAIL_MAILER=smtp => MAIL_MAILER=log
								б) MAIL_FROM_ADDRESS="hello@example.com"
						2) Подключение интерфейса "implements MustVerifyEmail" в модель User
						3) В случаи необходимости добавляем посредники проверки подтвержденной почты "verified" в маршруты. 
						4) Контроллеры:
							а) EmailVerificationPromptController - редиректит на шаблон в случаи отсутствия подтвержденного email
							б) EmailVerificationNotificationController - отправка формы подтверждения почты
							а) VerifyEmailController - проверка и верификация email
		*/

		//!Урок 2: Авторизация пользователей
		/*
			Познакомимся с механизмом авторизации билбиотеки "Breeze".

			Маршрут /login => AuthenticatedSessionController - отвечает за обработку запросов авторизации
			TODO ЗАМЕТКА: для авторизации понадобится почта, сегенерированная фабрикой + пароль, указанный в фабрике UserFactory. Пароль => "password". 

			При авторизации нас прекидывает в метод "store", у которого проввряются данные авторизации классом "Http\Requests\Auth\LoginRequest.php".
				В методе "authenticate" прописан функционал проверки колличества попыток входа, временная блокировка и вызов события в случаи превышения лимита.
				Его вызов в контроллере: $request->authenticate();
				Метод обновления сессии во избежания внемения в нее данных из вне во время авторизации: $request->session()->regenerate();
		*/

	echo '<hr><hr><br><h3>Laravel - #26.1-3 - Подтверждение пароля, Выход из системы, Восстановление пароля (День 26)</h3><hr><hr>' . "<br>";
		//!Урок 1: Подтверждение пароля
		/*
			Функциона подтверждения пароля в Laravel реализован за счет посредиков + шаблонов, предоставляемых библиотекой "Breeze".
			Создадим контроллер, выводящий запись, требующий авторизации и подтверждения пароля за счет посредника:
				Route::get('', function(){
					return 'send payment';
				})->middleware('password.confirm');
				где,
					password.confirm - посредник, подразумевающий авторизацию и требующий дальнейшего подтверждения пароля

				Сам посредник относится к Laravel.
				Однако в данном кейсе не обошлось без бриза: форма, кнопки, шаблон, выыводимые при проверки пароля - это производная библиотеки. 
				Библиотека реагирует на посредник "password.confirm" и выводит форму проверки пароля "confirm-password".
				Контроллер формы проверяет пароль авторизованного пользователя и допускает при совпадении пароля, записывая данные авторзации в сессию.
		*/

		//!Урок 2: Выход из системы
		/*
			Функционал выходы из учетки релизуется через передачу POST запроса из компанентов:
				dashboard.blade.php => layouts\app.blade.php => layouts\navigation.blade.php => views\components\dropdown.blade.php, где ссылка отправляющая форму. 
				Пример отправки запроса на выход из учетки с помощью JS без необходимости клемания формы под одну кнопку:
					Без JS требовалось бы записать форму (DELETE) в форме (POST), но теперь достаточно и одной. 
					<!-- Authentication -->
						<form method="POST" action="{{ route('logout') }}">
							@csrf
							<x-dropdown-link :href="route('logout')"
								onclick="event.preventDefault();
								this.closest('form').submit();">
								{{ __('Log Out') }}
							</x-dropdown-link>
						</form>
						
			Запрос на удаление далее обрабатывается в контролере: AuthenticatedSessionController => destroy(). 
			В этом методе используется "охранник" (guard()). 

			В методе destroy:
				Auth::guard('web')->logout(); - удаление авторизованного пользователя
				$request->session()->invalidate(); - сбросс сессии
				$request->session()->regenerateToken(); - перезапуск сессии
				return redirect('/'); - редирект

			ГАРДЫ 
			Гарды - это механизм, позволяющие разграничивать использование функционала приложения пользователями.
				По-умолчанию в приложении используется гарда "web".
				Гарды подразумевают под собой свод настроек взаимодействия с типами пользователей. 
				Гарды нужны например для того, чтобы мы могли раздилять сессии по типам пользователей. Например на авторизованных пользователей сайта и админов. 
				TODO ЗАМЕТКА: автор курса считает, что они чаще избыточны, так как можно обойтись и другими методами, однако guard() в Laravel есть. 
					Пример реализации гард:
						@auth("web")
							<a href="{{ route("logout") }}" class="text-md no-underline text-grey-darker hover:text-blue-dark ml-2 px-1">Выйти</a>
						@endauth
						Или для авторзованных пользователей относящийся к гарде "web". 
						
				Гарды ааходятся в файле "config\auth.php". На дынный момент имеется только гарда "web". 
		
				Гаады состаят из драйверов и провайдеров.
				Пример: 
					'guards' => [
					'web' => [
						'driver' => 'session',
						'provider' => 'users',
					],

			ДРАЙВЕРЫ
				Драйверы есть двух типов: session и token. Второй используется с API. Сессии находятся в папке "\storage\framework\cache\sessions".
					В файле "app\Providers\AuthServiceProvider.php" расширяется и настраивается авторизация. В нем добавляются новые драйверы. 
					Здесь можно прописывать правила доспупы для разных ролей авторизованных админов. 
				
			ПРОВАЙДЕР
				Провайдер - это правило дающее авторизации понять каким образом пользователи будет получать объекты. Их тоже два: "database", "eloquent".
				Eloquent подразумевает, что за передачу данных пользователю будет отвечать модель - метод вшитый в Lravel. А "database" подразумевает обращение к БД напрямую через метод. 
				Если создается новая гарда - к ней создается новый провайдер. 
				Провайдеры находятся в папке "app\Providers\AuthServiceProvider.php".
					Пример указания правила получения данных пользоваетелем:
						'users' => [
							'driver' => 'eloquent',
							'model' => App\Models\User::class,
						],
						model - указывает модель, которая присоедина к гарде
			*/

		//!Урок 3: Восстановление пароля
		/*
			Последнее, что осталось разобрать в системе регистрации/авторизации + библиотеки "Breeze" - восстановление пароля. 
			Данные формы восстанвленяи пароля (почта) отправляются в контроллер обрабатываются и новый пароль отправляется на почту.

			Вид изнутри => PasswordResetLinkController.
				Контроллер PasswordResetLinkController:
					1) выводит форму восстановления пароля
					2) проверка входных данных: почта
					3) отправка сгенерированного пароля на почту
					4) вывод информации о событии в формате сессии в случаи успешного или безуспешного ввода нового пароля
				
				Контроллер NewPasswordController:
					1) проверка отправленного пароля и токена
					2) утверждение нового пароля в случаи совпадения
					3) вызов сброса пароля
					4) создание события о ноовом пароле
					5) вывод информации о событии в формате сессии в случаи успешного или безуспешного ввода нового пароля
				
				В файле "storage\logs\laravel.log" прописана ссылка с токеном на форму смены пароля. 

				Функционал библиотеки является минимальным для авторизации на сайте. 
				Однако, автор им не пользуется, так как пишит авторизацию без избыточного создания контроллеров и компанентов. 
				
		*/

	echo '<hr><hr><br><h3>Laravel - #27.1-1 - Политики и права доступа (День 27)</h3><hr><hr>' . "<br>";
		//!Урок 1: Политики и права доступа
		/*
			СПОСОБЫ РАЗГРАНИЧЕНИЯ ПРАВ ДОСТУПА ПОЛЬЗОВАТЕЛЕЙ:
				1. Посредники:
					Route::get('/profile', function(){
						return 'profile';
					})->middleware('auth.basic');
					TODO ЗАМЕТКА: auth.basic - это допуск до страницы после авторизации, но без самописной формы и страницы входа. 

				2. Gates (ворота). Его мы не будем рассматривать в ходе курса. 
						Gates - простой вариант ограничения и подходит для понятия основ авторизации. Его используют, когда нужно поставить ограничение на один/два метода.
						Gates имет два состояния - закрыты или открыты по указанным условиям. 
				
				3. Политики: Политика в отличии от гейта привязывается не к одной способности (ability), а к группу мтеодов опереленной модели. 
						Политика работает при использовании способов передачи данных пользователю через 'driver' => 'eloquent'. 

			СОЗДАНИЕ ПОЛИТИКИ			
				ПРАВА - это мтеоды и прописанные в политике.
				Команда создания политики:
					php artisan make:policy AddressPolicy --model=Address 
					где,
						make:policy 	- создание политики
						PostPolicy	- название политики
						--model=Post 	- название модели к которой будет относиться политика
					Политика появляется в дериктории "app\Policies\AddressPolicy.php".
					TODO ЗАМЕТКА! Название политики должно начинаться с названия модели, к которой прикрепляется политика и заканчиваться словом Policy.
					
					После создания политики - она регистриуется в "app\Providers\AuthServiceProvider.php" в массиве "$policies" через указания сявзи модели и политики.
					Пример: 
						protected $policies = [
							'App\Models\Model' => 'App\Policies\ModelPolicy',
							Post::class => PostPolicy::class
						];
					ВАЖНО! В Laravel от 7-й версии есть AutoDiscovery. Это значит, что если политике дать название начиная с названия модели, то Laravel сам увидет эту связи и указывать ее в "AuthServiceProvider.php" не придется. Но это допустимо если соотношение названии модели и политики будет как на примере: Post => PostPolicy. Если такого соответствия нет, то связь модели и политики прилется указывать в "app\Providers\AuthServiceProvider.php".
				
				Добавление модели ее изменения:
					Для работы с политикой скопируем модель, миграцию, сидер и фабрику из предыдущего проекта в текущий. 
						В миграции пропишем поле c пользователем: 
							$table->integer('user_id');
						В фабрике пропишем генирацию поля с пользователем: 
							'user_id' => mt_rand(1, 10)
						В моделе меняем связь клиента на юсера:
							public function user(){
								return $this->belongsTo(User::class);
							}
						В маршруты добавим ресурс: 
							Route::resource('/addresses', App\Http\Controllers\AddressController::class);
						Перенесем контроллер и шаблоны, связаныне с моделью. 
						В сидерах генерируются 10 записей - оставляем как есть. 

					Запустим миграцию: php artisan migrate:fresh --seed

				Разбор методов политики:
					1) viewAny() - определяет может ли просмотривать пользователь любую модель.
						return true;
					2) view() - может ли пользователь просмаривать конкретный адрес. 
						return $user->id === $address->user_id;
					3) create() - может ли пользователь создавать записи
						return in_array($user->id, [1, 2, 5, 12]);
							где,
								in_array - функция проверки значения в массиве
								$user->id - сверяемое значение 
								[1, 2, 5, 12] - массив
					4) update() - может ли пользователь обновлять записи
						return $user->id === $address->user_id; - запись значит, что можно обновлять свои адреса
					5) delete() - может ли пользователь удалять записи
						return false;
					6) rstore() - может ли пользователь восстанавливать записи
						return false;
					7) forceDelete() - может ли пользователь удалять полностью записи
						return false;

					TODO ЗАМЕТКА: методы прописанные в политике - являются правами.
					TODO ЗАМЕТКА: в видео указан трейт HandlesAuthorization, но в 10-й версии Laravel он не был установлен с поликой. 
						Он имеет два метода: 
							1-й генерирует ответ в разрешения доступа при обращении пользователя к методу. 
							2-й генерирует ответ о запрете доступа.
							Нам это не приодится. 
							
			ИСПОЛЬЗОВАНИЕ ПОЛИТИК:
				1-й способ: использование через посредники:
					Пример а):
						Route::get('/createaddress', function(){
							return 'создание нового адреса разрешено';
						})->middleware('can:create, App\Models\Address');
						где,
							can:create - посредник дающий разрешение на создание записи
							App\Models\Address - адрес модели к которой разрешен доступ по использованию указанного метода текущему пользователю
						TODO ВАЖНО! запись can:create указывает на метод политики, а не модели.
					Пример б):
						Route::get('/viewaddress/{address}', function(Address $address){
							return 'просмотр адреса доступен: '.$address->id;
						})->middleware('can:view,address'); //БЕЗ пробелов
						где,
							$address - просматриваемый адрес
							Address - модель дающая доступ к адресу
							can:view - посредник с проверкой доступа к методу

				2-й контроллеры:
					Пример а):
						public function index(Request $request)
						{
							if (!$request->user() || $request->user()->cannot('viewAny', Address::class)) {
								abort(403);
							}
							return view('addresses.index', ['addresses' => Address::all()]);
						}
						где,
							/!$request->user() - не авторизоапнный текущий пользователь
							cannot - меотд проверки на отсутствие прав к методу модели
							can - меотд проверки на наличия прав к методу модели
							viewAny - метод проверяемый на наличие отсутсивя права
							Address - модель в к котрой относится метод
							abort(403); - вывод ошибки 403
							return view('addresses.index', ['addresses' => Address::all()]); - вывод шаблона
					
					Пример б):
						$this->authorize('create', Address::class);
						$this->authorize('view', $address);
							Передача объекта класса как аргумент, так как метод политики требует аргумента в видеадреса
						где,
							authorize - метод проверки у пользователя дступа к методу модели
							create - политики, првоеряющий доступ пользователя
							$address/Address::class - параметр передаваемый в политику для проверки.
							TODO ВАЖНО! запись authorize('create'...) указывает на метод политики, а не модели.
							Проверяет доступ прав на создание записи - доступ может быть выдан в политикех модели.
					
					Пример в):
						TODO ВАЖНО!: Есть еще более удобный способ ограничения доступа через ресурсный контроллер, указав метод "authorizeResource".
						При наличии оного подобные конструкции не нужны: $this->authorize('view', $address);
							public function __construct()
							{
								$this->authorizeResource(Address::class, 'address');
							}
							где,
								authorizeResource - метод проверяющий CRUD методы на доступ к модели 
								address - название параметра,который будет отправляться в политику для проверки

					"authorizeresource" - это метод, добавляющий к роутам, связанным с ресурсом мидлвар.
					По добвлению метода "authorizeresource" в ресурс - можно увидеть у всех методов ресурса мидлвар "authorize", прописав команду: "php artisan route:list".
					TODO ЗАМЕТКА: При генрации ресурса в laravel - методы в нем создаются уже с инъекцией переменных "id" => edit($id).
						Чтобы authorizeresource заработал - нужно, чтобы при создании ресурса в команде artisan указывалась модель к которой он прявязан. 
						Либо вручную в ресурсе менять у всех методов правило аргументов/параметров, аргументы на бинды модели. 
				
				3-й шаблоны:
					Если политики ограничивают доступ к редактированию записи, то нет и смысла выводить URL редактирования. 
					Дополнительная работа по праввам должна производиться и в шаблонах blade.
					Нам понадобится шаблон "resources\views\addresses\index.blade.php". 

					TODO ЗАМЕТКА: для работы с правами доступа в Laravel имеется директива "@can()".
						Если права просмотра имеются - выводим ссылку, если же прав нет - выводим заглушку с оповещением о отсутствии прав:
						@can() - директива для работы с правами доступа. 1-й аргумент - название права (метод в политике), второй - передаваемые в шаблон данные.
						
						TODO ЗАМЕТКА: методы view/update - это методы указаныне именно в политиках - они указваются в директивах. В политиках можно создавать свои мтеоды.
						Пример ограничение вывода ссылки на показ записи:
							@can('view', $address)
								<a href="{{ route('addresses.show', ['address' => $address]) }}">{{$address->address}}</a>
							@else
								<span>Ссылка недоступна для просмотра</span>
							@endcan
					
						Пример ограничение обновления записи:
							@can('update', $address) 
								<a href="{{ route('addresses.edit', ['address' => $address]) }}">Редактировать</a> - 
							@else
								<span>редактирование недоступно</span>
							@endcan
					
						TODO ВАЖНО! Так как право "create()" не подразумевает принятия параметров кроме User->id, то вторым параметром передается модель, на основе которой будет создаваться новая запись.
						Пример ограничения создания записи:
							@can('create', App\Models\Address::class)
								<li><a href="{{ route('addresses.create') }}">Добавить еще адрес</a></li>
							@else
								<span>создание записей недоступно</span>
							@endcan
				
						TODO ВАЖНО! Несмотря, что на страницу "addresses" не имеет ограничений по правам => viewAny: return true; - страницы не доступна для не авторизованных пользователей. Все потому, что права в аргументе требуют авторизованного пользователя. Для того, чтобы страница отображалась и у неавторизованного пользователя - перед аругментом права ставится "?": запись означает, что аргумент не обязателен. 
							Пример:
								public function viewAny(?User $user): bool
								{
										return true;
								}


			СОЗДАНИЕ ПРАВ В ПОЛИТИКЕ
				Политики позволяют создавать в себе свои методы-права. 
				Пример:
					public function myPrava(User $user, int $n): bool
					{
						return $user->id === $n;
					}
				Реализация права в шаблоне:
					@can('myPrava', [App\Models\Address::class, 6])
						<span>Право "myPrava" успешно реализовано</span>
					@endcan
					Третий аргумент это аргумент добавленный в право.  
				
			НАСТРОЙКА ПОЛИТИКИ
				Настройка политики производится в файле: config\auth.php
				Суть заключается в настройка драйвером и провайдеров - смотреть урок #26.2: "Выход из системы".
		*/	

		
	echo '<hr><hr><br><h2>Модуль №28.28-31: Дополнительные возможности</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #28.1 - Отправка e-mail (День 28)</h3><hr><hr>' . "<br>";
		//!Урок 1: Отправка e-mail
		/*
			Продолжим работу в первом проекте, так как второй ориентирован на работу только с авторизацией. 
			В рамках нового модуля кодовая база не сильно выростит, однако, об этих разделах нужно знать. 

			Для разбора работы отправки почты ознакомимся с настройками: "\config\mail.php". 

			Способы отправки почтлвых сообщений (mailers):
				1) smtp		- использование SMTP сервере. Подходит при ограниченой отправки почты => т.к. скорость == ~ 1 сообщение/1 сек.
				2) ses		- amazon'овский метод. Оптимальный вариант за свою цену, при массовой отправки писем.
				3) mailgun	- не извезстный способ. Но цена вроде как гораздо больше чем у "ses".
				4) postmark	- не извезстный способ.
				5) sendmail	- способ, подазумевает отправку писем с своего сервера. Самый сложный, рискованный способ - так как требует настройки, но бесплатный и быстырй.
					TODO ЗАМЕТКА: настройка почтового сервера это сложная тема, достойная отдельного курса. При качественной настройке сервера метод "sendmail" примерно равен методу "ses". И то не во всех аспектах. Например некотрые почтовые клиенты не принимают почту от неправильно настроенного сервера даже в спам. 
				6) log		- вариант, подходящий для настройки и отладки функционала отправки почтовых сообщений.
				7) array		- способ, помещающий письма в массив вместо отправки. Подходит для дальнейшей обработки сообщения. Используется обычно после отправки письма. 
				8) failover	- список из ескольких способов отправки, выстроенный в порядке приоритетов, если прыдыдущий вариант не отправил сообщение. 

			От кого письмо (from):
				address - адрес отправителя (происывается в .env файле => "MAIL_FROM_ADDRESS").
				name - имя отправителя (происывается в .env файле => "MAIL_FROM_NAME" - по-умолчанию подтавляется название сайте => "${APP_NAME}").
				
			Создание шаблонов для писем:
				1) markdown - рамзетка создания шаблонов писем, из компанентов своих или гоотовых. 
				2) самописные шаблоны. 

			Для настройки отправки писем в с определенным шаблоном пропишем контроллекр, предварительно в файле .env, прописав оправку писем в log => MAIL_MAILER=log.

			СОЗДАНЕ ПИСЬМА
				Прежде чем отправить писмьмо - его нужно создать, и из контроллера вызвать фассад отправки писмьа. 
				Создадим класс для для отправки email уведомлений
					php artisan make:mail Hello
						Класс хранится по адресу: "app\Mail\Hello.php".	
					
					TODO ЗАМЕТКА: в 10-й версии Laravel метод "build()" отсутствует. Сейчас в 10-ке метды: envelope, content, attachments.
					По умолчанию в классе имеется два метода, где __construct - класс принимает данные, помещаемые в сообщение, а content - передача параметров email уведомлений.
						public function __construct(){
							$this->name = $name;
						}
					Например сюда могут помещаться имя зерегистрированного пользователя, которые передастся в шаблон письма.  

				Данные полученные классом передаются в шаблон заполнения данных "laravel\resources\views\emails\contact_form.blade.php". 
					Этот шаблон будет отправляться в виде письма - в нем находятся даныне из формы. 
					public function build(){
						Методы испольующиеся в методе "build()";
						$this->from('manager@example.com', 'Менеджер') - заменяет дефолтное занчение в файле .env
								->subject('Тема письма')
								->view('emails.messsage') - шаблон с разметкой HTML и текстом 
								->text('emails.hello_text') - письмо в виде текста (нужно для лучшей передачи письма, на случай не поддерживаемости HTML клиентом)
								->with(['a' => 10]); - дополнитльные передаваемые даныне
								Ппередача дополнительных заголовков в сообщение:
								$this->withSwiftMessage(function($message){
									$message->getHeaders()->addTextHeader(
										'My-Header', '123' 
									);
								});
						return $this; - возврат сообщения   
					} 
					withSwiftMessage()	- метод объявления заголовков
					$message	- собщение
					getHeaders()	- получение у сообщения заголовков
					addTextHeader()	- присвоение сообзению новых заголовков
					'My-Header', '123' - заголовк, значение

					TODO ПЕРЕДАЧА ПИСЬМА В НОВОЙ ВЕРСИИ:
						Тема письма и отправитель:
							use Illuminate\Mail\Mailables\Address;
							public function envelope(): Envelope
							{
								return new Envelope(
									
										from: new Address('admin@example.com', 'Менеджер'),
										subject: 'Тема письма',
								);
							}
						Подключение шаблона почты + передача текста + передача параметра:
							public function content(): Content
							{
								return new Content(
									view: 'emails.hello',
									text: 'emails.hello_text',
									with: [
										'a' => 10
									],
								);
							}
						Передача атберутов в письмо:
							public function attachments(): array
							{
								return ['a' => 10];
							}
						Подключене заголовков в письмао (не реализовано):
							public function headers(): Headers
								{
									return new Headers(
										messageId: 'custom-message-id@example.com',
										references: ['previous-message@example.com'],
										text: [
												'X-Custom-Header' => 'Custom Value',
										],
									);
								}
							
						
					TODO ВАЖНО! присвоение новых заголовков работало до 8-й версии Laravel. После используется метод "$this->withSymfonyMessage();", а не withSwiftMessage().
						Пример:
							$this->withSwiftMessage(function(Email $message){
								$message->getHeaders()->addTextHeader(
									'My-Header', '123' 
								);
							});

					TODO ЗАМЕТКА: дополнительные заголовки требуются при массовых рассылках (Precedence: bulk). Или некоторые почтовые сервисы присваивают заголовки сами.
					Еще заголовки являются средством сбора информации о прочитанных, открытых сообщениях. 

				Создаем шаблоны для письма:
					views\emails\hello.blade.php, views\emails\hello_text.blade.php: 
					Прмиер наполнения шаблонов:
						<div>
							<p>Здравствуйте, {{$name}}!</p>
							<p>Я рад вас приветствовать!</p>
							<p>Переменная a = {{ $a }}/</p>
						</div>
						Здравствуйте, {{$name}}!
						Я рад вас приветствовать!
						Переменная a = {{ $a }}

				ОТПРАВКА ПИСЬМА
					Когда шаблоны написаны и заполнены - через контроллер (метод 'testMail') обращаемся к фассаду "Mail::" для отправки письма. 
						public function testMail(){
							Mail::to('koliya@example.com')->send(new Hello('Николай'));
							return 'Проверка работы отправки письма';
						}
						где,
							to() - метод с почтой получателя
							send() - метод с аргументом - классом, в конструктор которого передается имя. 

				ОТПРАВКА ПАКЕТА ПИСЕМ 
					Отправка писем, обоченно черзе SMTP сервер - дело не быстрое.
					Для отправки группы писем в фассадe Mail лучше испольовать метод "qeue()".  
						Пример:
							Mail::to('koliya@example.com')->qeue(new Hello('Николай'));

						qeue() - метод, помещающий письма в очередь отправки. 

				ОЧЕРЕДИ
					Очереди - это функционал laravel, позволяющий невелировать время ожидания каких либо событий пользователем, помещая их выполнение в фоновый режим. 
					Они применяются буть то либо в отправке сообщений, либо в загрузки группы файлов пользователем.
					TODO ВАЖНО! Почта может отправляться некоторое время, поэтому при отправки почты лучше использовать "очереди" черзе запуск Cron скрипта, чтобы отправка письма прошла тогда, когда настала бы очередь отправки. Этот скипт выполняет запуск задач, помещенных в очереди => "php artisan qeue:work".

					TODO ЗАМЕТКА: функционал очередей в уроке не будет рассказан подробно и н будет реализован... напишу о очередях ниже. 
					ИНФОРМАЦИЯ ИЗ ДРУГОГО КУРСА
						1. Настройка очередей и типы очередей 
							Файл с конфигурацией очередей находится в "config\queue.php".
							В файле есть несколько типов очередей:
							sync, database, beanstalkd, sqs, redis.
								Рассмотрим только два типа:
									sync		- тип очереди выбранный по умолчанию. Задача в очереди начинает выполняться мгновенно, не влияя на скорость выполнения задачи. 
									database	- тип очереди, записывающий задачу в таблицу БД "jobs" - его и будем использовать. 
										Задачи записанные в таблицу начинают выполняться через воркер, т.е. задача записанная в очередь не начинает выполняться мгновенно, а по команде в фоновом режиме. 
						
						2. Создание таблицы, класса для записи очередей
							Для работы с очередями типа "database" - понадобиться создать таблицу "jobs" через миграцию, так  таблицы по умолчанию нет. 
								Команда создания миграции с таблицой:
									php artisan queue:table
								Команда выполнения миграции:
									php artisan migrate
								Команда создания класса, в который записываютяс задачи, кладущиеся в очередь:
									php artisan make:job ForgonUserEmailJob
										job - тип класса, записывающий задачу в очередь 
										ForgonUserEmailJob - название класса
											Появляется класс в папке "laravel\app\Jobs\ForgonUserEmailJob.php"
						
						3. Функционал класса записи очереди
							Функция "__construct" 	- принимает и присваивает данные, необходимые для задачи
							Функция "handle"			- выполняет задачу с значениями, полученными в "__construct"
								Пример записи отправки письма в очередь:
									private $user;
									private $password;
									public function __construct($user, $password){
										$this->user = $user;
										$this->password = $password;
									}
									public function handle(){
										Mail::to($this->user)->send(new ForgotPassword($this->password));
									}
								Пример вызова функционала занесения задачи в очедедь из контроллера 3-мя способами:
									1) dispatch(new ForgonUserEmailJob($user, $password));
									2) $this->dispatch(new ForgonUserEmailJob($user, $password));
									3) ForgonUserEmailJob::dispatch($user, $password);
														
						4. Настройка работы записи в очередь
							По-умолчанию сейчас стоит тип записи в очередь "sync", чтобы поменять его на "database" нужно:
								В файле ".env" поменять значение строки "QUEUE_CONNECTION" с "sync" на "database".
							
							При отправке сообщения пользователем задача попадает в таблицу "jobs" на оидание выполнения. 
								Для выполнения задачи, находящейся в ожидании прописывается воркер - кмоманда, запускающая выполнение задач в очереди. 
								После запуска команды воркер будет ождать поступления задачи до закрытия консоли. 
								Пример:
									php artisan queue:work 

							Для работы воркера на живом(нелакальном) сервере в laravel - используется "Supervison Configuration". Принцип работы тот же, но для хостинга. 

						5. Ошибка при выполнения задачи, находящейся в очереди. 
							Если задача, напимер прописана с ошибкой в классе "ForgonUserEmailJob" - то задача при вызове воркера перезаписывается из таблицы "jobs" в другую таблицу "failed_jobs".
							Таблицы "failed_jobs" в отличии от "jobs" находится в БД по умолчанию вне зависимости от создания таблицы "jobs". В "failed_jobs" прописывается ошибка выполнения задачи.

							Конманда отображения зафейленных задач:
								php artisan queue:failed
									Команда отображеет ID задачи, тип очереди, класс поставивший задачу в очередь, время записи задачи в таблицу "failed_jobs". 
							
							Команда выполнения зафейленных задач:
								php artisan queue:retry all
									all - выполнение проверки всех зафейлиных задач. Здесь можно записать ID конкретной задачи. 
										Команда проверяет задачу и перевод ее из таблицы "failed_jobs" в таблицу "jobs". 
										Далее задача выполняется воркером либо его запуском, если проект не на хостинге и если ошибка исправлена. 
		*/

	echo '<hr><hr><br><h3>Laravel - #29.1-2 - Отправка уведомлений, События (День 29)</h3><hr><hr>' . "<br>";
		//!Урок 1: Отправка уведомлений
		/*
			Отправка уведоблений чем то пожоже на отправку email, но отлиичия есть:
				1) Уведомления отправляютяс по разным каналам ... например в соц.сеть или по SMS, когда как email только на почтовый клиент. Хотя под уведомление по-умолчанию подразумевается уведомление на email, хотя каналов уведомлений множество. 
				Размерем классический вариант уведомлений - череp email. 

				Команда создания класса для отправки уведомлений:
					php artisan make:notification ImportantError			
				Адресс класса отправки уведомлений:
					app\Notifications\ImportantError.php
				
			ОБЗОР ФНКЦИОНАЛА КЛАССА ОТПРАВКИ УВЕДОМЛЕНИЙ
				1) __construct() - конструктор
				2) via() - возвратщает массив каналов, по каторым доставляется сообщение. 
					TODO ЗАМЕТКА: для каждого канала придется рарабатывать свою отдельную функцию.  Для так сказать рендернга дял каждого канала.
					Отвечат за обработку канала объект "new MailMessage":
						->line('The introduction to the notification.') - строка
						->action('Notification Action', url('/')) - ссылка
						->line('Thank you for using our application!'); - строка
				3) toMail() - настройка внешнего вида канала
				4)	toArray() - возможность просмотра сообщений в виде массива

			ОТПРАВКА УВЕДОМЛЕНИЙ
				1-й способ отправки уведоблений - с шаблонами уведомлений Laravel по-умолчанию
					Создадим новый маршрут для проверки функционала на практике.
					Для отправки уведобления в контроллере понадобится фассад "Notification::" и класс отправки уведоблений "ImportantError".
					Создадим пользователй так, как сидер для пользовталей создавался только для темы авторзации:
						User::factory()->count(10)->create();
					Отправка сообщения:
						Notification::send(User::find(1), new ImportantError(150));
						где,
							Notification:: - фассад отправки уведоблений
							send - метод передачи. Аргументы: 1-й пользователь и объект
							150 - передаваемый аргумент - число
							TODO ЗАМЕТКА: почта пользователя выбирается автоматически из БД для отправки уведомления. Если поле с почтой или иным контактом названо не "email", то для этого прописывается отдельная функция для возврата почты в классе отправки уведомлений - и уже на нее ссыллается клас контроллера. 
							Пример:
								public function routeNotifacationForMail($notification){
										return $this->email;
								}
							Т.е. нужно каким то образом получить контактные даные. 
							Уведобление должно быть отправлено в логи, куда отправку мы и настроили предварительно. 

				2-й способ отправки уведоблений (более удобный):
					return (new MailMessage)->subject('Ошибка на сайте')->view(
						['emails.important_error', 'email.important_text'],
						['param' => $this->a, 'cufra' => 100]
					);
					где,
						MailMessage - фассад отправки почтового сообщения
						subject() - тема письма
						view() - передача параметров. 1-й массив: HTML+текстовый шаблоны. 2-й массив: передаваемые параметры. 
				
				
			ВСТРОЕННЫЕ ШАБЛОНЫ УВЕДОМЛЕНИЙ, ПОЧТЫ В LARAVEL
				Команда копирования шаблонов уведомлений в проект:
					php artisan vendor:publish --tag=laravel-notifications
				Адрес хранения шаблонов с уведомленийми:
					resources\views\vendor\notifications\email.blade.php
					В этом шаблоне и прописываются поля объекта "MailMessage" в виде ->line/->action.

				Но имхо лучше прописывать шаблоны самому, дабы избежать повторяющихся шаблонов с другими разработчиками. 

				Команда копирования почтовых шаблонов в проект:
					php artisan vendor:publish --tag=laravel-mail
				Адрес хранения почтовых шаблонов:
					resources\views\vendor\mail\html
					resources\views\vendor\mail\text
				Все шаблоны относятся к Markdown'у и содержат либо только текст либо текст + HTML.

			ИЗМЕНЕНИЕ СТАНДАРТНОГО ШАБЛОНА ПРОВЕРКИ ПОЧТЫ LARAVEL
				Зайддем в исходник и посмотрим стандартный шаблон:
					\vendor\laravel\framework\src\Illuminate\Auth\Notifications\VerifyEmail.php
					
				В этом классе есть методы формирования уведомления:
					1) toMail
					2) buildMailMessage
						Эти методы формируют шаблон и отправку писем. Если они не устраивают - можно создать свои на их базе, не меняя исходные. 
					
					После это - созданное уведомление нужно подключить к моделе пользователй. 
						Пример:
							public function sendEmailVerificationNotification()
							{
								$this->notify(new VerifyEmail);
							}
							где,
								new VerifyEmail - самомозданный класс формирования шаблонов уведомлений
		*/

		//!Урок 2: События
		/*
			
		Событие - это класс (event/событие), выполняется в коде при определенных условиях и запускает работу множества классов-обработчиков событий (listener/слушатель). 
		Создание события без создания listener'а/слушателя - не имеет смысла.
		Буть то отправка сообщения боту, e-mail, выгрузка в SRM и т.д.		
		После совершения какого либо события в приложении подразумевается множество действий.  Например при оплате товара на сайте высылается e-mail сообщение покупателю, менеджеру и т.п. Чтобы не захломлять контроллер множеством кода - используются события. 
		Входной точкой для инициализации событий является файл "app\Providers\EventServiceProvider.php". 

	1. Создание события, листенера и их настройка
		В отличии от очередей - для работы с событиями не нужно ничего создавать в БД перед созданием самого события - например таблицы "job".

		Создание события происходит через командную строку:
			php artisan make:event MyEvent
			где,
				make:event 	- создание события
				MyEvent		- название события
		Класс-событие будет только принимать переменные через конструктор, полученные из контроллера и после передавать их классам-листенерам.
		После создания класс появляется в папке "\app\Events\MyEvent.php";

		Создание обработчика (listener), отслеживающего событие:
			php artisan make:listener MyEventNotification
				или так 
			php artisan make:listener NewCommentEmailNotification --event=\App\Events\MyEvent (омжно и так: --event=MyEvent)
			где,
				make:listener 								- создание обработчика события
				MyEventNotification				- название обработчика
				--event=\App\Events\MyEvent	- параметр, указывающий listener'у от какого event-class'а принимать параметры
		Класс-listener будет выполнять действия с переменными, полученными от класса-события. 
		Cозданный класс появляется в папке "\app\Listeners\MyEventNotification.php";
			
	2. Работа с созданными событием и листенером
		Так как event только принимает аргументы от контроллера, то в его распоряжении достаточно оставить только конструктор с присваиванием аргумента полю. 
			class MyEvent{...
					public $comment;
					public function __construct($comment){
						$this->comment=$comment;
					}
			...}

		И так как listener в лишь выполняет действие с полученными аргументами от события, то ему достаточно оставить лишь метод выполнения (без контроллера). 
		Т.е. слушатель ловит объект события в мтеод "handle()", а не "__construct()";
			public function handle(MyEvent $event){
				echo $event->data.'<br>';
			}
			где,
				$event - объект события MyEvent
		
	3. Связывание слушателя и события
		Для взяимодействия события и слушателянужно связать в провайдере:
			Входной точкой для инициализации событий является файл "app\Providers\EventServiceProvider.php". 
			Провайдер: app\Providers\EventServiceProvider.php
			В нем уже имеется одно событие и в нем (событии) вызов одного обработчика:
			Пример:
				protected $listen = [
					Registered::class => [
						SendEmailVerificationNotification::class,
					],
				];
			где, 
			Registered - класс события
			SendEmailVerificationNotification - класс-обработчик (листенер/listener), активирующийся при совершении события
			
			Предварительно событие и слушателя нужно подключить:
				use App\Events\MyEvent;
				use App\Listeners\MyEventNotification;

			Новое событие с листенером будет выглядеть так:
				MyEvent::class => [
					MyEventNotification::class,
				],
			После срабатывания события "MyEvent" - выполняется листенер "MyEventNotification". Количество листенеров неограничено. 

	4. Добавление вызова события в контроллере
		Создаем маршрут, подключаем к контроллеру событие, пишем код - результат передаем в событие. 
		Пример:
			$comment = $post->comments()->create($request->validated());
			event(new MyEvent($comment));
				ИЛИ
			MyEvent::dispatch($comment);
			где,
				dispatch - метод передачи даных в конструктор события, подключенный в событие через трейт "use Dispatchable".
				event - метод создания объекта события. Что тоже равносильно вызову его конструктора. 
			
		TODO ЗАМЕТКА: Чтобы обработчик - listener приступал к отправки сообщения не сразу, а с задержкой - то ему нужно имплементировать интерфейс "ShouldQueue". 
		Пример:
			class NewCommentEmailNotification implements ShouldQueue {...}

		TODO ЗАМЕТКА: Минусом работы с событием является нечитабельный код. Дело в том, что незнакомому с проектом разработчику не понять просто так, куда класс-event передает полученный аргумент, так как в нем нет информации о листенере, а только есть метод "__construct{}". Слушатель события проверяется только в провайдере.

		*/

	echo '<hr><hr><br><h3>Laravel - #30.1-2 - Создание собственных команд для Artisan, Планировщик задач (День 30)</h3><hr><hr>' . "<br>";
		//!Урок 1: Создание собственных команд для Artisan
		/*
			СОЗДАНИЕ КОМАНД:
				В Laravel есть возможность создавать и свои artisan команды. 
				Они прописываются в созданном файле.
				Требуется это тоько в крупных проектах и не часто. например, когда это относится к задачам, которые должны выполняться черзе какие то промежутки времени. Например проверка ответных писем от почтовых сервисов. Формирование ежедневного отчета, отправляемого в email. 
				А зетем поставить планировщик - о нем в следующем уроке. 

				Пример создания команды файла с самописными комнадами:
					php artisan make:command TestCommand
				Адрес хранения самописных команд: 
					app\Console\Commands\TestCommand.php

			
			ПОЛЯ И МЕТОДЫ В ФАЙЛЕ САМОПИСНЫХ КОМАНД
				1) $signature - переменная с описанием команды (как называется, какие есть аргументы, какие параметры).
					Пример:
						protected $signature = 'uset:test {data} {--a} {--b=} {--O|options}';
						где,
							uset:test - название команды
							data - имя аргумента команды. 
							--a - переключатель, который при наличии в команда передает => true - 1, при отсутствии => 0 - false.
							--b= - параметр, принимающий значение. Аналог data, но указвающий ключ занчения
							--O|options/--O|options= - переключатель/параметр, имеющий сокращенное значение. 

						В команду так же можно переадвать массивы и т.п. На практике и приведенный объем избыточен. 

					Пример записи команда в консоль:
						php artisan user:test perviyParavetr --a --b=vtoroyParametr --options=text_oprions// или --options
							TODO ВАЖНО! при создании команды важно оставлять в нахзвание префиксы ":" во избежении повторения пользовательских команд с служебными. 
				
				2) $description - описание команды. Отображается после ввода команды "php adtisan list"
				3) В предыдущих версиях был конструктор, но он не важен, поэтому его убрали. 
				4) handle() - функция, вызываемая при ввыполнении команды. 
					Функция подразумевает вызов из себя функции класса с самописыными командами:					
						4.1) line() - вывод линии в консоль
						4.2) argument() - получение значения аргумента
							Пример вывода переданного аргумента в консоль:
								$this->line($this->argument('data'));
								где,
									data - название аргумента, записанного в переменной $signature
						4.3) info() - выывод строки, подсвеченаной синим цветом.
							$this->info($this->option('b'));
						4.4) warn() - выывод строки, подсвеченаной желтым цветом.
							$this->warn($this->option('b'));
						4.5) error() - выывод строки, подсвеченаной оранжевым цветом.
							$this->error($this->option('b'));
						4.6) option() - функция полученияе командой параметра
							$this->info($this->option('options'));
						4.7) newLine() - пустая строка ... хотя возможен и аргумент в виде значения строки
							$this->newLine();
						4.8) ask() - сообщение с запросом ввести значение в консоль для принятия в аргумент. 
							$data = $this->ask('Введите данные: '); // $data принимает аргумент после ввода значения после вопроса
						4.9) comment() - вывод сообщения в консоль, прописанного в переменной. Аналог info/warn/error, но без цвета. 
							$this->comment($data);
						4.10) confirm() - метод с запросом подтверждения. 
							if ($this->confirm('Уверены?: ')) {
								$this->line('yes');
							}else{
								$this->line('no');
							}
						4.11) call() - функция запуска команды. 1-й аргумент: название запускаемой команды, 2-й: массив с передаваемыми параметрами. 
							$this->call('list');

		*/

		//!Урок 2: Планировщик задач
		/*
			Планировщие задач - это более гибкий и настраиваемый аналог скрипта Crone, встроенный в Laravel.	
			TODO ЗАМЕТКА: Crone кстати тоже вызывается чреез artisan.
			Зачем нужен плинировщик:
				Планировщик нужен для автоматизированного запуска определенных команд, например каждый четверх 3-й недели месяца. 
				1) В некоторых аспектах планировщик будет удобнее crone'а, а в некоторых просто незаменим им. 
				2) Когда нужно, чтобы команда не запускалась дважды подряд если весь пакет команд запускается по-новой из за сбоя например. Crone же пришлось бы костылить.
				3) На сайте может быть множество команд, на отправку уведомлений ежедневных или нет. При переезде на другой сервер Crone придется заново настраивать, а плинировщик же остается в проекте без необходимости перенастройки. Он запускается одной командой Crone'ом через artisan.
				
				СОЗДАНИЕ ЗАДАЧИ:
					php artisan make:command UpdateFileCommand
					Адрес файла, выполняющего задачу: app\Console\Commands\UpdateFileCommand.php

					Поля и метдоы представлены по подобию с классом созданных команд artisan. 
						signature - настройка команд в artisan. 
						$description - описание команды. 
						handle() - код запускаемый при обращении к планировщику.
					
					Пример:
						protected $signature = 'user:updatefile'; - даем название команде.
						handle(){
							$this->line('Start...'); - строка в терминале		  				
							Storage::disk('local')->put('comand.txt',  time()); - создание файла в диске local с текущей временной меткой
						}
					Запуск команды для проверки файла: 
						php artisan user:updatefile
						storage\app\comand.txt - файл создан: 1687636083

			ДОБАВЛЕНИЕ ЗАДАЧИ В ПЛАНИРОВЩИК ЗАДАЧ:
				Задачи, записанные в планировщик находятся в файле: app\Console\Kernel.php и метде: schedule().
				Пропишем записанную ранее задачу в планировщик.
					Пример:
						$schedule->command('user:updatefile'){
							->everyMinute()
							->between('12:00', '20:00')
							->WithoutOverlapping();
						}	
						где,
							command() - меотд запускающие комнаду
							user:updatefile - запускаемая команда
							everyMinute() - таймаут запуска команды
							between() - метод определяющий временной отрезок запуска команды
							WithoutOverlapping() - метод запрещающий запускать следующию иттерацию команды с таймаутом до ее полного выполнения. 
						Есть множество других инструментов в планировщике, но и эти достаточно часты.
						Метод Crone не имеет аналогичного метода "WithoutOverlapping()".
						TODO ЗАМЕТКА: запрет на перехд на следующую иттерацию очень важен. Иногда комнада может не выполниться полностью в таймаут 1 мин. Тогда следущая иттерация выполнит пункты задачи предудущей иттерации повторно. Это может быть отправка писем - тогда получатели письма получит его второй раз. После каждого отправленного письма выставлять пометку "отправлено" в БД - накладно для производительности - это делается одной командой в конце задачи, когда все писмьа отправлены.

			КОМАНДА ЗАПУСКА ПЛАНИРОВЩИКА:
				1) php artisan schedule:run
					Эта команда запускает все задачи в планировщике задач единоразово.
					TODO ВАЖНО! Именно эту комнаду (php artisan schedule:run) и нужно сиавить в Crone на таймаут указанный в планировщике => 1 мин. 
						Созержание файла storage\app\comand.txt: до запуска планировщика - 1687636083; до запуска планировщика: 1687685791
				2) php artisan schedule:work
					Эта команда запускает все задачи в планировщике задач циклично.
					TODO ВАЖНО! Для заврешения работы этого планировщика достаточно в терминале прожать CTRL+C.
					TODO ЗАМЕТКА: Эта команда запускается только на этапе разработке для проверки работы планировщика.
					

		*/

	echo '<hr><hr><br><h3>Laravel - #31.1-3 - Локализация, Helpers, Заключение (День 31)</h3><hr><hr>' . "<br>";
		//!Урок 1: Локализация
		/*
			НАСТРОЙКА ЛОКАЛИЗАЦИИ
				Папка локализации: lang
				В старых версиях она находилась в ресурсах. 
				В папке есть папки с самой локализацией - по-умолчнию "en".
				Папка вмещает языковые константы: ключ - значение своей локализации. 
				Прмиер константы en\pagination.php:
					'previous' => '&laquo; Previous',
					'next' => 'Next &raquo;',
					где,
						previous - ключ на который ссылается шаблон
						&laquo; Previous - значение ключа, выводимое при обращении к нему

			СОЗДАНИЕ СВОИХ КОНСТАНТ		
				а) Создать константу можно чрезе создание файла в папке локали с возвратом массива, где константа - ключ, значнеие - перевод локали. 
				Создавать файлы констант лучше для отдельных задач. Константы только для авторизации, контснты для паролей, константы для вывода ошибок и т.д. 
					Пример: validation/passwords/pagination ... и т.п.
				
				б) Так же константы можно объявлять без создани файла, а через внесения в файл "\lang\en|ru.json"
					Там так же прописываются связки ключ значения, но в виде JSON. 
						Пример:
							{
								"welcome": "Добро пожаловать из JSON :name!",
								"password": "пароль",
								"error": "ошибка",
								"hello": "привет"
							}
							где,
								password - константа
								пароль - значение
								:name - переманная, получаемую в шаблоне от контроллера
							Пример вызова константы с параметрами:
								echo __('welcome', ['name' => 'переданное имя']).'<hr>';

			МЕТДЫ РАБОЫТ С ЯЗЫКОВЫМИ КОНСТАНТАМИ
				Для работы языковой константы есть методы:
					1) trans() - функция обращения к константе. Аргументом выступает путь до константы в папке /locale/ru|en/.
						Пример:
							echo trans('testLocation.welcome'); "Добро пожаловать/welcome"; В файле: lang\ru\auth.php
							echo trans('welcome'); "Добро пожаловать/welcome"; В файле: lang\ru.json
							где,
								testLocation - константа 
								welcome - параметр константы
							TODO ЗАМЕТКА: в аргументах методов обращения к контснтам не находящихся в отдельном файле кроме JSON - указываюстя только константы. 
					2) __() - аналог мтеода trans(), выставленные через двойное подчеркивание.
						Пример:
							echo __('testLocation.welcome'); "Добро пожаловать/welcome";
							TODO ЗАМЕТКА: такой метод чаще используется в шаблонах.
					3) setLocale() - метод динамической смены локали. Используется через фассад "App". Аргументом выступает локаль. 
						Пример:
							App::setLocale('ru');	
					4) currentLocale() - метод проверки/вывода локали. Используется через фассад "App". 
						Пример:
							echo App::currentLocale('ru');	
		*/

		//!Урок 2: Helpers
		/*
			Некоторые задачи ситуации и задачи повторяются в проектах достаточно часто. 
			Для таких редовых ситуаций были созданы хелперы => Helpers. 
			Они избаляют от необходимости прописывать функционал часто повторяющихся функций. По-сути они выполняют роль стандартных функций языка, но и дополняют их.  
			Наример до PHP 8 функции "str_contains()" не было, поэтому приходилось пользоваться хелпером Str::constant(). Или методом вывода ошибок: abort(403).
			
			TODO ЗАМЕТКА: хелперы нужно подключать как и фассады.
				Пример:
					use Illuminate\Support\Str;

			Разберем в рамках курса несколько вариантов хелперов:	
				1) Str::contains() - метод происка в строке подстроки. 1-й аргумент строка, 2-й аргумент строка искомая в строке. 
					Пример:
						return (Str::contains('строка из символов в которой есть Str', 'Str')) ? 'Строка нашлась' : 'строка не нашлась';
				2) Str::endsWith() - метод проверки на заврешение строки определенным определенной подстрокой. 
					Пример:
						echo (Str::endsWith('строка из символов в которой есть Str', 'Str')) ? 'Заканчивается на X подстраку'.'<br>' : 'Не заканчивается на X подстраку'.
				3) Str::startsWith() - метод проверки на заврешение строки определенным определенной подстрокой. 
					Пример:
						echo (Str::startsWith('строка из символов в которой есть Str', 'Str')) ? 'начинается на X подстраку'.'<br>' : 'Не начинается на X подстраку'.<br>;
				4) Str::replaceLast() - функция замены последней указанной подстроки в строке, указанной подстрокой. 1-й аргумент - заменяемая подстрокастрока, 2-й - заменяющая подстрока, 3-й строка с заменяемой подстрокой. В то время как аналог PHP заменяет все указанный подстроки в строке. 
					Пример:
						echo Str::replaceLast('Str', 'replaceLast', 'строка из символов в которой есть Str').'<br>';
				5) Str::words() - обрезает строку до указанного количества слов. 1-й аргумент - брезаемая строка, 2-й количество оставляемых слов, 3-й (дополнительный) - строка, на которую заменяется строка удаленная.
					Пример:
						echo Str::words('несколько слов в предложении', 2).'<br>';
				6) Str::random() - фнкция генерации количества символов. Аргумент - количество случайно генерируемух символов.
					Пример:
						echo Str::random(10).'<br>';
		*/

		//!Урок 3: Заключение
		/*
			Курс подошел к концу. 
				Для дальнейшего обучения и устройства на работу нужны практика и подготовка проектов.
		*/

		
	echo '<hr><hr><br><h2>Модуль №32.32-40: Бонус "Создание сайта на Laravel"</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #32.1-3 - Постановка задачи, Создание и настройка проекта, Создание моделей (День 32)</h3><hr><hr>' . "<br>";
		//!Урок 1: Постановка задачи
		/*
			В рамках бонусного курса будем применять полученные ранее теоритические знания на практике через создание сайта с следющего урока.
			Этапы создания сайта:
				1) Протатипирование - определение функций продукта и пользовательского интерфейса.
				2) Дизайн - составление дизайна шаблонов, верстка сайта. 
				3) Связвание шаблонов вместе и подгрузка данных из БД. 
		*/
		//!Урок 2: Создание и настройка проекта
		/*
			Начнем работу с создания нового проекта:
				php composer.phar create-project laravel/laravel 32-40_praktika
			Внесем прилагаемые с курсом файлы (js/styles/img) папки public в проект.
			Созаддим бд и подключем в .env: laravel_Rusakov_practice
			В конфиге выберем русскую локаль.
		*/
		//!Урок 3: Создание моделей
		/*
			В процесе создания моделей нет однозначно правильного и неправильного подхода - это творческий процесс.
				Практика показывает, что с 1-го раза модель правильно создать со всеми необходимыми параметрами редко получается, но в курсе получится. 

				Планируемые модели:
					1) модель поста
						php artisan make:model Post -mfs
						Use SoftDeletes; - мягкое удаление
					2) платные курсы 
						php artisan make:model Course -mfs
					3) бесплатные курсы 
						php artisan make:model FreeCourse -mfs
					4) комментарии
						php artisan make:model Comment -mfs
					TODO ЗАМЕТКА: Введем возможность прописи комментариев без авторзации с возможность удаления. Через access_token.
					5) сайты учеников
						php artisan make:model Site -mfs

				Оставим только созданные мигарции - остальные удалим. 
				Вот некотрые поля из созданных:
					1) посты:
						$table->boolean('is_release'); //пост - рассылка или нет
						$table->string('aleas', 255)->uniqid(); //чпу ссылки
						$table->integer('hits'); //просмотры
						$table->dateTime('data_show'); //заданное время отображения поста (анонс).
						$table->softDeletes(); //мягкое удаление

					2) комменты:
						$table->integer('post_id'); //id поста
						$table->string('access_token', 32); //токен проверки автора коммента, даваемый пользователю при создании коммента (без авторизации).

					3) курсы платные:
						$table->string('alias', 255)->uniqid(); //алиас - псевданим ссылки
						$table->decimal('price', 10, 2); //цена курса. 1-й арг: название поля, 2-й: кол-во символов, 3-й кол-во символов после запятой
					TODO ЗАМЕТКА: для обозначения цен в таблицах лучше использовать тип данных "decimal". 

					4) курсы бесплатные:
						$table->integer('delivery_id'); //номер рассылки - он определяет подписку пользователя

					5) сайты:
						$table->string('address', 255);
						$table->boolean('is_active'); //флаг проверки сайта модератором

					Модели:
						Отношения:
							1) пост
								один ко нмогим с комментариями
							2) коммент
								один ко нмогим с комментариями
						Атребуты:
							1) сайт:
								protected $attribute = ['is_active' => 0];
						Запуск миграции: php artisan migrate:fresh --seed
		*/

	echo '<hr><hr><br><h3>Laravel - #33.1 - Создание фабрик и наполнителей (День 33)</h3><hr><hr>' . "<br>";
		//!Урок 1: Создание фабрик и наполнителей
		/*
			Фабрики и сидеры с прошлого урока - наполним их и запустим. 
			С помощью фейкера не получится с HTML создать текст. Поэтому создадим функцию генерации текста с параграфами HTML.
				'intro_text' => $this->getFakeHTMLText(1), //генерация текста с HTML
				public function getFakeHTMLText($countParagraphs){
					$paragraphs = $this->faker->paragraphs($countParagraphs);
					$text = '';
					foreach ($paragraphs as $p) { //генерация блоков текста
						$text .= "<p>$p</p>";
					}
					return $text;
				}

				TODO ВАЖНО! Так как этот функционал будет повторяться и в других фабриках - создадим для него класс с статическим методом.
				TODO ЗАМЕТКА: faker передается только в качестве аргумента, поэтому приставка "$this" не нужна. 
					class FactoryHelper {
						public static function getFakeHTMLText($faker, $countParagraphs){
							$paragraphs = $faker->paragraphs($countParagraphs);
							$text = '';
							foreach ($paragraphs as $p) { //генерация блоков текста
								$text .= "<p>$p</p>";
							}
							return $text;
						}
					}
					Пример вызова класса: 'intro_text' => FactoryHalper::getFakeHTMLText($this->faker, 1), //генерация текста с HTML

			Алиасы должны быть уникальным и не сгенерированными. Создадим массив из них: $aliases = [ '5steps', 'ab-1', 'ab-2',...];
			  'is_release' => mt_rand(1, 2) == 1, //true || false
            'title' => $this->faker->realText(mt_rand(20, 100)), // текст от 20-100 чимволов
            'alias' => $this->faker->unique()->randomElement($aliases), //вместе с алиасом будет и картинка, отвечающая за пост: analist-img.png 
            'intro_text' => FactoryHelper::getFakeHTMLText($this->faker, 1), //генерация текста с HTML
            'full_text' => FactoryHelper::getFakeHTMLText($this->faker, mt_rand(2, 10)), //от 2 до 10 абзацов
            'meta_key' => implode(', ', $this->faker->words(mt_rand(3, 5))), //возврат массив случайных слов, преобразованных в строку
            'hits' => mt_rand(0, 1000), //число просмотров
            'date_show' => $this->faker->dateTimeBetween($startDate = '-1 year', $endDate = '+1 month') //время показа +-1 год/день
		
			Коменты:
				$dataTime = $this->faker->dateTime(); // случайное время
				'access_token' => Str::random(32), //генератор токена доступа к комменту из 32 символов
				'created_at' => $dataTime, //время созданяи комментария 
				'updated_at' => $dataTime, //время обновления комментария 
			
			Курс:
				'full_description' => FactoryHelper::getFakeHTMLText($this->faker, mt_rand(2, 4)), 
				'price' => mt_rand(1000, 45000), //цена
			
			Курс бесплатный:
				Практически копия платного. 

			Сайты:	
				'address' => 'http://'.$this->faker->domainName(), //адрес сайта
				'is_active' => mt_rand(1, 2) == 1,

			Сидеры:
				$this->call([
					FreeCourseSeeder::class,
					...
				]);
				поста:
					Post::factory()->count(20)->create();
				Коменты:
					Comment::factory()->count(80)->create();
				Курс:
					Course::factory()->count(20)->create();
				Курс бесплатный:
					FreeCourse::factory()->count(20)->create();
				Сайты:
					Site::factory()->count(25)->create();
		*/


	echo '<hr><hr><br><h3>Laravel - #34.1 - Подготовка основного шаблона (День 34)</h3><hr><hr>' . "<br>";
		//!Урок 1: Подготовка основного шаблона
		/*
			Возмем HTML шаблон предлагаемого сайта в материалах курса и будем переводить его на Laravel. 
			В большей части страницы на сайте похожи друг на друга. 
			В ходе урока буудем описывать шаблон главной страницы. 
			
			Для начала заменим ссылки на имена ссылок в маршрутах.
			Передаваемые в шаблон переменные будем помещать в компанент, а его уже дублировать в шаблоны: 
			Создадим папку resources\views\layouts, в котором создадим компанент "main-layout.blade". 
			Создадим компанент, который будет получать информацию, повторяющуюся на страницах.
				php artisan meke:component MainLayout
				resources\views\components\main-layout.blade.php
				Но эта папка нам не нужна, так как мы уже создали файл-шаблон, котоырй и является компанентом. 
				А файл - контроллер компанента - оставим в нем и будем получать данные, передаваемые в компанент:
					app\View\Components\MainLayout.php
					Указываем в нем путь до компанента: 
						return view('layouts.main-layout');
			Сайдбар будем выводить только на главной странице: <div id="right">{{ $right ?? ''}}</div>
			В контроллере компанента создадим и передадим массивы платный и бесплатных курсов:
				$slider = Course::orderByDesc('id')->get();
				$courses = FreeCourse::orderByDesc('id')->get();
				return view('layouts.main-layout', ['slider' => $slider, 'courses' => $courses]);
				
			Вставка для отображения года
				<p>&copy; Blog.MyRusakov.ru {{date('Y')}} г.</p>
		*/

	echo '<hr><hr><br><h3>Laravel - #35.1-2 - Вывод главной страницы, Навигация по страницам (День 35)</h3><hr><hr>' . "<br>";
		//!Урок 1: Вывод главной страницы
		/*
			Займемся выводом главной страницы, создав контроллер и заполнив компанент слотами. 
			Выведем посты время публикации (data_show) которых меньше теущего. Передадим это в виде переменной $posts. Carbon::now() - текущее время. 
			Компанент в прошлом уроке мы создали - теперь создадим для него шаблон => resources\views\index.blade.php
			TODO ЗАМЕТКА: с выводом даты есть сложность. Она должна выглядеть так: "03 декабря 2021". Для этого применим функцию "translatedFormat('d F Y')". 
			Поле "date_show" является строкой, поэтому его нужно перевести в объкт/формат "date". 
			Для этого у нас есть абцессор и мутатор. 
			Для этого в методе Post пропишем:
				protected $casts = [
					'date_show' => 'date'
				];
				где, date_show - поле таблицы, date - изменяемый формат. 
				
			<div class="date">{{$post->date_show->translatedFormat('d F Y')}}</div>, где ('d F Y') - формат вывода времени. Локаль переведент ее на русский. 
			Переносим в компанент левую и правую часть и запускаем. 
			Вывод ссылок постов:
				<a href="{{route('post', ['id' => $post->id])}}">ЧИТАТЬ ПОЛНОСТЬЮ &gt;</a>
		*/

		//!Урок 2: Навигация по страницам
		/*
			Введем разбиение на страницы выводимые посты на гл.странице. 
			Меняем вывод постов в контроллере c ->get() на ->paginate():
				
				$posts = Post::where('date_show', '<', Carbon::now())
				->orderByDesc('date_show')
				->paginate(5);
				НО так напрямую выставлять количество записей на странице не рекомендуется. Для этого число устанавливается в константу в файле .env 
				Пример:
					USER_COUNT_ON_PAGE=5
				И установим ее в пагинатор:
					->paginate(env('USER_COUNT_ON_PAGE'));

				TODO ЗАМЕТКА: рекомендуется все пользовательские настройки/команды/константы называть с префикса USER. 
				Вывод пагинации на странице с постами:
					{{$post->links('pagination')}}
					где,
						links - метод пагинации
						pagination - подключаемый шаблон пагинации с логикой отображения пагинации, в которой передаются ссылки на страницы
					
					В шаблоне:
						1) Проверяем страницы на наличие
							@if ($paginator->hasPages()) ... страницы ... @endif
						2) Выводим текущую и поледнюю страницу
							<span>Страница {{$paginator->currentPage()}} из {{$paginator->lastPage()}}</span>
						3) Ввод на первой странице либо ссылка на первую страницу
							@if ($paginator->onFirstPage())
								В начало&nbsp; &laquo;&nbsp;
							@else
								<a href="{{ Request::url() }}">В начало</a>&nbsp;
								<a href="{{ $paginator->previousPageUrl() }}">&laquo;</a>&nbsp;
							@endif
							где,
								$paginator->onFirstPage() - проверка текущей тсраницы как первой
								Request::url() - url без GET параметров, т.е. 1-я страницы
						4) Предыдущая страницы
							$paginator->previousPageUrl()
						5) Вывод страницы:
							@foreach ($elements as $element)
								@if (is_array($element))
									@foreach ($element as $page => $url)
											@if ($page == $paginator->currentPage())
												{{ $page }}&nbsp;
											@else
												<a href="{{ $url }}">{{ $page }}</a>&nbsp;
											@endif
									@endforeach
								@endif
							@endforeach
						6) Следующая страница, номер последней страницы
							<a href="{{$paginator->nextPageUrl()}}">&raquo </a>
							<a href="{{Request::url().'?page='.$paginator->lastPage()}}">В конец</a>
						7) Последняя страницы
							@if ($paginator->onLastPage())
								&raquo;&nbsp; В конец
							@else
							где,
								$paginator->onLastPage() - проверка последней страницы как последней
					
							
		*/


	echo '<hr><hr><br><h3>Laravel - #36.1-3 - Вывод страницы "Об авторе", Вывод страницы "Видеокурсы", Вывод страницы "Выпуски рассылки" (День 36)</h3><hr><hr>' . "<br>";
		//!Урок 1: Вывод страницы "Об авторе"
		/*
			Выведем страницу об авторе создав шаблон и метод контроллера. Тут все просто. 
			Правого блока в шаблоне не будет. 
		*/

		//!Урок 2: Вывод страницы "Видеокурсы"
		/*
			Выведем страницу о видеокурсах. 
			Создадим метд вывода курсов в контроллере:
				public function courses(){
					return view('author', [
						'courses' => Course::orderByDesc('id')->get(),
						'free_courses' => FreeCourse::orderByDesc('id')->get()
					]);
				}
			Фишки вывода курсов через foreach:
				1) {{$loop->index + 1}}
					Нумерация выведенных курсов
				2) {{$loop->index + count($courses) + 1}}
				TODO ЗАМЕТКА: запись означает продожение списка после вывода платных курсов
					вывод нумерации бесптатных курсов. 
		*/

		//!Урок 3: Вывод страницы "Выпуски рассылки"
		/*
			Реализуем вывод рассылок:
			Через контроллер быудем передавать бесплатные курсы. На странице будет выводиться и номера выпуска и чтобы ее вывести нужно знать общее число выпусков. 

			public function releases(){
				$courses = FreeCourse::orderByDesc('id')->get();
				$posts = Post::orderByDesc('id')
					->where('is_release', 1)
					->where('date_show', '<', Carbon::now())
					->paginate(env('USER_COUNT_ON_PAGE'));
				$count = Post::orderByDesc('id')
				->where('is_release', 1)
				->where('date_show', '<', Carbon::now())
				->count();

				return view('releases', [
					'courses' => $courses,
					'posts' => $posts,
					'count' => $count
				]);
			}
			где,
				$courses - бесплатные курсы, выводимоые в обратном порядке
				$posts - опубликованные посты, выводимые в обратном порядке, выводимые постранично
				$count - количество выпусков вышедших в релиз (нужнго дял вывода номеров выпусков на странице)

			Запись в шаблоне:
				<h4>Выпуск №{{$count - $loop->index}}.</h4> 
				$count - $loop->index -- максимальное число выпусков минус номер индекса выводимого элемента, т.е. $loop->index 1-й иттераци == [0]. 
				Это правило работает если была бы одна страница пагинации, но их множество:
					<h4>Выпуск №{{$count - $loop->index - ($post->currentPage() - 1)*env('USER_COUNT_ON_PAGE')}}.</h4>
						($post->currentPage() - 1)*env('USER_COUNT_ON_PAGE') - запись вычета элементов предыдущей страници. На 2-й странице вычитываются номера 1-й страницы.
						где,
							$post->currentPage() - номер текущей страници. Т.е. $post->currentPage() - 1 - игнорирует первую страницу
							/*env('USER_COUNT_ON_PAGE') - умножение на количества элементов на странице
			
			Так как вывод постов не отличается в текущем и в предыдущем уроках уроме записи с номером выпуска, то создадим для вывода поста отдельный шаблон. 
			Теперь вывод постов на главной странице:
				@foreach ($posts as $post)
					@include('post_intro')
				@endforeach
			На странице редации:
				@foreach ($posts as $post)
						@include('post_intro', ['number' => $count - $loop->index - ($posts->currentPage() - 1)*env('USER_COUNT_ON_PAGE')])
				@endforeach
		*/

	echo '<hr><hr><br><h3>Laravel - #37.1-3 - Вывод страницы "Сайты учеников", Добавление сайта, Добавление reCAPTCHA (День 37)</h3><hr><hr>' . "<br>";
		//!Урок 1: Вывод страницы "Сайты учеников"
		/*
			Вывод сайтов не сложен и потребуется для вывода формы добавления сайтов. 
			Вывод сайтов в контроллере:
				return view('sites', [
					'sites' => Site::where('is_active', 1)->orderByDesc('id')->get()
				]);
		*/

		//!Урок 2: Добавление сайта
		/*
			Создадим вывод формы для добавления сайта. 
			В мершруте будем выводить форму чреез HTTP метод Any:
				Route::any('/sites/add', [App\Http\Controllers\MainController::class, 'addSites'])->name('sites.add');
			Action ведет на страницу с формой: action="{{url()->current()}} или "action="sites/add""
			
			Проверка формы на ошибки и вывод сообщения об успешном добавлении формы:
				@if ($errors->any())
					@foreach ($errors->all() as $message)
						<p class="messsage">{{$message}}</p>
					@endforeach
				@elseif($success_add)
					Изначально $success_add - имеет значнеие false в контроллере, но после добавления становится true.
					<p class="messsage">Сайт успешно добавлен и отправлен на проверку перед размещением</p>
				@endif

			Проверка и создание сайта:
				if ($request->add_site) {
				$validate = $request->validate([
					'address' => 'required|url|unique:sites',
					'description' => 'required|min:10|max:200',
				]);
				$site = new Site();
				$site->address = $validate['address'];
				$site->description = $validate['description'];
				$site->save();

			TODO ЗАМЕТКА: в главном компаненте в пути к JS, IMG и CSS проставить в начале "/", чтобы дать понять, что поиск идет от корня.
				<link type="text/css" rel="stylesheet" href="/styles/fancybox.css" />
				<img src="/images/courses/{{ $course->alias }}.png" alt="{{ $course->title }}" />
			TODO ЗАМЕТКА: Строку ниже убираем - это CSRF токен, выводимый на страницу. Он уже проставлен в виде директивы.  
				{{--<input type="hidden" name="_token" value="i6yi4ysAPfHeWGPglYGnBrbKw9RZFWCk3iPmairH">--}}

			Создаем локаль RU
			В моделе должен быть массив с параметрами по-умолчнаию, котоыре не вводит пользователь:
				protected $attributes = [
					'is_active' => 0
				];
		*/

		//!Урок 3: Добавление reCAPTCHA
		/*
			Форма написана, но если ее оставить так, то на нее скоро будут спамить тысячами сообщений. 
			Поэтому нужна капча - рекапча.
			Для этого в Laravel специальный модуль. 
			Ссылка:
				https://laravel-recaptcha-docs.biscolab.com/docs/intro 
			
			Этапы установки рекапчи в фаорму:
				1) Получнеие ключа рекапчи
					Ссылка: https://www.google.com/recaptcha/admin/create
					а) выбор названия сайта - название рекапчи: local-laravel
					б) выбор типа рекапчи и подтипа
					в) указание домена
					г) принятие условий и отправка рекапчи
					д) копированеи ключа сайта: 6LeGeOgmAAAAAKtCENnTnPrrA6qKOfBcCJ1s6GIp и секретного ключа:6LeGeOgmAAAAABdx2x0qD5nUYD6EB4YtmVt-Ir5l

				2) Установка рекапчи
					а) установка через компосер в дериктории проекта: "composer require biscolab/laravel-recaptcha"
				3) Настройка рекапчи
					а) Создание config/recaptcha.php файл конфигурации, используя следующую команду artisan
						php artisan vendor:publish --provider="Biscolab\ReCaptcha\ReCaptchaServiceProvider"
				4) Добавление API ключей в файл .env (без угловых скобок):
					RECAPTCHA_SITE_KEY=<YOUR_API_SITE_KEY> == ключ сайта: 6LeGeOgmAAAAAKtCENnTnPrrA6qKOfBcCJ1s6GIp
					RECAPTCHA_SECRET_KEY=<YOUR_API_SECRET_KEY> == секретный ключ: 6LeGeOgmAAAAABdx2x0qD5nUYD6EB4YtmVt
					RECAPTCHA_SKIP_IP=<YOUR_IP_LIST> - список IP для которых можно отключить рекапчу...не будем реализовывать
				5) Открываем созданный файл "config\recaptcha.php"
					а) Указываем версию рекапчи
					Все параметры указаны обычно на странице установки библиотеки. Но у нас они установлены по-умолчанию.
				
			Использованеи рекапчи 2-й версии
				1) Вставьте htmlScriptTagJsApi() вспомогательный элемент перед закрытием </head> тега.
					<!DOCTYPE html>
						<html>
						<head>
						...
						{!! htmlScriptTagJsApi($configuration) !!}
						</head>
				2) Вставка в форму
					<form>
						@csrf
						...
						{!! htmlFormSnippet() !!}
							<!-- OR -->
							{!! htmlFormSnippet($attributes) !!} - если понадобится внести аттребуты 
						<input type="submit">
					</form
				3) Верификация
					Ввведенеи строки в проверку валидации: 'g-recaptcha-response' => 'recaptcha'
					$validator = Validator::make(request()->all(), [
						...
						'g-recaptcha-response' => 'recaptcha',
						// OR since v4.0.0
						recaptchaFieldName() => recaptchaRuleName()
					]);
				4) Добавление ошибки "validation.recaptcha" в языковую константу
					'recaptcha' => 'Вы не подтвердили, что вы не робот',

				Теперь рекапча должна работать, но так как у нас локальынй сервер и домен не настроен, то и рекапча не работает, так как в ней не прописан наш домен. 
		*/

	echo '<hr><hr><br><h3>Laravel - #38.1-2 - Вывод страницы с постом, Добавление комментариев (День 38)</h3><hr><hr>' . "<br>";
		//!Урок 1: Вывод страницы с постом
		/*
			Выведем страницу с постом и комментариев. Форму комментариев выведем в след уроке. 
			Укажем дополнительно, что в списке отображаемых постов не должен отображаться читаемый коммент. 
		*/

		//!Урок 2: Добавление комментариев
		/*
			Начнем обработку форму добавления комментариев, а значит поменяем запрос с GET на ANY. Route::any('/post{post} ... });
			Еще в меотд post добавим зависимость Request, так как в методе будет обработка полученных данных. 
			В форме указываем адрес на саму себя. 
			TODO ЗАМЕТКА: так как после ошибке редирект не нужен, то будем выполнять проверку формы через фассад: Validator::make().
			При создании комментария будем заполнять поле "$comment->access_token = '12345';"
			При успешном добавлении комментария нужно выводить шаблон на уровне формы добавления комментария для этого сделаем дополнительный маршрут:
				Route::any('/post{post}#comments', [App\Http\Controllers\MainController::class, 'post'])->name('post.comments');
			Если добавление не прошло успешно, то стоит через проверку воводить шаблон на месте формы с комментариями:
					if ($validator->fails()) return redirect()->route('post.comments', ['posts' => $post])->withErrors($validator->errors())->withInput();
						или
					if ($validator->fails()) return $redirect->withErrors($validator->errors())->withInput();
						где $redirect переменаня с redirect()->route( ... []);
							Запись "->withErrors($validator->errors()" необходима потому, что ошибки передаются в шаблон через метод ->validate();
						Запись "->withInput()" - нужна так как передает функцию old('inputName'), передаваемую методом "->validated()", которого мы не прописали так как  вызвали валидацию через фассад "Validator::". 
		*/

	echo '<hr><hr><br><h3>Laravel - #39.1-2 - Удаление комментариев, Добавление поиска (День 39)</h3><hr><hr>' . "<br>";
		//!Урок 1: Удаление комментариев
		/*
			Реализуем функцию вдаления комментариев не смотря на отсутствие на сайте авторизации. 
			TODO ЗАМЕТКА: пользователь при заходе на сайт получает в свою сессию специальный "access_token", котоырй выполняет функцию ID пользователя. 
			При добавлении комментария токен пользователя впечатывается в строку комментария. Если она совпадает с сессией пользователя - у него есть доступ на удаление.
			Но так как токен находится в сессии, то и возможность удаление сохраняется только при условии хранения токена в сессии - до выхода из браузера. 
			При необходимости возможностьи удаления в любое время - уже нужна авторизация. 

			УСТАНОВКА access_token
				1) При открытии страницы с постом - создается access_token в контроллере
					$this->setAccessToken($request);
				2) Функция созданяи токена:
					public function setAccessToken(Request $request) {
						if ($request->session()->missing('access_token')) {
							$request->session()->put('access_token', Str::random(32));
							где,
								use Illuminate\Support\Str; - хелпер
								missing('access_token') - проверка на отсутствие парамека сессии
						}
					}
					TODO ЗАМЕТКА: Метод missing() - может подсвечиваться как ошибка, но тем не менее он работает. 
				3) Прописать политику доступа к комментариям
					а) Сооздание потики
						php artisan make:policy CommentPolicy --model=Comment
						В политике понадобится только менто delete
					б) Доступ на удаление комментария если содержимое токена комментари и сессии совпадают
						public function delete(?User $user, Comment $comment): bool
						{
							return Session::get('access_token') === $comment->access_token;
						}
						где,
							/?User - не обязательность условия наличия у пользователя авторизации
				4) Вывод кнопки удаления комментария в форме добавления комментария
					@can('delete', $comment)
						<div class="functions"><a href="{{route('comment.delete', ['comment' => $comment])}}" class="replay">Удалить</a></div>
					@endcan
				5) Создание маршрута, ведущего на удаление комментария
					Route::get('/comment{comment}/delete', [App\Http\Controllers\MainController::class, 'deleteComment'])
					->middleware('can:delete,comment')->name('comment.delete');
				6) Удаление комментария
						public function deleteComment(Comment $comment) {
							$post = $comment->post;
							$comment->delete();
							return redirect()->route('post.comments', ['post' => $post]);
						}
					где,
						Comment $comment - удаляемый коммент
						$post = $comment->post; - ссылка для редиректа
						$comment->delete(); - удаление коммента
						return redirect()->route('post.comments', ['post' => $post]); - редирект на страницу с формой комментрирования
					TODO ЗАМЕТКА: без прописи дополнительной проверки в в контроллере или мидлваре/посреднике, проверяющего права удаления коммента - комменты удалять может кто угодно, подставляя в URL нужный Id. 
						Route::get('/comment{comment}/delete', [App\Http\Controllers\MainController::class, 'deleteComment'])
							->middleware('can:delete,comment')->name('comment.delete');
							где,
								can:delete - действие указаноне в политике
								comment - параметр над которым подразумевается действие (передается в политику для проверки). 
						TODO ВАЖНО! В посреднеке не должно быть пробелов между проверкой и передаваемым параметром. 
		*/

		//!Урок 2: Добавление поиска
		/*
			Реализацтя поиска на сайте:
				1) Создание маршрута:
				Route::get('/search', [App\Http\Controllers\MainController::class, 'search'])->name('search');
					TODO ЗАМЕТКА: поисковой запрос отправляется метдом GET, так как это нужно для индексации и продвижения. + это создает ссылку на результат поиска.  
				2) Смена урла в шаблоне:
					В шаблоне с поиском достаточно поставить URL, ведущего на метод поиска. 
						<form name="search" method="get" action="{{route('search')}}">
				3) Создание маршрута:
					Route::get('/search', [App\Http\Controllers\MainController::class, 'search'])->name('search');
				4) Проверка запроса на валидность:
					$validated = $request->validate([
						'search_query' => 'required|string|min:3|max:200'
					]);
				5) Составление выборки подходящих под запрос постов:
					$search_query = $validated['search_query'];
					$post = Post::where('title', 'LIKE', "%$search_query%")
					->orWhere('intro_text', 'LIKE', "%$search_query%")
					->orWhere('full_text', 'LIKE', "%$search_query%")
					->paginate(env('USER_COUNT_ON_PAGE'));
				6) Передача в шаблон запроса и выборки запроса:
					return view('search', ['search_query' => $search_query, 'post' => $post]);
				7) Создаем шаблон для вывода искомых постов и скопиурем в него код вывода постов из шаблона index:
					@if (!count($posts))
						<div id="other">
							<h1>Результаты поиска: {{$search_query}}</h1>
							<div id="pm">
								<p>Ничего не найдено!</p>
								<p><a href="{{route('index')}}">Вернуться на главную</a></p>
							</div>
						</div>
					@endif
					@foreach ($posts as $post)
						@include('post_intro')
					@endforeach
					{{$posts->links('pagination')}}
				TODO ЗАМЕТКА: по всем словам в искомых полях таблицы чрезе цикл foreach - для этого слова разбиваются через пробел в массив и уже в нем происходит поиск на соответствие запросу. Но обойдемся простйо версией поиска.

		*/

	echo '<hr><hr><br><h3>Laravel - #40.1-3 - Создание ЧПУ-ссылок, Вывод страницы 404, Подведение итогов (День 40)</h3><hr><hr>' . "<br>";
		//!Урок 1: Создание ЧПУ-ссылок
		/*
			На данный в адресной строке выводятся ссылки, понятные для сервера. Однако, это не ЧПУ-ссылки (человеко-понятные).
			+ для индекцсации страниц ужно, чтобы она была ЧПУ.
			В целом сайт уже имее ЧПУ ссылки, но кроме постов, котоыре отображаются в виде цифры в конце URL'a:
				.../post/15
			Своей системы реализации ЧПУ ссылок в Laravel нет, однако, можно осздать и свою. 

			Создание функционала оформления ЧПУ ссылки:
				1) Параметр post в URL'е-маршруте заменим на алиас:
					Route::any('/post/{post}',...); => Route::any('/post/{alias}',...);
				2) Замена ссылок на посты:
					Было:
						<a href="{{route('post', ['post' => $post])}}">ЧИТАТЬ ПОЛНОСТЬЮ &gt;</a>
					Стало:
						<a href="{{route('post', ['alias' => $post->alias])}}">ЧИТАТЬ ПОЛНОСТЬЮ &gt;</a>
				3) Замена аргумента в методе вывода постов и присваивание:
					Было: 
						public function post(Post $post, Request $request) {
					Стало:
						public function post($alias, Request $request) {
							$post = Post::where('alias', $alias)->first();
				4) Проверка аргумента $alias на причастность к модели/таблице post:
					Без нее будет выдаваться ошибка, но не 404. 					
					Было: 
						public function post(Post $post, Request $request) {
					Стало:
						if (!$post) abort(404);
				5) Замена ссылок в контроллере:
					Было:
						$redirect = redirect()->route('post.comments', ['alias' => $post]);
					Стало:
						return redirect()->route('post.comments', ['alisas' => $post->alias]);

				Этого вполне достаточно. Но елси нужно добавить суффикс HTML, то он добавляется в URL в маршруте. 
		*/

		//!Урок 2: Вывод страницы 404
		/*
			Создадим страницу 404. 
			Эта система работает уже. Однако, не всех может устроть этот шаблон. 
			
			Создание шаблонов с ошибками:
				1) Сооздание папки с шаблонами ошибок errors
				2) Создание файла 404.blade.php
				3) Переносим в шаблон компанент страницы. 
				4) Добавим оповещение об отсутствии страници с кнопкой на главную страницу. 
					<div id="other">
					<h1>Страница не найдена</h1>
					<div id="pm">
						<p>К сожалению, запрошенная страница не существует</br>Проверьте правильность ввода адреса.</p>
						<p><a href="{{route('index')}}">Вернуться на главную</a></p>
					</div>
				</div>
		*/

		//!Урок 3: Подведение итогов
		/*
			На созданном сайте имеются вывод страниц, пагинация, валидация, поиск, формы, рекапчи. 
			Если писать подобный проект с нуля на нативном языке - это не на долго.
			С фреймворком же набедакурить сложнее - в нем уже выстроны процессы создания и пользования функционала сайта. 
			Для дальнейшего продвижения и обучения нужно создавать проекты обращаясь к документации, вспоминая пройденные уроки. 
		*/


