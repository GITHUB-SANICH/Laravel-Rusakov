
	<?php

use function Termwind\style;

	echo '<hr><hr><br><h2>Модуль №15.15-19:  Модель</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #15.1-2 - Создание модели, Фабрика (День 15)</h3><hr><hr>' . "<br>";
		//!Урок 1: Создание модели
		/*

		В Laravel используется ORM библиотека Eloquent: Getting Started, позволяющая не писать нативный запрос к базе. Это подходит к небольшим проектам. Библиотека делает запосы объекто ориентированными.
			TODO ЗАМЕТКА: библиотека производит отображение реляционную модель в объектную модель таблицы и обратно. 
				Т.е. Eloquent преобращует строку в таблице в объект и обратно. 

		МОДЕЛЬ - это класс объект которого взаимодействует с конкретной таблицей в БД.
			TODO ЗАМЕТКА: Чаще всего на практике запросы пишутся с использованием моедлей, а не составление SQL запросов и QueryBuilder'ы, как в прошлых уроках. 
				Т.е. обращения к определенной таблице осуществляется через определенную модель.

		
		При создании модели - может создается миграция на основе которой создается таблица. 
		Миграция опишит таблюцу внутри БД, а модель будет исполнять функционал связанный с таблицей под которую создавался. 
		Команда создания модели:
			Пример: 
			php artisan make:model Post -msc
			где, 
				php artisan				- обращение к помошнику
				make:model				- команда создания модели 
				Article					- название модели
				-m							- опция создания миграции при создании таблицы 
				-s							- опция создания сидера для наполения таблицы
				-с							- опция создания контроллера
				-f							- опция создания фабрики
				"m", "с", "f" и "s" могут выводиться по одиночки и в любом порядке.
				TODO ЗАМЕТКА: Чаще в опциях прописываются миграция, сидер, фабрика - без контроллера => "php artisan make:model Post -msf"

				В каждой созданой моделе появляется трейт, вызывающий фабрику.
				Пример:
					use HasFactory;

				TODO ЗАМЕТКА: в отличии от моделей фреймворка Django - в моделях Laravel не фигурируют ни таблицы, ни типы полей - для этого создаются миграции.
				TODO ЗАМЕТКА: При создании модели - создается таблица с названием модели во множественном числе. Пример: "Article" = "articles".
					
				ВАЖНЫЕ ЗАМЕТКИ ПО РАБОТЕ С МОДЕЛЬЮ/ТАБЛИЦЕЙ/МИГРАЦИЕЙ
				ИЗМЕНЕНИЕ НАЗВАНИЯ ТАБЛИЦЫ, ПРИВЯЗАННЙО К МОДЕЛИ
					Если сгенерированное название таблицы не подходит - его можно изменить в миграции, но так же в моделе нужно будет добавить поле с название таблицы, к которой она будет привязываться "protected $table = 'nameTable';".
					
				ОТКЛЮЧЕНИ ПОЛЕЙ С ДАТОЙ СОЗДАНИЯ И РЕДАКТИРОВАНИЯ
					Если в таблице не нужны поля создания и редактирования поля, то настройка "$table->timestamps();" комментрируется в миграции, а в моделе создается поле, отключающее этот функционал от таблицы во избежании ошибок. "public $timestamps = false;" 

				ИЗМЕНЕНИЕ ПЕРВИЧНОГО КЛЮЧА
					а) Для изменения первичного ключав моделе прописывается поле, указывающее его "protected $primaryKey = 'alias';".
					б) Для указания типа поля первичного ключа (н.п. если он хранит не числа) прописывается поле "protected $keyType = 'string';". 

				ЗНАЧЕНИЯ ПО-УМОЛЧАНИЮ В ТАБЛИЦЕ
					Значения по-умолчанию в таблцие можно указывать в миграции, но так же и в моделе и это удобнее. 
					Пример:
						protected $attributes = [
							'title' => 'newPost',
							'is_publish' => false
						];
		*/

		//!Урок 2: Фабрика
		/*
			Фабрика - это инструмент заполнения таблциы данными, используемый в сидере, делающий его удобнее. 
			Фабрика удачно сочитается с использованием библиотеке "facker", генерирующуй случайные данные. 
			Папка с фабриками:
				"database\factories\"
			Команда создания фабрики.
				Пример:
					php artisan make:factory PostFactory
						или
					php artisan make:model Post --factory / -f
						где,
							PostFactory - назвение фабрики
							--factory / -f - опции создания фабрики

			В созданной фабрике имеется только метод "definition()", возвратщающая массив данных для создаваемого объекта/модели.
			Фабрика имеет возможность генерации даных случайным образом через обращение к библиотеке "facker".
				Пример:
					return [
						'author' => $this->faker->name(),
						'title' => $this->faker->text(mt_rand(10, 30)), //генерация случайного колличества символов от 10 до 30
						'is_publish' => mt_rand(1, 2) == 1 //рандомный вывод числа, при котором 1 == true
					];

			TODO ЗАМЕТКА: объект "faker" доступен в фабрики по-умолчанию. Т.е. его подключать не нужно.  
			TODO ЗАМЕТКА: поля "created_at" и "updated_at" не заполняются, так как используется фабрика. 
			TODO ЗАМЕТКА: Ссылка на библиотеку "faker" "https://github.com/fzaninotto/Faker" с примерами использования методов объекта. 

			ВЫЗОВ ФАБРИКИ В СИДЕРЕ
				Для вызова фабрики модели ее нужно привязать к сидуру (модель), пространство имен.
				Пример прописи пространства имен модели в сидере:
					use App\Models\Post;
				TODO ЗАМЕТКА: Так как в моделе прописан трейт "HasFactory", связывающий ее с фабрикой - фабрика сама понимает, с какой моделью она связана. Так что достаточно привязки к сидеру только моедли, так как через сидер она наследует функционал нужной фабрики. 
				Пример обращения в сидере к фабрике чреез модель:
					public function run(): void
					{
						POST::factory()->count(10)->create();
					}
					где,
						POST - модель, к которой привязана фабрика
						factory() - метод вызова фабрики. Доступен модели через трейт "HasFactory".
						count() - метод, указывающий количество создаваемых записей/объектов. Аргументом является число. 
						create() - метод, записывающий значения созданных объектов в БД. 
					
					TODO ВАЖНО! Не забываем подключать к зупускающемуся по-умолчанию сидеру "DatabaseSeeder" в методе call([]) запускаемый сидер в примере "PostSeeder".

					Для сравнения ниже код напоняения таблицы без фабрики:
						$names = ['Freed', 'Helga', 'Nicolas', 'Василий', 'Григорий'];
						for ($i=0; $i < 200; $i++) { 
							$post_id = mt_rand(1, 10);
							$name = Arr::random($names); //хелпер, работы с массивом (метод "random" выбирает случайны элемент). 
							$text = Str::random(mt_rand(30, 100)); //хелпер, генерации текста (метод "random" выбирает одно из предложенных значений). 
							$created_at = date('Y-m-d H:i:s');
							$updated_at = $created_at;

							2-й способ передачи данных в таблицу
							DB::table('comments')->insert([
								'post_id' => $post_id, 
								'name' => $name, 
								'text' => $text, 
								'created_at' => $created_at, 
								'updated_at' => $updated_at
							]);
						}

					И код фабрики + сидера:
					return [
						'author' => $this->faker->name(),
						'title' => $this->faker->text(mt_rand(10, 30)), //генерация случайного колличества символов от 10 до 30
						'is_publish' => mt_rand(1, 2) == 1 //рандомный вывод числа, при котором 1 == true
					];
					POST::factory()->count(10)->create();
		*/

	echo '<hr><hr><br><h3>Laravel - #16.1-1 - Работа с моделями (День 16)</h3><hr><hr>' . "<br>";
		//!Урок 1: Работа с моделями
		/*
			РАБОТА В БД ЧЕРЕЗ МОДЕЛЬ
				Для начала работы с моделью талицы - ее нужно подключить. 
				Пример подключения модели к контроллеру:
					use App\Models\Post;

				СПОСОБЫ СОЗДАНИЯ ЗАПИСЕЙ В БД
					1) Объявление объекта модели
						Пример:
							$post = new Post();
							$post->author = 'Федор';
							$post->title = 'новый пост';
							$post->is_publish = false;
							$post->save();
							где,
								$post - объект модели
								author/title - название полей таблицы  
								save() - метод занесения записи в таблицу
								
					2) Использование фабрики модели
						Пример:
							$post = Post::factory()->make();
							echo '2-й способ записи: '.$post->author; //вывод поля со случайным значением
							$post->title = 'Добавленный пост';
							$post->save();
						TODO ЗАМЕТКА: $post->author - поле, генерирующее случайное значение каждый раз при обращении, потому, что выводится через фабрику.

					4) Изменения полей в таблице
						Пример:
							$post = Post::create(['author' => 'Ванек', 'is_publish' => true]); 
						TODO Заметка: метод create() не только создаст объект на основе добавленной записи, но и сразу добавит ее в БД. 
						НО такая запись выдаст ошибку: Add [author] to fillable property to allow mass assignment on [App\Models\Post]. 
							Что значит поле не добавлено в массив "fillable" в моделе. 
						TODO ВАЖНО! $fillable - это массив полей, значения которых можно изменять в таблице, и которые можно записывать в БД через фабрику. При попытки изменить поля, незаписанные в массиве $fillable - вывдится ошибка. Этот массив безопасных полей, созданный для ограждения запросов затрагивающих БД в целях безопасности. 
						//Этим полям можно устанавливать значения по-умолчанию.
						TODO ВАЖН!О Для в случаи заполненного в модели массива $fillable - в фабрике тоже должны быть указаны поля из этого масива, чтобы фабрике было разрешенол их обновлять.
						Пример заполнения массива:
							В моделе:
							protected $fillable = [
								'name',
								'email',
								'password',
							];
							
					ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ МОДЕЛИ И СПОСОБЫ ПОСТРАЕНИЯ ЗАПРОСА
						Принцип построения запросов через модель аналогичен принципе построение запросов через QueryBuilder'ы. 
						Но вместо фассада DB будет подставляться модель. 

						Методы вывода
						1) find(); Метод заносит в коллекцию строку с заданным Id для вывода.
							Аргументом являтся число Id выводимой строки.
							Пример:
								$post = Post::find(5);
								echo 'Вывод поля строки: "'.$post->title.'"<br>';

						2) findOrFail(); Аналог метода find(), но при отсутствии вносимого аргумента (Id) выдает ошибку 404.
							Пример:
								$post = Post::find(5);
								echo 'Вывод поля строки: "'.$post->title.'"<br>';

						3) all(); Метод заносит в коллекцию все строки таблицы.
							Аргументом являтся число Id выводимой строки.
							Пример:
								foreach (Post::all() as $post) {
									echo 'Вывод всех значений выбранного поля объекта: "'.$post->title.'"<br>';
								}

						Методы проверки на наличие изменений в объекте:
						4) ->isClean(); Метод проверяет модель на изменения после ее извлечения (после объявления объекта модели). 
							Возвратщает булево значение. True - если изменения не происходили. False - если происходили.
							Аргументом может выступать конкретное поле объекта. Т.е. изменялось либо конкретное поле. 
							Пример:
								echo 'Проверка объекта на изменения через "isClean()" '.$post->isClean().'<br>';
								echo 'Проверка объекта на изменения через "isClean()" '.$post->isClean('title').'<br>';

						5) ->isDirty(); Аналог метода "->isClean()", но при изменении объекта возвратщает True.
						Аргументом может выступать конкретное поле объекта.
							Пример:
								echo 'Проверка объекта на изменения через "isDirty()" '.$post->isDirty().'<br>';

						Метод сортировки:
						6) ->reject(); (отвержение) Метод исключает параметры из коллекции перед выводом объекта. Т.е. является фильтром.
							Это может потребоваться, когда в определеннй момент выполенния некоторые параметры для вывода больше не требуются, а создание нового запроса даст лишнюю нагрузку на БД.
							Аргументмо является callback функция, у которой аргументом является объект-коллекция. В теле замыкания прописывается поле с исключаемым значением.
								Пример испоьзования метода:
									$posts = Post::all();
									$posts = $posts->reject(function($posts){
										return $posts->author == 'Eladio Thiel';
									});
									foreach ($posts as $post) {
										echo 'Вывод всех значений поля объекта: "'.$post->author.'"<br>';
									}

						Меотды экономии оперативки:
						7) ->chunk(); Метод экономит оперативку, но и опционально загружает БД.
							Аргументмо первым аргументои является количество записей в одной мини-коллекции, вторым замыкание с аргументом дробимой коллекцией.
							В теле замыкания цикл с выводом мини-коллекции. 
								Пример испоьзования метода:
									Post::where('is_publish', 0)->chunk(3, function($posts){
										foreach ($posts as $post) {
											echo $post->author.'<br>';
										}echo '.............<br>';
									});

						8) ->cursor(); Аналог метода chunk(), но выводящий только одну запись == chunk(1, function($collection){...}). 
							Метод максимально экономит оперативку, но максимально нагружает БД. Так как обращения к ней идут после каждой записи.
								Пример испоьзования метода:
									foreach (Post::where('is_publish', 0)->cursor() as $post){
										echo $post->title.'<br>.............<br>';
									}

						Меотд обновления:
						9) ->update();
							Пример испоьзования метода:
								Post::where('id', '<', 5)->update(['is_publish' => 1]);

						Методы удаления:
						10) ->delete(); Метод удаления записи , указанной в выборке. 
							Пример испоьзования метода:
								Post::find(11)->delete();

						11) ->destroy(); Аналог метода delete(), но не требующий предварительной выборки
							Меод может принимать аргументы в виде номера Id (либо массива с Id) удаляемой записи без необходимости выборки.
							Пример испоьзования метода:
								Post::destroy(11); //удаление одной записи
								Post::destroy([5, 8, 9]); //удаление множества записей
						TODO ЗАМЕТКА: в случаи попытки удаления несуществующей записи - ошибка не выдается. 

						12) withTrashed(); Метод вывода записей, удаленных через мягкое удаление. 
							Пример испоьзования метода:
								$posts = Post::withTrashed()->get();
									ИЛИ
								$posts = Post::withTrashed()->where('id', '<', 5)->get();
									foreach ($posts as $post) {
										echo $post->author.'<br>^^^^^^^^^^^^^^<br>';
									}

				МЯГКОЕ УДАЛЕНИЕ/ФЕЙКОВОЕ УДАЛЕНИЕ
					МЯГКОЕУ ДАЛЕНИЕ - функционал позволяющий удалять записи буз полного ее стирания из БД, вешая пометку даты удаления записи. 
					Бывыют ситуации, когда нужно чтобы какая то запись не отображалась на сайте, однако, полное удаление остается весьма нежелательным. 
					В таком случаи проктикуется "мягкое удаление". 
					
					Для ввода возможности мягкого удаления требуется подключение трейта к модели:
					Подключени: 
							use Illuminate\Database\Eloquent\SoftDeletes;
						Вызов трейта в моделе:
							use SoftDeletes;
						TODO ВАЖНО! Поделюченный трейт подразумевеет, что в таблице уже есть поле, вмещающее дату удаления записи.
									
					Создание поля с датой мягкого удаления в миграции:
					$table->softDeletes();
					Созданое поле в таблице после обонвления запуска миграции:
					deleted_at
					
					Теперь при удалении записи например "Post::destroy(11);" - она перестанет отображаться на сайте, но не удаляется из БД.
					В поле "deleted_at" заносится дата удаления записи. 

					TODO ЗАМЕТКА: наличии мягкого удаления подразумевает возможность автоматического удаления записи через определенныый срок. 
					

			*/

	echo '<hr><hr><br><h3>Laravel - #17.1-2 - Аксессоры и мутаторы, Наблюдатели/Observers (День 17)</h3><hr><hr>' . "<br>";
		//!Урок 1: Аксессоры и мутаторы
		/*
			АКСЕССОР
				Аксессоры - это механизм, получающий доступ к свойствам, перед их запросом во внешнем коде. Т.е. переде выдачей из БД. 
					ИЛИ
				Аксессор преобразует значение атрибута объекта Eloquent при обращении к нему. 
				Т.е при обращении к значению свойству через Eloquent - срабатывает "аксессор" - функция, которая преоразовывает значение перед выводом.

				Аксессор может быть полезен, когда изменения с значениями свойст нужно будет производить достаточно часто, без необходимости прописи опции изменений свойства в методе контроллера. 
				
				Например "аксессоры" позволяют приводить даты в определенный формат перед выводом. Или выводить имя автора статьи в верхнем регистре.

				TODO ЗАМЕТКА: Аксессор и мутатор пишутся в моделе через публичный метод.
				Правило прописи назхвания аксессора - префикс "get" + "название ловимого свойства" + суффикс "Attribute". 
				Поэтому название аксессору и мутаторам важно давать согласно конвенции имен Laravel.
					Пример записи кода аксессора:
					public function getAuthorAttribute($val){
						return mb_strtoupper($val);
					}
					где,
						getAuthorAttribute - название акссесора
						get - префикс акксессора
						Author - название ловомого свойства
						Attribute - свойство, указывающее что функция является аксессором
						$val - ловимое значение
						mb_strtoupper - метод преобразования текста в верхний регистр
				
					Пример записи кода вывода свойства:
						$post = Post::find();
						echo $post->author; == МАКСИМИЛИАН ЛОУ V

				Акссесор можно оставлять пустым, но тогда толка в нем немного.
				
			МЕТАТОР
				Мутаотор - преобразует полученные данные перед записью их в БД. 
				Т.е. аналог аксессора, только наоборот. 
				TODO ЗАМЕТКА: правило прописи названия мутатора аналогично правило аксессора заисключением префикса set вместо get. 
				Пример записи мутатора:
					public function setAuthorAttribute($val){
						$this->attributes['author'] = $val;
						$this->attributes['title'] = 'Текст поста изменен автором - '.$val;
					}
					где,
						setAuthorAttribute - название мутатора
						set - префикс мутатора
						$val - вночимое значение
						$this-> - указатель на поле внутри объекта
						attributes - массив с свойством изменяемого поля
						author/title - название изменяемых полей

				Пример записи кода записи свойства в БД:
					$post = Post::find();
					echo $post->author; == МАКСИМИЛИАН ЛОУ V
					$post->author = 'Новый автор';
					$post->save();
					echo 'Новое название атвора: '.$post->author;

			СПОСОБЫ СВЕДЕНИЯ ТИПОВ ДАННЫХ
				Частенько в полях БД подразщумевающих тип данных "Boolean" вмещают цифры 1 и 0, т.е. типами Integer. 
				На практике хотелось бы, чтобы подразумевающиеся типы данных в поля и действительные совпадали. 
				Для исправления этой ситуации есть два способа: через аксессор или 
				Оба способа прописываются в моделе. 

				1-й способ (аксессор):
					public function getIsPublishAttribute($value){
						return (bool) $value;
					}
				2-й способ (массив "$casts"):
					protected $casts = [
						'is_publish' => 'boolean',
					];
					где,
						protected - обязательное правило приватности массива
						$casts - название массива (обязательное) для хранения типов данных полей таблицы
						is_publish - название поля таблицы
						boolean - устанавливаемое значение поля таблицы

				TODO ЗАМЕТКА: способ прописи типа данных полей таблицы в массиве/поле модели $casts - считается наиболее удобным.
				Такая система используется в проектах часто, особенно при работе с датой и временем. 
			
		*/

		//!Урок 2: Наблюдатели/Observers
		/*
			Наблюдатель ИЛИ Observer - это реализованный патерн проектирования, позволяющий отслеживать объект, находящийся в другом объекте. 
				При этом наблюдаемый объект о наюлюдателе не будет ничего знать.
				Наблюдатель может пригодится например при необходимости оповещения людей при определенных событиях в моделе либо для логировнаия.
				Observer создается, когда на большинство методов модели напрашивается наличие событий. Это нужно для того, чтобы не плодить кучу событий-event'ов или лешнего смешивания логики во множесте функций взаимодействующих с моделью.

			Команда создания наблюдателя:
				php artisan make:observer --model:Post

			Команда создания Observer:
				php artisan make:observer CommentObserver --model=\App\Models\Comment
				где, 
					make:observer 						- создание обсервера
					PostObserver 						- название обсервера
					Post									- название модели, к которой создается наюлюдатель
					--model=\App\Models\Post 	- модель к которой пикрепляется обсервер 
						ИЛИ
					--model=Post
				После создания класс появляется в папке "\app\Observers\PostObserver.php";				

			TODO ЗАМЕТКА: Наблюдатель имеет список функций, привязаных к CRUD операциям модели. 

			Список функций в наблюдателе:
				1) created			- срабатывает при создани записи таблицы
				2) updated			- срабатывает при обновлении поля/записи
				3) deleted			- срабатывает при удалении записи
				4) restored			- срабатывает при восстановлении записи после удаления (мягкого удаления)
				5) forceDeleted	- срабатывает при безвозвратном удалении записи

			TODO ВАЖНО! Чтобы наблюдатель заработал, помимо создания нужно привязать его к моделе в провайдере "app\Providers\EventServiceProvider.php".
				
			Привязка наблюдателя к модели:
				Привязка наблюдателя и модели производится в файле "app\Providers\EventServiceProvider.php" в методе "boot()".
				Предварительно к провайдеру нужно подключить и наблюдателя и модель:
					use App\Models\Post;
					use App\Observers\PostObserver;
				
				Пример подключения наблюдателя к моделе:
					public function boot(): void
					{
						Post::observe(PostObserver::class);
					}	
					
				Теперь при обновлении записи - сработает наблюдатель.
				Код в контроллере:
					$post = Post::factory()->make();
					$post->title = 'Пост создан чреез testObserver';
					$post->save();
				Код в наблюдателе:
					public function updated(Post $post): void
					{
						echo 'Запись наблюдателя: запись с ID == '.$post->id.' обнавлена.<br>';  == Запись наблюдателя: запись с ID == 11 создано.				
					}
				
			*/

	echo '<hr><hr><br><h3>Laravel - #18.1-2 - Отношение один к одному, Отношение один ко многим (День 18)</h3><hr><hr>' . "<br>";
		//!Урок 1: Отношение один к одному
		/*
			СОЗДАНИЕ МОДЕЛЕЙ И ИХ НАПОЛНЕНИЕ
				Для комбинированного вывода данных из несокльких таблиц - вместо оператора JOIN в Eloquent используются отношения между моделями. 
				Отношение выражается в соотношении информации таблиц моделей. Это делается во избежании раздувания размера таблиц.
				Например, когда через статью автора нужно определить время регистрации, авторизации, почту UTM-метки и т.д.
				В этом уроке разберем отношение "один к одному", а в следующем "один ко многим" затем и "многие ко многием".
				
				Содадим таблицы с клиентами и адресами c "один к одному/belongsTo" + миграции/фабрики/сидеры.
					php artisan make:model Client -msf
					php artisan make:model Address -msf
				
					В миграции адресов пропишем str адрес. В миграции клиентов str имя клиента, int address_id. 
					TODO ЗАМЕТКА: можно назвать поле с ID адреса и по другому (без суффикса _id), но потом в отношении моделей будет нужно указать это поле.

				В фабрике для таблиц создаем фейкеры:
					'adress' => $this->faker->address(); //Address
					'name' => $this->faker->name(), //Clients
					'address_id' => 'address_id' =>$this->faker->unique()->randomElement(range(1, 10))
					где,
						unique() - метод, генерирующий значение из массива, которое не будет повторяться
						randomElement() - метод выбирающий случайный элемент
						range() - функция генерирующая массив с числами от первого аргумента до второго
					Так как мы собираемся создавать таблицу, в которой адреса у клиентом не повторяются - мы прописали их уникальными. 	
					TODO ВАЖНО!: шаг генерации с уникальными значениями должен соответстовать количеству генерируемых записей в таблице. Иначе ошибка. 
						
				Прикрепляем к каждому сидуру свою фабрику:
					Address::factory()->count(10)->create();
					Client::factory()->count(10)->create();
				Подключаем созданные сидеры к главному сидеру:
					$this->call([...
						AddressSeeder::class, 
						ClientSeeder::class, 
					]);
				Запускаем миграции:
					php artisan migrate:fresh --seed

				Создаем контроллер с подключением к созданным моделям и можно начинать прописывать отношения в моделях. 
				
			НАСТРОЙКА ОТНОШЕНИй МЕЖДУ МОДЕЛЯМИ
				В модели с клиентами уже есть Id поля адресс. Через это поле и отношения моделей получим доступ к адресам. 
				Так как мы пропишем, что  у одного клиента может быть один адрес, то пропишем сявзь один к одному. 
				Отношение прописываются в функции моделе именем которой явялется имя таблицы, с которой прописываются отношения.
				
				Пример связи моделей Client и Address по схеме "один к одному":
					public function address(){
						return $this->belongsTo(Address::class);
					}
					где, 
						belongsTo				- метод указывающий ссылку по типу "один к одному"
						Address	- модель, с которой устанавливается связи и берется информация

				Пример связи моделей Address и Client по схеме "один к одному":
					public function client(){
						return $this->hasOne(Client::class);
					}

				TODO ЗАМЕТКА: методы отношений "belongsTo" и "hasOne" идентичны - просто имеют разные названия.

				TODO ВАЖНО! В примере выше Eloquent будет искать связь между address_id в модели Clients и id в модели Address. По умолчанию Eloquent определяет имя внешнего ключа по имени метода отношения, добавляя суффикс _id. Однако, если имя внешнего ключа модели Phone не address_id, передайте это имя вторым параметром в метод belongsTo():

				TODO ЗАМЕТКА: Как и для метода hasOne()/belongsTo() вы можете указать внешний и локальный ключи, передав дополнительные параметры в метод hasMany():
				
				При этом в связях "один к одному/один ко многим" первым выступает модуль в котором прописывается связь, в вторым число возможных связей.  
				Если у модуля User, прописывается сввязь например с кооментариями или статьями, то и в первом и во втором случаях это связи "один ко многим", так как у одного пользователя может быть мнодество статей и множество комментариев.
				А у одного комментария один автор и одна статья.  

				Когда связи установлены можно выводить информацию в статьях. 
				TODO ВАЖНО! При наличии отношений между моделями - тип передачи данных в шаблона чреез класс "DB" будет выдавать ошибку: поэтому при наличии этих отношений передавать информацию в шаблон через модель.
						Пример:
							Вариант с ошибкой:	$articles = DB::select('SELECT * FROM articles');
							Вариант без ошибки:	$articles	= Article::all();

				ВЫВОД ЗАПСИЕЙ
					Вывод записи адреса клиента в контроллере:
						$client = Client::find(1);
								echo 'Вывод имени клиента: '.$client->name;
								echo 'Вывод адреса клиента: '.$client->address->address;
						}
						где,
							$client->name - вывод имени клиента
							$client->address->address - вывод адреса клиента
							->address-> - название модели, привязанной к таблице "addresses"
							->address - название выводимого поля, к которому обращается $client
								Вывод имени клиента: Афанасьева Иммануил Дмитриевич
								Вывод адреса клиента: 494438, Магаданская область, город Москва, проезд Славы, 15
					
					Вывод записи клиента из таблицы с адресами в контроллере:
						
		*/

		//!Урок 2: Отношение один ко многим
		/*
			Отношение таблиц один ко многим подразумевает, что у одного элемента может быть множество связей с полем другой таблицы. 
			Например у одного автора клиента может быть множество заказов, в то время как у одного заказа может быть только один клиент.

			СОЗДАНИЕ МОДЕЛЕЙ И ИХ НАПОЛНЕНИЕ	
				php artisan make:model Order -msf - модель с заказами

				В миграции добавим поле с  Id клиента:
					$table->integer('client_id');
				В фабрике добавим пропишем его наполнение:
					'client_id' => mt_rand(1, 10) //так как у таблицы будет связь один ко многием, то уникальные значения полю ник чему
				
			НАСТРОЙКА ОТНОШЕНИй МЕЖДУ МОДЕЛЯМИ
				Отношения модели Order к Client
					public function client(){
						$this->belongsTo(Client::class); 
					}

				Отношения модели Client к Order
					public function orders(){
						return $this->hasMany(Order::class);
					}

				TODO ВАЖНО! Так как у клиента большое колличество заказов в при отношении один ко многим - в моделе прописывается множественное число таблицы: "orders", а не "order" если бы отношение было один к одному.

			ВЫВОД ЗАПИСЕЙ
				Вывод заказов клиента:
					$orders = Client::find(1)->orders;
					foreach ($orders as $order) {
						echo 'Вывод номера Id заказа клиента: '.$order->id.'<br>';
					}
				TODO ЗАМЕТКА: здесь так же указывается мнодественное число заказов, так как у клиента их много => "Client::find(1)->orders". 

				Вывод клиента заказа:
				$clien = Order::find(1)->client;
					echo 'Вывод клиента заказа: '.$clien->name.'<br>';
		*/

	echo '<hr><hr><br><h3>Laravel - #19.1-2 - Отношение многие ко многим, Ресурсный контроллер (День 19)</h3><hr><hr>' . "<br>";
		//!Урок 1: Отношение многие ко многим
		/*
		Отношения "многие ко многим" более сложное, но оно менее распрастранено. 
		Этот тип может пригодится в ситуации например, когда у множества заказав может быть множество товаров и у множества товаров может находиться в множестве заказов. 
				Т.е. заказ и товар жестко не привязаны друг к другу. 
				Т.е. и заказ может ссылаться на множество вмещаемых им товаров, так и товар на множество заказов, в которых сам находится.
				
				СОЗДАНИЕ МОДЕЛЕЙ И ИХ НАПОЛНЕНИЕ	
				Таблицы с заказами уже имеется - создадим таблицу с товарами:
					php artisan make:model Product -msf
					И создаем дополнительно модель-посредника между моделями с отношением "многие ко многим".
					php artisan make:model OrderProduct -msf
					
					Так как в таблице с товарами нельзя в одном поле указать множество заказов (order_id), как и в таблице заказов множество товаров (product_id), то создается 3-я таблица, которая будет посредником между таблицами со связью "многие ко многим". 
					TODO ВАЖНО! В отличии от прочих отношений - отношение "многие ко многим" подразумевает наличие 3-й таблицы-посредника между двумя первыми. 
					
					Создание 3-й модели-посредника:
						php artisan make:model OrderProduct -msf	

				TODO ВАЖНО! Модель 3-й таблицы создается из имен 1-й (Order) и 2-й (Prodect) моделей => php artisan make:model OrderProduct -msf	
					
				TODO ВАЖНО! Миграция задала названию таблицы-посредника во множественное число. Название должно содержать имя таблиц с отношением "многие ко многим" в единственном числе. 1-я тб. == "orders", 2-й тб. = "products", 3-я т.б = "order_product".
				
				TODO ВАЖНО! Так как название таблицы от предложенного миграцией изменено с множественного на единственное число, то в поле модели  "protected $table" нужно вписать желаемое название таблицы, котоыре было переправлено у миграции.
				
				Наполнение моделей:
				Product:
					$table->string('title', 255); -> Product
				OrderProduct:
					$table->integer('order_id');
					$table->integer('prodect_id');
				
				Переименуем в методе create() название таблицы с "order_products" на "order_product".

				Наполнение фабрик:
					Product:
						'title' => $this->faker->company() //допустим, продаются компании										
					OrderProduct:
						'order_id' => mt_rand(1, 30), //по числу записей в таблице заказов
						'product_id' => mt_rand(1, 10) //по числу товаров

				Наполнение сидов:
					Product:
						Product::factory()->count(10)->create();
					OrderProduct:
						OrderProduct::factory()->count(100)->create();

					Полключаем созданные сидеры к "database\seeders\DatabaseSeeder.php".


			НАСТРОЙКА ОТНОШЕНИй МЕЖДУ МОДЕЛЯМИ
				TODO ВАЖНО! Методы в моделях, содержащих связь с другими моделями - прописываются во множественном числе при связи "МКМ". 
				Отношения, прописываемые в моделях:
					Order:
						public function products(){
							return $this->belongsToMany(Product::class); 
						}
					Product:
						public function orders(){
							return $this->belongsToMany(Order::class); 
						}
					OrderProduct:
					
				TODO ЗАМЕТКА: Связь "многие ко многим" устанавливают метды "belongsToMany" и "hasMany" - они идентичны, но ставятся в разных связаннх моедлях.
			
			ВЫВОД ЗАПИСЕЙ
			TODO ЗАМЕТКА: в запросе моделей "МКМ" завершающая часть запроса должны быть в во множжетвенном числе: "->prodects/->orders".
				Вывод номера товара, где Id заказа = 1:
					$products = Order::find(1)->prodects;
					foreach ($products as $product) {
						echo 'Товар из заказа'.$product->title;
					}
				Вывод номера заказа, где Id товара = 1:
					$orders = Product::find(1)->orders;
					foreach ($orders as $order) {
						echo 'Вывод номера Id заказа, у которого товар имеет Id = 1: '.$order->id.'<br>';
					}

			ОСОБЕНОСТИ НАСТРОЙКИ ОТНОШЕНИЙ "МНОГИЕ КО МНОГИМ"
				1) Построение таблис с отношением "многие ко многием" подразумевает создание 3-й таблицы - посредника.
				2) Название созданной таблицы-посредника должно состоять из название 1-й и 2-й моделей в единственном числе => "order_product". 
				3) В созданное таблице должны находиться поля, указвающие на Id 1-й и 2-й таблиц: "order_id", "product_id".
				4) Название создаваемой таблицы-посредника должно быть в единственом числе: "order_product".
				5) Измененое название таблицы, отличное от варианта миграции - заносится в модель-посредник: protected $table = 'order_product';

		*/

		//!Урок 2: Ресурсный контроллер 
		/*
			Ресурсный контроллер (РК/ресурс) - контроллер направленный на обработку CRUD-операций определенной модели. 
			Обычно создается вместе с формой. 
			Пример создания РК:
				1-й способы создания ресурса:
					php artisan make:controller AddressController --resource --model=Address
				где,
					--resource - дополнительный атребут добавляющий контроллеру свое правило маршрутизации типа "resource". 
					--model - атребут, указывающий на модель к которой прикрепляется РК.

					Методы содержащиеся в РК:
						1) index()		- отвечает за вывод всех элемнетов
						2) create()		- выводит форму на создание/добавление
						3) store()		- принимает запрос от заполненой формы
						4) show()		- выводит передаваемую запись
						5) edit()		- открывает форму для редактирования записи
						6) update()		- обработка обновленной записи, отправленной из формы
						7) destroy()	- удаление записи (принимает только запросы на удаление)
			
				ПРАВИЛО МАРШРУТИЗАЦИИ ДЛЯ РК
					Для каждого метода можно создать вручную свое правило маршрутизации, но для ресурса есть запись, вмещающая все нужные методы.
					Добавим одно правило маршрутизации в файл "web".
					Пример:
						"Route::resource('addresses', App\Http\Controllers\AddressController::class);"
							где,
								resource - подразумевает множество правил маршрутизации
								addresses - ссылка на вызов ресурса
								TODO ЗАМЕТКА: методы, реагирующие на: GET запроc => index, show, edit; POST => store; PUT/PATCH => update; DELETE => destroy;
								TODO ЗАМЕТКА: по-умолчанию ссылка ведет на метод "index". Аргументом ссылки могут выступать методы РК, передаваемые GET методом.
									Методы show, edit подразумевают наличие аргумента:
										1) index: addresses/
										2) show: addresses/1
										3) edit: addresses/1/edit
										где,
											1 - Id, выводимой записи
											1/edit - Id редактируемой записи
								
						Данное правило маршрутизации вмещает в себя мноожество HTTP методов и методов созданного ресурса.

				ОТСЛЕЖИВАНИ ПРАВИЛА МАРШРУТИЗАЦИИ
					Чтобы отсделить созданное правило маршрутизации в проекте - пропишем команду: 
						TODO ЗАМЕТКА: php artisan route:list - команда отображения правил маршрутизации в проекте 
						Для в "web" отображается информация о множестве правилах маршрутищации, хотя в файле была запись только о РК (Route::resource(...)) : 
							GET|HEAD        addresses ....................addresses.index › AddressController@index  
							POST            addresses ....................addresses.store › AddressController@store  
							GET|HEAD        addresses/create .............addresses.create › AddressController@create  
							GET|HEAD        addresses/{address} ..........addresses.show › AddressController@show  
							PUT|PATCH       addresses/{address} ..........addresses.update › AddressController@update  
							DELETE          addresses/{address} ..........addresses.destroy › AddressController@destroy
							GET|HEAD        addresses/{address}/edit......addresses.edit › AddressController@edit  
							
				ОБРАЩЕНИЕ К РК ЗА ШАБЛОНОМ
					Код в контроллере:
						index:	
							return view('addresses.index', ['addresses' => Address::all()]);
						show:
							return view('addresses.show', ['address' => $address]);
						edit:
							return 'Показать форму для редактирования адреса: '.$address->address; Открывается по сыслке "addresses/ID/edit"

					Создадим шаблонs, которые будут выводиться в зависимости об обращения к ресурсу: index/show.
					index:
						<ul>
							@foreach ($addresses as $address)
								<li><a href="{{ route('addresses.show', ['address' => $address]) }}">{{$address->address}}</a></li>
							@endforeach
						</ul>
						где,	
							addresses.show - ссылка на адрес
							$address->address - названеи адреса
							['address' => $address] - псевданим аргумента и аргумент, передаваемые по ссылке							
		*/
