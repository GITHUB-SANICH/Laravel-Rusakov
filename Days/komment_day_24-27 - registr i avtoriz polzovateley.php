
	<?php

use function Termwind\style;

	echo '<hr><hr><br><h2>Модуль №24.24-27:  Регистрация и авторизация пользователей</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #24.1-2 - Установка Laravel Breeze, Регистрация пользователей (День 24)</h3><hr><hr>' . "<br>";
		//!Урок 1: Установка Laravel Breeze
		/*
			В ходе урока установим библиотку "Breeze". Она нужна для авторизации/регистрации пользователй. Это более безопасный вариант, когда авторизация пишется с нуля.
			Это сложная задача, которая в бОльшей части решает данная библиотека.
			Команда подключения библиотеки:
				composer require laravel/breeze --dev
			Команда запуска библиотеки:
				php artisan breeze:install
				Далее в ходе установки будут предлагаться разные настройки - согашаемся на только на blade.
			TODO ВАЖНО! Установка библиотеки "Breeze" перетирает существующий файл "web.php"/папку "routes" на прилагаемый из коробки библиотеки.
			TODO ЗАМЕТКА: Breeze позволяет из коробки создать каркас вашего приложения с помощью Vue или React и инерции - одностраничные приложения без создания API.
			TODO ЗАМЕТКА: Стек "Breeze" по умолчанию - это стек Blade, который использует простые шаблоны Blade для визуализации интерфейса вашего приложения.
			TODO ЗАМЕТКА: Установка библиотеки "Breeze" вместе с собой подразумевает установку CSS фреймворка "Tailwind", задающий стиль шаблонам.
			
			Наполним БД фейковыми данными и переходим к следующему уроку:
				1) Перепишем ссылку проекта в "env": APP_URL=http://127.0.0.1:8000
				2) Создадим новыую БД: laravel_Rusakov_2
				3) Создаем сидер: php artisan make:seeder UserSeeder
				4) Записываем в нем: User::factory()->count(10)->create();
				5) Миграция: php artisan migrate:fresh --seed
				6) Меняем локализацию для фейковых данных в "24-40\config\app.php": 'faker_locale' => 'ru_RU'
				7) В фабрике: $this->call([UserSeeder::class,]);

			В подключенной библиотеке имеются свои маршруты, контроллеры , шаблоны.
			Дитали работы библиотеки будем разобраны в рамках проходимого раздела.
		*/

		//!Урок 2: Регистрация пользователей
		/*
			В этом уроке не будем ничего писать, а просто ознакомимся с компанентами, кодом, в целом как происходит регистрация пользователя в библиотекее "Breeze".

			Файл routes\auth.php: 
				Route::middleware('guest')->group(function () {
					Route::get('register', [RegisteredUserController::class, 'create'])->name('register');
				где,	
					middleware('guest') - посредник, запускающий редирект для авторзованных пользователей

			Шаблон resources\views\auth\register.blade.php вмешает в себе компанент => resources\views\layouts\guest.blade.php
				Этот компанент - шаблон для неавторизованных пользователей. 
					{{ $slot }} - метка в шаблоне для гостей, в которую вставляется слот из шаблона "resources\views\auth\register.blade.php"

			Файл "\lang\en.json"
				Имеет набор атребутов, переводимый в локализации. Компаненты имеют ссылки на названия этих атребутов и переводятся в зависимо от локализации. 
					TODO ЗАМЕТКА: файл "en.json" вмеащет себя атребут и их перевод в зависимости от локализации. Ссылка на атребут в коде: __('Name').

			event(new Registered($user)); - событие уведомляющее о том, что но пользователь зарегистрирован. События еще будем разбирать. 

			return redirect(RouteServiceProvider::HOME); - редирект на страницу => public const HOME = '/dashboard';

		*/

	echo '<hr><hr><br><h3>Laravel - #25.1-2 - Подтверждение e-mail, Авторизация пользователей (День 25)</h3><hr><hr>' . "<br>";
		//!Урок 1: Подтверждение e-mail
		/*
			В этом уроке не будем практически ничего писать, но добавим в систему регистрации необходимость подтвержение e-mail'а. 
			
			НАСТРОЙКА SMTP сервера
				Так как мы пользуем локальынй сервер, то SMTP сервера у нас нет - пропишем адрес отправки собщения в лог-файл. 
					1) Настрока в файле .env: 
						а) MAIL_MAILER=smtp => MAIL_MAILER=log
						б) MAIL_FROM_ADDRESS="hello@example.com"
						Схема отправки писем еще будет изучаться, но пока достаточно и этого. 
						а) Запись 
						б) Получатель 
					2) Настройка модели пользователя:
						Имплементируем интерефейс/контракт к моделе и подключем его:
							implements MustVerifyEmail
					3) Добавление посредника/midllwar'а в маршруты, проверяющий подтверждение почты:
							Route::middleware(['auth', 'verified'])->group(function () { ... } .
							Это Laravel'ский посредник - его использовение не требует наличия библиотеки. 

				КОНТРОЛЛЕРЫ БИБЛИОТЕКИ ОТВЕЧАЮЩИЕ ЗА ПРОВЕРКУ ПОЧТЫ
					1) EmailVerificationPromptController - проверяет верификацию почты и выдает нужный шаблон
							redirect()->intended(RouteServiceProvider::HOME)
							Метод "intended" означаент, что пользователь редиректится на страницу HOME, если до редиректа у него не было прав на желаемую страницу. 
							Если права на желаемую страницу были, то редиректится туда откуда турнули.
					2) EmailVerificationNotificationController - передает нужный шаблон в случаи прохода и не прохода проверки верификации почты. 
						В случаи не прохода верификации возвратщает обратно с переменной, помещенной в сессию: return back()->with('status', 'verification-link-sent');
					3) VerifyEmailController - 
						->middleware(['signed', 'throttle:6,1']) - требование подписи запроса + разрешение делать запрос 6 раз в минуту

				ИТОГО:
					ШАГИ ВЕРИФИКАЦИИ EMAIL
						1) Адрес записи сообщения в лог и отправка на указанную почту:
							Настрока в файле .env: 
								а) MAIL_MAILER=smtp => MAIL_MAILER=log
								б) MAIL_FROM_ADDRESS="hello@example.com"
						2) Подключение интерфейса "implements MustVerifyEmail" в модель User
						3) В случаи необходимости добавляем посредники проверки подтвержденной почты "verified" в маршруты. 
						4) Контроллеры:
							а) EmailVerificationPromptController - редиректит на шаблон в случаи отсутствия подтвержденного email
							б) EmailVerificationNotificationController - отправка формы подтверждения почты
							а) VerifyEmailController - проверка и верификация email
		*/

		//!Урок 2: Авторизация пользователей
		/*
			Познакомимся с механизмом авторизации билбиотеки "Breeze".

			Маршрут /login => AuthenticatedSessionController - отвечает за обработку запросов авторизации
			TODO ЗАМЕТКА: для авторизации понадобится почта, сегенерированная фабрикой + пароль, указанный в фабрике UserFactory. Пароль => "password". 

			При авторизации нас прекидывает в метод "store", у которого проввряются данные авторизации классом "Http\Requests\Auth\LoginRequest.php".
				В методе "authenticate" прописан функционал проверки колличества попыток входа, временная блокировка и вызов события в случаи превышения лимита.
				Его вызов в контроллере: $request->authenticate();
				Метод обновления сессии во избежания внемения в нее данных из вне во время авторизации: $request->session()->regenerate();
		*/

	echo '<hr><hr><br><h3>Laravel - #26.1-3 - Подтверждение пароля, Выход из системы, Восстановление пароля (День 26)</h3><hr><hr>' . "<br>";
		//!Урок 1: Подтверждение пароля
		/*
			Функциона подтверждения пароля в Laravel реализован за счет посредиков + шаблонов, предоставляемых библиотекой "Breeze".
			Создадим контроллер, выводящий запись, требующий авторизации и подтверждения пароля за счет посредника:
				Route::get('', function(){
					return 'send payment';
				})->middleware('password.confirm');
				где,
					password.confirm - посредник, подразумевающий авторизацию и требующий дальнейшего подтверждения пароля

				Сам посредник относится к Laravel.
				Однако в данном кейсе не обошлось без бриза: форма, кнопки, шаблон, выыводимые при проверки пароля - это производная библиотеки. 
				Библиотека реагирует на посредник "password.confirm" и выводит форму проверки пароля "confirm-password".
				Контроллер формы проверяет пароль авторизованного пользователя и допускает при совпадении пароля, записывая данные авторзации в сессию.
		*/

		//!Урок 2: Выход из системы
		/*
			Функционал выходы из учетки релизуется через передачу POST запроса из компанентов:
				dashboard.blade.php => layouts\app.blade.php => layouts\navigation.blade.php => views\components\dropdown.blade.php, где ссылка отправляющая форму. 
				Пример отправки запроса на выход из учетки с помощью JS без необходимости клемания формы под одну кнопку:
					Без JS требовалось бы записать форму (DELETE) в форме (POST), но теперь достаточно и одной. 
					<!-- Authentication -->
						<form method="POST" action="{{ route('logout') }}">
							@csrf
							<x-dropdown-link :href="route('logout')"
								onclick="event.preventDefault();
								this.closest('form').submit();">
								{{ __('Log Out') }}
							</x-dropdown-link>
						</form>
						
			Запрос на удаление далее обрабатывается в контролере: AuthenticatedSessionController => destroy(). 
			В этом методе используется "охранник" (guard()). 

			В методе destroy:
				Auth::guard('web')->logout(); - удаление авторизованного пользователя
				$request->session()->invalidate(); - сбросс сессии
				$request->session()->regenerateToken(); - перезапуск сессии
				return redirect('/'); - редирект

			ГАРДЫ 
			Гарды - это механизм, позволяющие разграничивать использование функционала приложения пользователями.
				По-умолчанию в приложении используется гарда "web".
				Гарды подразумевают под собой свод настроек взаимодействия с типами пользователей. 
				Гарды нужны например для того, чтобы мы могли раздилять сессии по типам пользователей. Например на авторизованных пользователей сайта и админов. 
				TODO ЗАМЕТКА: автор курса считает, что они чаще избыточны, так как можно обойтись и другими методами, однако guard() в Laravel есть. 
					Пример реализации гард:
						@auth("web")
							<a href="{{ route("logout") }}" class="text-md no-underline text-grey-darker hover:text-blue-dark ml-2 px-1">Выйти</a>
						@endauth
						Или для авторзованных пользователей относящийся к гарде "web". 
						
				Гарды ааходятся в файле "config\auth.php". На дынный момент имеется только гарда "web". 
		
				Гаады состаят из драйверов и провайдеров.
				Пример: 
					'guards' => [
					'web' => [
						'driver' => 'session',
						'provider' => 'users',
					],

			ДРАЙВЕРЫ
				Драйверы есть двух типов: session и token. Второй используется с API. Сессии находятся в папке "\storage\framework\cache\sessions".
					В файле "app\Providers\AuthServiceProvider.php" расширяется и настраивается авторизация. В нем добавляются новые драйверы. 
					Здесь можно прописывать правила доспупы для разных ролей авторизованных админов. 
				
			ПРОВАЙДЕР
				Провайдер - это правило дающее авторизации понять каким образом пользователи будет получать объекты. Их тоже два: "database", "eloquent".
				Eloquent подразумевает, что за передачу данных пользователю будет отвечать модель - метод вшитый в Lravel. А "database" подразумевает обращение к БД напрямую через метод. 
				Если создается новая гарда - к ней создается новый провайдер. 
				Провайдеры находятся в папке "app\Providers\AuthServiceProvider.php".
					Пример указания правила получения данных пользоваетелем:
						'users' => [
							'driver' => 'eloquent',
							'model' => App\Models\User::class,
						],
						model - указывает модель, которая присоедина к гарде
			*/

		//!Урок 3: Восстановление пароля
		/*
			Последнее, что осталось разобрать в системе регистрации/авторизации + библиотеки "Breeze" - восстановление пароля. 
			Данные формы восстанвленяи пароля (почта) отправляются в контроллер обрабатываются и новый пароль отправляется на почту.

			Вид изнутри => PasswordResetLinkController.
				Контроллер PasswordResetLinkController:
					1) выводит форму восстановления пароля
					2) проверка входных данных: почта
					3) отправка сгенерированного пароля на почту
					4) вывод информации о событии в формате сессии в случаи успешного или безуспешного ввода нового пароля
				
				Контроллер NewPasswordController:
					1) проверка отправленного пароля и токена
					2) утверждение нового пароля в случаи совпадения
					3) вызов сброса пароля
					4) создание события о ноовом пароле
					5) вывод информации о событии в формате сессии в случаи успешного или безуспешного ввода нового пароля
				
				В файле "storage\logs\laravel.log" прописана ссылка с токеном на форму смены пароля. 

				Функционал библиотеки является минимальным для авторизации на сайте. 
				Однако, автор им не пользуется, так как пишит авторизацию без избыточного создания контроллеров и компанентов. 
				
		*/

	echo '<hr><hr><br><h3>Laravel - #27.1-1 - Политики и права доступа (День 27)</h3><hr><hr>' . "<br>";
		//!Урок 1: Политики и права доступа
		/*
			СПОСОБЫ РАЗГРАНИЧЕНИЯ ПРАВ ДОСТУПА ПОЛЬЗОВАТЕЛЕЙ:
				1. Посредники:
					Route::get('/profile', function(){
						return 'profile';
					})->middleware('auth.basic');
					TODO ЗАМЕТКА: auth.basic - это допуск до страницы после авторизации, но без самописной формы и страницы входа. 

				2. Gates (ворота). Его мы не будем рассматривать в ходе курса. 
						Gates - простой вариант ограничения и подходит для понятия основ авторизации. Его используют, когда нужно поставить ограничение на один/два метода.
						Gates имет два состояния - закрыты или открыты по указанным условиям. 
				
				3. Политики: Политика в отличии от гейта привязывается не к одной способности (ability), а к группу мтеодов опереленной модели. 
						Политика работает при использовании способов передачи данных пользователю через 'driver' => 'eloquent'. 

			СОЗДАНИЕ ПОЛИТИКИ			
				ПРАВА - это мтеоды и прописанные в политике.
				Команда создания политики:
					php artisan make:policy AddressPolicy --model=Address 
					где,
						make:policy 	- создание политики
						PostPolicy	- название политики
						--model=Post 	- название модели к которой будет относиться политика
					Политика появляется в дериктории "app\Policies\AddressPolicy.php".
					TODO ЗАМЕТКА! Название политики должно начинаться с названия модели, к которой прикрепляется политика и заканчиваться словом Policy.
					
					После создания политики - она регистриуется в "app\Providers\AuthServiceProvider.php" в массиве "$policies" через указания сявзи модели и политики.
					Пример: 
						protected $policies = [
							'App\Models\Model' => 'App\Policies\ModelPolicy',
							Post::class => PostPolicy::class
						];
					ВАЖНО! В Laravel от 7-й версии есть AutoDiscovery. Это значит, что если политике дать название начиная с названия модели, то Laravel сам увидет эту связи и указывать ее в "AuthServiceProvider.php" не придется. Но это допустимо если соотношение названии модели и политики будет как на примере: Post => PostPolicy. Если такого соответствия нет, то связь модели и политики прилется указывать в "app\Providers\AuthServiceProvider.php".
				
				Добавление модели ее изменения:
					Для работы с политикой скопируем модель, миграцию, сидер и фабрику из предыдущего проекта в текущий. 
						В миграции пропишем поле c пользователем: 
							$table->integer('user_id');
						В фабрике пропишем генирацию поля с пользователем: 
							'user_id' => mt_rand(1, 10)
						В моделе меняем связь клиента на юсера:
							public function user(){
								return $this->belongsTo(User::class);
							}
						В маршруты добавим ресурс: 
							Route::resource('/addresses', App\Http\Controllers\AddressController::class);
						Перенесем контроллер и шаблоны, связаныне с моделью. 
						В сидерах генерируются 10 записей - оставляем как есть. 

					Запустим миграцию: php artisan migrate:fresh --seed

				Разбор методов политики:
					1) viewAny() - определяет может ли просмотривать пользователь любую модель.
						return true;
					2) view() - может ли пользователь просмаривать конкретный адрес. 
						return $user->id === $address->user_id;
					3) create() - может ли пользователь создавать записи
						return in_array($user->id, [1, 2, 5, 12]);
							где,
								in_array - функция проверки значения в массиве
								$user->id - сверяемое значение 
								[1, 2, 5, 12] - массив
					4) update() - может ли пользователь обновлять записи
						return $user->id === $address->user_id; - запись значит, что можно обновлять свои адреса
					5) delete() - может ли пользователь удалять записи
						return false;
					6) rstore() - может ли пользователь восстанавливать записи
						return false;
					7) forceDelete() - может ли пользователь удалять полностью записи
						return false;

					TODO ЗАМЕТКА: методы прописанные в политике - являются правами.
					TODO ЗАМЕТКА: в видео указан трейт HandlesAuthorization, но в 10-й версии Laravel он не был установлен с поликой. 
						Он имеет два метода: 
							1-й генерирует ответ в разрешения доступа при обращении пользователя к методу. 
							2-й генерирует ответ о запрете доступа.
							Нам это не приодится. 
							
			ИСПОЛЬЗОВАНИЕ ПОЛИТИК:
				1-й способ: использование через посредники:
					Пример а):
						Route::get('/createaddress', function(){
							return 'создание нового адреса разрешено';
						})->middleware('can:create, App\Models\Address');
						где,
							can:create - посредник дающий разрешение на создание записи
							App\Models\Address - адрес модели к которой разрешен доступ по использованию указанного метода текущему пользователю
						TODO ВАЖНО! запись can:create указывает на метод политики, а не модели.
					Пример б):
						Route::get('/viewaddress/{address}', function(Address $address){
							return 'просмотр адреса доступен: '.$address->id;
						})->middleware('can:view,address'); //БЕЗ пробелов
						где,
							$address - просматриваемый адрес
							Address - модель дающая доступ к адресу
							can:view - посредник с проверкой доступа к методу

				2-й контроллеры:
					Пример а):
						public function index(Request $request)
						{
							if (!$request->user() || $request->user()->cannot('viewAny', Address::class)) {
								abort(403);
							}
							return view('addresses.index', ['addresses' => Address::all()]);
						}
						где,
							/!$request->user() - не авторизоапнный текущий пользователь
							cannot - меотд проверки на отсутствие прав к методу модели
							can - меотд проверки на наличия прав к методу модели
							viewAny - метод проверяемый на наличие отсутсивя права
							Address - модель в к котрой относится метод
							abort(403); - вывод ошибки 403
							return view('addresses.index', ['addresses' => Address::all()]); - вывод шаблона
					
					Пример б):
						$this->authorize('create', Address::class);
						$this->authorize('view', $address);
							Передача объекта класса как аргумент, так как метод политики требует аргумента в видеадреса
						где,
							authorize - метод проверки у пользователя дступа к методу модели
							create - политики, првоеряющий доступ пользователя
							$address/Address::class - параметр передаваемый в политику для проверки.
							TODO ВАЖНО! запись authorize('create'...) указывает на метод политики, а не модели.
							Проверяет доступ прав на создание записи - доступ может быть выдан в политикех модели.
					
					Пример в):
						TODO ВАЖНО!: Есть еще более удобный способ ограничения доступа через ресурсный контроллер, указав метод "authorizeResource".
						При наличии оного подобные конструкции не нужны: $this->authorize('view', $address);
							public function __construct()
							{
								$this->authorizeResource(Address::class, 'address');
							}
							где,
								authorizeResource - метод проверяющий CRUD методы на доступ к модели 
								address - название параметра,который будет отправляться в политику для проверки

					"authorizeresource" - это метод, добавляющий к роутам, связанным с ресурсом мидлвар.
					По добвлению метода "authorizeresource" в ресурс - можно увидеть у всех методов ресурса мидлвар "authorize", прописав команду: "php artisan route:list".
					TODO ЗАМЕТКА: При генрации ресурса в laravel - методы в нем создаются уже с инъекцией переменных "id" => edit($id).
						Чтобы authorizeresource заработал - нужно, чтобы при создании ресурса в команде artisan указывалась модель к которой он прявязан. 
						Либо вручную в ресурсе менять у всех методов правило аргументов/параметров, аргументы на бинды модели. 
				
				3-й шаблоны:
					Если политики ограничивают доступ к редактированию записи, то нет и смысла выводить URL редактирования. 
					Дополнительная работа по праввам должна производиться и в шаблонах blade.
					Нам понадобится шаблон "resources\views\addresses\index.blade.php". 

					TODO ЗАМЕТКА: для работы с правами доступа в Laravel имеется директива "@can()".
						Если права просмотра имеются - выводим ссылку, если же прав нет - выводим заглушку с оповещением о отсутствии прав:
						@can() - директива для работы с правами доступа. 1-й аргумент - название права (метод в политике), второй - передаваемые в шаблон данные.
						
						TODO ЗАМЕТКА: методы view/update - это методы указаныне именно в политиках - они указваются в директивах. В политиках можно создавать свои мтеоды.
						Пример ограничение вывода ссылки на показ записи:
							@can('view', $address)
								<a href="{{ route('addresses.show', ['address' => $address]) }}">{{$address->address}}</a>
							@else
								<span>Ссылка недоступна для просмотра</span>
							@endcan
					
						Пример ограничение обновления записи:
							@can('update', $address) 
								<a href="{{ route('addresses.edit', ['address' => $address]) }}">Редактировать</a> - 
							@else
								<span>редактирование недоступно</span>
							@endcan
					
						TODO ВАЖНО! Так как право "create()" не подразумевает принятия параметров кроме User->id, то вторым параметром передается модель, на основе которой будет создаваться новая запись.
						Пример ограничения создания записи:
							@can('create', App\Models\Address::class)
								<li><a href="{{ route('addresses.create') }}">Добавить еще адрес</a></li>
							@else
								<span>создание записей недоступно</span>
							@endcan
				
						TODO ВАЖНО! Несмотря, что на страницу "addresses" не имеет ограничений по правам => viewAny: return true; - страницы не доступна для не авторизованных пользователей. Все потому, что права в аргументе требуют авторизованного пользователя. Для того, чтобы страница отображалась и у неавторизованного пользователя - перед аругментом права ставится "?": запись означает, что аргумент не обязателен. 
							Пример:
								public function viewAny(?User $user): bool
								{
										return true;
								}


			СОЗДАНИЕ ПРАВ В ПОЛИТИКЕ
				Политики позволяют создавать в себе свои методы-права. 
				Пример:
					public function myPrava(User $user, int $n): bool
					{
						return $user->id === $n;
					}
				Реализация права в шаблоне:
					@can('myPrava', [App\Models\Address::class, 6])
						<span>Право "myPrava" успешно реализовано</span>
					@endcan
					Третий аргумент это аргумент добавленный в право.  
				
			НАСТРОЙКА ПОЛИТИКИ
				Настройка политики производится в файле: config\auth.php
				Суть заключается в настройка драйвером и провайдеров - смотреть урок #26.2: "Выход из системы".
		*/	

		