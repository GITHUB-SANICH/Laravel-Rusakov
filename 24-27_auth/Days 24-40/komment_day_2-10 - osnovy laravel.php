
	<?php
	echo '<hr><hr><br><h2>Модуль №2.2-10:  Основы Laravel</h2>' . "<br>";
	echo '<hr><hr><br><h3>Laravel - #2.1-2 - Структура директорий, Конфигурирование (День 2)</h3><hr><hr>' . "<br>";
		//!Урок 1: Структура директорий
		/*
			Список папок и из назначений:
				app - это папка в которой находятся модели, контроллеры, провайдеры, классы по отслеживанию ошибок;  
			Провайдеры - это файлы, описывающие глобальный функционал. Например "RouteServiceProvider" - отвечает за процесс отслеживания URL адресов внутри проекта. 
			Итого: Папка "app" - рабочая папка в которой описывается работа моделей, контроллеров, провайдеров, посредников и возможно дополнительными файлами. 
		bootstrap - это папка, хранящая файл с классами, запускающимися вместе с проектом. 
			В этой папке не придется ничего менять. В этой папке находится файл "app.php", который запускается вместе с проектом.  
			В файле перечисляются/описываются классы, которые запускаются вместе с проектом. 
			Итого: папка отвечает за описание классов, запускающихся вместе с проектом. 
		config - это папка хранящая различные файлы конфигурации. Например файл подключения к БД с параметрыми подключения. 
			Или файл с настройками авторезации и регистрации, отправки почты и т.д. 
			Итого: папка хранит настройки работы сайта, которые могут отвеать за работы почты, авторизации или подколючения к БД. 
		database - папка, хранящая папку с миграциями и отвечает за описание всей базы данных.  
			В этой папки возможно понадобится папка "migration". В ней находятся разные файлы миграции. Они создаются автоматически. 
			Миграции - файл, в котором записана история изменения объектов БД (н.п. таблица). 
			Грубо говоря миграция - это система контроля версиий для объекта БД. 
				Когда разрабатываешь веб-приложение в команде на нескольких машинах, рано или поздно сталкиваешься с проблемой синхронизации кода проекта и базы данных. Для управления кодом есть системы контроля версий, в частности, git, а для СУБД придуманы миграции.
				Миграции позволяют управлять базой данных не заходя в интерфейс PHPMyAdmin. 
			seedrs - файл, позволяющий наполнить созданную таблицу данными. 
			Итого: папка database хранит в себе описания всей базы данных. 
			
		lang -  папка служит для разных языковых версий сайта. 
			Например есть возможность вывода отображения определенных ошибок на определенном языке. 
			Итого: папка служит для разных языковых версий сайта и языковых версий ошибок.  
		public - папка хранит в себе файлы, отображаемые для пользователя, а так же файл с настройкой сервера "htaccess". 
			Например index.php - этот файл не потребуется никак видоизменять, так как он занимается в основном подгрузкой других файлов. 
			В том числе файл app.php из папки bootstrap. Файлы index.php и app.php посути запускают проект. 
			Ничего в этой папки менять не придется. 
			Итого: папка хранит в себе файлы отображаемые на сайте. Здесь хрангиться также различные медиафайлы - то, что должен увидеть пользователь. 
		resources - папка рабочая, в которой прописывается css, js, views (а вней шаблоны с HTML файлами). 
			В папке views таки и находится шаблон стартовой страницы laravel. В ходе обучения разберем парядок вызова шаблонов и работу с ними. 
			Итого: папка хранит в себе HTML шаблоны, CSS, JS. 
		routes - папка предоставляет функционал, позволяющий работать с URL адресами проекта - то есть URL нашего сайта.
			Например в файле web.php описываются URL, отслеживаемые на сайте проекта. Например описывается условие перехода на шаблон главной страници при переходе по ссылке "/". 
			api - запрос по api
			channels - запрос по каналам
			console - запрос в консоль
			web - запрос
			Итого: в папке находятся файлы, позволяющие отслеживать переходы пользователя по разным URL адресам проекта.
		storage - это папка-хранилище, в ней находится кэш; файлы, созданные внутри проекта, логи. Так же в эту папку попадают файлы пользователя. 
			Итого: в папке хранатся разные сохраненные файлы, кэш и логи проекта. 
		tests - папка с классами UNIT тетированиея. 
			В папке уже имеется небольшой набор классов (в том числе базовый) для проверки работоспособности проекта и Unit тестирования впринцепи. 
			Итого: папка содержитклассы Unit тестирования. 
		vendor - папка хранит в себе скаченные библиотеки через Composer. 
			Итого: папку трогать не нужно. 
		По ходу работы с проектом он может наполнятся дополнительными папками и файлами - например политикой - папка с правами
	ФАЙЛЫ: 
		.editorconfig - файл с настройками текстового редактора. 
			Итого: трогать файл не стоит. 
		.env - файл важный, так как в нем указываются глобальные настройки длоя всего проекта. 
			Например название проекта, секретный ключ  - этот ключ нужен для безопастности проекта - он встраивается в подпись для каждой формы.
			Это обеспечивает безопастную передачу данных на сайте. 
			APP_DEBUG - нужен для вывода или отключения вывода ошибок на вебсайте. Его лучше отключить, если сайт находится на хостинге. Так как вывод ошибок считается лазейкой в безопастности. Эту настройук можно включить при работе на локальном сервере для правок. На боевом не стОи.
			APP_URL - настройка с URL сайта. 
			Имеются настройки подключения к БД (порт, название БД и т.д.). Настройки для SMTP сервера. 
		.env.example - файл используется в качестве файла примера, чтобы вы знали, какие пары KEY = VALUE вам нужны для вашего проекта. Чаще всего его 		используют для копирования в файл .env и последующего изменения значений.
		.gitattributes, .gitignore - файлы с настройками игнорируемых файлов на локальный и удаленный репозитории git'а. 
		.styleci.yml - файл, в котором находятся настройки нескольких базовых контейнеров при работе с докером. Пример: JS, finder, laravel. 
		artisan - файл-помошник при работе с laravel. Файл трогать не нужно, в нем перечислины настройки этого помошника. 
		composer.json - описание зависимостей библиотек в проекте  
		composer.phar - главный файл Composer 
		composer.lock - логи работы в Composer 
		package.json - файл, аналогичный файлу composer.json. Но composer.json - нужен для описания зависимостей библиотек для серверной части, 
			а 	package.json - для зависимости клиентской части. В нем тоже описываются разные библиотеки, но для корректной работы клиентской части. 
			Например Bootstrap или SASS. Библиотеки, описанные в package.json можно так же установить через NPM (другой пакетный менеджер). 
			С этим файлом будем работать в  момент создания дизайна для проекта.
		phpunit.xml - файл с настройками для Unit тестированиюя внутри проекта.  
		README.md - файл, нужный для выгрузки проекта в репозиторий. Из него создается основная страница на удаленном репозитории. 
			В файле имеется текстовое описания содержимого проекта. 
		webpack.mix.js - файл, конвертирующйи JS и CSS файлы и из папки "resources" внутрь папки "чpublic". 
			Эта конвертация сделает JS, CSS файлы написаныне через SASS или View/React в понятный для браузера формат. 

		Запоминать все папки, файлы и их назначения сложно и не нужно, так как с основынми из них еще предстоит работать, а стальные не нуждаются 	 вболее подробном объяснении, так как с ними работать почти не придется.  
		
		TODO ВАЖНО! Команды остановки локального сервера: ctrl+c (в терминале). Тогда при перезагрузки страницы проект не запустится.  
		*/
			

	//!Урок 2: Конфигурирование
	/*
		Настройки Laravel находятся в папке "config". Там находятся настройки для всего приложения - кеширование, логирование, почта и.т.д.
			К этой папке будем периодически обращаться по ходу обучения и надобности.
		В общем файл с настройками выглядет как функция retern, возратщающая ключ (настройка) и его значение.
		Часто файлы из папки config ссылаются на файл .env. (например конфиг "app") Т.е. дополнительон считывать и парсить этот файл для других конфигов не нужно. 
			Пример:
				'name' => env('APP_NAME', 'Laravel'),
				где, name - настройка, env - файл с параметром,  APP_NAME - название с параметром, 'Laravel - значение.
		Так же в файле app есть настройкаи часового пояса (timezone), языка сайта (local).
			Local можно накостылить и записать русский перевод в английской версии сайта, но это не про качество. 
			name	- имя проекта
			url	- ссылка на проект
			env	- среды выполнения приложения (продакшен или локал)
			debug	- вывод или отсутствие вывода ошибки на страницу
			fallback_locale - настройка с языком, выбранным в случаи отсутствия записи в языке, указнном в Local.
			faker_locale	- язык для фейковой таблицы.
			providers	- важная настройка, подключающая провайдеры

		Некоорые параметры отсутствуют в файле .env, поэтому они вжесткую прописываюстя в вайле app.php
		Пространства имен фреймворка и приложения
		iluminate - часть пространства имен настроек, относящихся к фреймворку
		App - часть пространства имен, относящаяся к проекту
		.env - файл важный, так как в нем указываются глобальные настройки длоя всего проекта. 
	*/

	echo '<hr><hr><br><h3>Laravel - #3.1-2 - Знакомство с Artisan и режим обслуживания, Маршрутизация (День 3)</h3><hr><hr>' . "<br>";
		//!Урок 1:  Знакомство с Artisan и режим обслуживания
		/*
			1) В этом уроке научимся вводить и выводить сайт из режима обслуживания. 
			2) Использовать artisan. Его файл предстваляет собой обычный php скрипт. 

			КОМАНДЕ ПЕРЕХОДА В РЕЖИМ ОБСЛУЖИВАНИЯ:
				php artisan down
				Команда обслуживания по определенному ключу:
					php artisan down --secret="mysecret-123456"
					где,
					--secret 			- атребут объявления ключа доступа к сайту в режиме обслуживания
					mysecret-123456	- ключ доступа к сайту в режиме обслуживания
					Пример ссылки, открывающей доступ к сайту в режиме обслуживания:
						https://site.ru/mysecret-123456
						Доступ к сайту в режиме обслуживания предоставляеся мидлваром, настроенным через artisan
			КОМАНДЕ ВЫХОДА ИЗ РЕЖИМА ОБСЛУЖИВАНИЯ:
				php artisan up
			
			Функкционал работы с сайтом в режиме обслуживания через пароль (--secret="") обеспечивается посредниками (midlware), так как фильтрует запрос. 
			РЕЖИМ ОБСЛУЖИВАНИЯ закрывает доступ к приложению во время технических работ/обновлений в целях безопастности. И чтобы пользователи не видели никаких ошибок во время правок. 
		*/

		//!Урок 2: Маршрутизация
		/*
		В этом уроке будут разобраны маршрутизация, правила маршрутизации; мидлвары и как с ними работать.

		Настройки маршрутищации указаны в файле "app\Providers\RouteServiceProvider.php", который ссылаеися на файл "routes\web.php".
			При необходимости можно создать и самим дополнительные файлы с настройками маршрутизации и ссылаться на наих в провайдере. 
		Можно перечислять через функцию "match" типы запросы, которые будет обрабатывать URL => Rote::match(['get', 'post'], /contracts, function(){});
		Или прописать выполнение всех запросов => Rote::any(['get', 'post'], /contacts, function(){});
		Пример обработки динамического урла =>  Rote::get(/user/{id}, function($id){});
			В случаи наличия одинакового адреса маршрутов - приоритет чтения предоставляется самому нижнему в списке маршруту. 

		REQUEST	- это служебный класс, зависимостей, работающий с телом запроса. Через него можно вывести оттельное значенеи из запоса. 
			Rote::get(/user/{id}, function($id, REQUEST $requests){
				echo $requests->patch(); //вывод id пользователя
			});

		Можно прописывать маршрутизация с необазательными параметрами:
			Rote::get(/user/{id?}, function($id='not found user'){
				return 'user: '.$id;
			})->where('id', ['0-9']+);
			где, 
				"?" - проверка на наличие, 
				$id='' - значение параметра по-умолчанию.
				)->where('id', ['0-9']+); - регулярное выражение, обязывающее подставлять только числа. 
					ИЛИ )->whereNubber('id');	- проверка на тип число
					ИЛИ )->whereAlpha('messange'); - проверка на тип строки			
				Допустима проверка на несколько параметров - например на сообщение. Но для этого есть отдельные средства в контролере.
			
		Для каждого прописынного маршрута можно прописывать определенные имена - псевданимы, но об этом позже.
			Пример: )->name('news_id');
		
		Пример редиректа в случаи если определенная страница переехала на другой адрес:
			Rote::redirect('/before_str{id}', 'after_str{id}'); //301
			Rote::permanentRedirect('/before_str{id}', 'after_str{id}'); //302
		Есть два редиректа это 301 (пример выше) и 302: времено и навсегда. 
	
	
		*/

	echo '<hr><hr><br><h3>Laravel - #4.1-3 - Ограничение частоты запросов, Посредники, Контроллеры (День 4)</h3><hr><hr>' . "<br>";
		//!Урок 1:  Ограничение частоты запросов
		/*
			Для любого проекта требуется в целях оптимизации ставить ограничение по запросам.
			Настройки ограничения запросов находятся в провайдерах "app\Providers\RouteServiceProvider.php".

			Прмиер маршрута, обрамленного префиксом и посредником:
				Route::group(['prefix' => 'feedback', 'middleware' => 'throttle:test_RateLimiter'], function(){ //передача посреднику настройку ограничения запросов
					Route::get('/', function () {return 'feedback';});
					Route::get('/user', function () {return 'feedback-user';});
				});
		*/
		//!Урок 2: Посредники
		//?Задание №2.3 не пройдено:
		/*
			Создайте посредника, который будет пропускать запрос к созданному маршруту только при условии наличия параметра key=123456 (для получения параметра можно использовать конструкцию $request->input('key')).
			МАРШРУТ:
			Route::middleware("throttle:test_RateLimiter")->group(function () {//передача посреднику настройку ограничения запросов
				Route::get('/controller-first/{key}', [App\Http\Controllers\FirstController::class, 'index']);
			});
			ПОСРЕДНИК:
			class CheckLocalhost
			{
				public function handle(Request $request, Closure $next): Response
				{
					if($request->ip() == '127.0.0.1') return $next($request); //пропуск запросу по определенному IP	
					if($request->input('key') == 12345) return $next($request);
					abort('404'); //при отсутствии нужного IP выдавать error 404
				}
			}
		*/
		/*
		Middleware - разновидность классов, работающих с запросами фильррую/дополняя его и т.д.
		Например если запрос выходил за рамки допустимого размера - от он отбраковывается мидлваром.
		В Laravel уже имеется достаточно своих посредников, но можно создавать и свои через artisan => php artisan make:middleware CheckLocalhost
		Создадим посредник, фильтрующий пользователей по IP.
			Пример:	
				public function handle(Request $request, Closure $next): Response
				{
					if($request->ip() == '127.0.0.1') return $next($request); //пропуск запросу по определенному IP	
					abort('404'); //при отсутствии нужного IP выдавать error 404
				}
				где, $next($request); - разрешение на дальнейшее выполнение запроса
		Но чтобы посредник заработал его нужно зарегистрировать в файле "app\Http\Kernel.php". 
		Пример:	
			'checklocalhost' => \App\Http\Middleware\CheckLocalhost::class,

		Проверка работы посредника:
			

		В дальнейшем к мидлвару возможно понадобиться обращаться и для удобства они обертуты в псевданим в файле "laravel\app\Http\Kernel.php".
			Пример:  'auth' => \App\Http\Middleware\Authenticate::class,
				где, 
					'auth' - псевдоним мидлвара
					\App\Http\Middleware\Authenticate::class - мидлвар 

		Вызов группы мидлваров может происходить при вызове префиксов. Обращаясь к псевдониму "web" или "api" вызывается группа мидлваров. 
			Пример: 
			protected $middlewareGroups = [
         'web' => [
            \App\Http\Middleware\EncryptCookies::class,
            \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
            \Illuminate\Session\Middleware\StartSession::class,
            // \Illuminate\Session\Middleware\AuthenticateSession::class,
            \Illuminate\View\Middleware\ShareErrorsFromSession::class,
            \App\Http\Middleware\VerifyCsrfToken::class,
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
         ],

         'api' => [
            // \Laravel\Sanctum\Http\Middleware\EnsureFrontendRequestsAreStateful::class,
            'throttle:api',
            \Illuminate\Routing\Middleware\SubstituteBindings::class,
         ],
      ];
		Вызов мидлваров префикса api будет вызван в файле Providers\RouteServiceProvider.php если ссылка будет иметь вид например: "localhost.com/api"
		В файле Providers\RouteServiceProvider.php прописаны мидвары группы 'web' ко всем правилам маршрутизации в файле web.php. 

		В этом курсе работы с API не подразумеваетс и можно было бы удалить мидлвары и функции в файле RouteServiceProvider.php, но не будем.

	1. Цикл HTTP запросов в Laravel
		а) Запросы прописываются в файле laravel\routes\web.php => 
		б) Перенаправляется в laravel\public\index.php => 
		в) Затем перенаправляются в мидлвары, хрянящиеся в файле laravel\app\Http\Kernel.php => 
		г) Когда произошло бращенеи к нужным мидлварам, запрос направляется в файл laravel\app\Providers\RouteServiceProvider.php => 
		д) В конечном счете  запрос возвратщается обратно в файл laravel\routes\web.php, где настраивается принятие запроса, обращение к котроллерам и вывод view-шаблонов.

		Консольная команда, отображающая все правила маршрутизации в приложении:
		php artisan route:list

	2. Создание своего Middleware. 
		Мидлвар создается через artisan команду: 
			php artisan make:middleware - создание мидлвара
			php artisan make:middleware GoogleRecaptcha - создание мидлвара с валидацией гуглрекапчи
		Новый мидлвар находится в папке laravel\app\Http\Middleware\GoogleRecaptcha.php

		В новосозданном мидлваре будет проверятся наличие примерного/учебного параметра "r" в запросе, отсутствие которого выводит ошибку 403:
			if (!$request->has("r")) {
				abort(403);
			}

		В файле "app\Http\Kernel.php" нужно прописать псевдоним для нового мидлвара: "'r' => GoogleRecaptcha::class,".
		В случаи отсутствия этого параметры при подключенном мидлваре будет вывордится ошибка 403.
		Если же ссылка будет иметь вид "localhost.com/?r=1" с подключенным мидлваром, то ошибка 403 выводиться не будет.

	3. Подключение мидлвара. 
	Подключение мидлвара происхочет чреез метод "middleware()"
		Пример: 
			Route::get('/', function () {
				return view('welcome');
			})->middleware("r"); - подключенный мидлвар к отправляемому запросу
	Можно подключать несколько мидлваров через массив: ->middleware(["r"]);

	4. Работа с маршрутизацией в фале web.php. Группы маршрутизации по префиксу и роутам.
		Создадим контроллер: php artisan make:controller IndexController
		Пропишем в нем только возврат главного шаблона сайта, а роут будет ссылаться на этот контроллер. 
			Пример:
				Route::get('/', [App\Http\Controllers\IndexController::class, 'index'])->name('home');
			
			Желательно каждому правилу маршрутизации задавать имя как выше в примере (->name('home');), так как во время ветски это упростит прописание ссылок в шмблонах. 
			Например вместо прописания полного правила маршрутизации достаточно будет прописать "\route('home);" 'это будет коротким аналогом вышенаписанного правила маршрутизации.
			Помимо минимализации кода это позволяет при смене ссылки в маршрутизации менять ее только в ней, а не во всех шаблонахв, в которых эта ссылка быда указана - так как в шаблонах указывается только всевдоним на нужное правило (route).
		
		Кроме того роуты-правила маршрутизации можно объединять в группы. 
			Пример:
				//группа маршрутизации, в которой применяется мидлвар "r"
				Route::middleware("r")->group(function(){
				//Правила маршрутизации, к которой применяются правила мидлвара "r"
					Route::get('/', [App\Http\Controllers\IndexController::class, 'index'])->name('home');
					Route::post('/contact_form', [App\Http\Controllers\ContactController::class, 'index'])->name('contact_form');
				});

		Еще есть возможность объединять правила маршрутизации в группы по префиксу. Чтобы не повторяеть его во всех URI роутов. Вместо news/{{id}} указывается {{id}}.
			Пример:	
				//группа роутов в каждом из которых имеется префикс "news"
				Route::prefix("news")->group(function(){
					//Правила маршрутизации, к которой применяются правила мидлвара "r"
						Route::get('/', [App\Http\Controllers\Newsontroller::class, 'index'])->name('news');
						Route::post('/{id}', [App\Http\Controllers\NewsController::class, 'index'])->name('news_id');
				});
		
		так же можно првефиксы и мидлвары засовывать в одну группу. 
			Пример: 
				Route::middleware("r")->prefix("news")->group(function(){}
		*/

		//!Урок 3: Контроллеры
		/*
			Команда создания контрллера:
				php artisan make:controller NameController --invokable
				--invokable - необязательынй параметр. Он создает в контроллере метод __invoke().
				Он нужен, когда маршрут не указывает функцию, обрабатывающую запрос. 
				
				Пример записи маршрута для вызова метода "__invoke" в контроллере:
					Route::get('/request', App\Http\Controllers\FirstController::class); 
		*/

	echo '<hr><hr><br><h3>Laravel - #5.1-2 - Шаблоны, Компоновщики шаблонов (День 5)</h3><hr><hr>' . "<br>";
		//!Урок 1: Шаблоны
		/*
			Шаблоны создаются в папке: "resources\views"
			Пример переда данных в шаблон из контроллера:
			
				public function testView(Request $request)
				{
				1-й способ
					return view('example')
						->with('a', 'Shalom')
						->with('b', 'Hello');
				}   
				2-й способ
				return View::make('example', ['a' => 'Shalom', 'b' => 'Hello']);
				3-й способ
				return view('example', ['a' => 'Shalom', 'b' => 'Hello']);
				где, a/b - ключ, Shalom/Hello - значения, example - название шаблона, View - фассад, make - меотд фассада

				СОЗДАНИЕ ГЛОБАЛЬНЙО ПЕРЕМЕННЙО
					Если данные нужны для вывода на множестве страниц - для этого создается глобальная переменная. 
					Она создается в файле "app\Providers\AppServiceProvider.php", методе "boot".
					Пример: View::share('global_var', 'Значение глобальной переменной "global_var"');
					Вызов глобальной переменной: <p>Global: <?=$global_var?></p>
		*/
		//!Урок 2: Компоновщики шаблонов
		/*
			Компоновщики шаблонов - инструмент, делающий данные доступными только для определенных шаблонов. 
			Компоновщие передает данные в шаблон, когда он (шаблон) открывается в проекте. 
			Комноновшик объявлается в файле "app\Providers\AppServiceProvider.php" через фассад View::composer();
			Пример:
				Объявление компоновщика:
					View::composer('example', function($view){
							$view->with('composer_data', 'pass');
					});
					где,
						$view - объект с параметрами, передаваемыми в шаблон "example"
						example	- отслеживаемый шаблон
							Можно перечислить множество шаблонов для компановщика, но тогда они должны быть пересичленны в массиве
						composer_data	- передаваемый параметр
						pass	- значение параметра
				Вызов компоновщека в шаблоне:
					@php
						if (isset($composer_data)) echo '<p>Composer Data:'. $composer_data.'</p>';
					@endphp
					или
					@if (isset($composer_data))
						{{'Composer Data: '.$composer_data}}
					@endif


			ТАКОЙ подход наполнения шаблонов нарушает 1-й принцип SOLID, поэтому по-хорошему нужно создавать отдельный провайдер с компановщиками.
			Либо создать отдельный класс компановщик, на который будут ссылаться провайдер. Это лучше еще и потому, что класс при необходимости может обратиться к БД.
			
			ХРАНЕНИЕ КОМПОНОВЩИКА
				Папка с компоновщиком - создается сомостоятельно (папки не создаются автоматически через artisan): 
					Указананя в этом классе информация будут передаваться в шаблон, а провайдер будет только к нему (классу) обращаться для передачи в шаблон. 
						app\View\Composers\ExampleComposer.php 
					Это произвольная ссылка, и класс с компановщиком можно создать, где угодно. 
				
				ФУНКЦИОНАЛ КОМПОНОВЩИКА:
					namespace App\View\Composers;
					use Illuminate\View\View;
					class ExampleComposer
					{
						public function compose(View $view){
							$view->with('composer_data', 'push ExampleComposer');
						}
					}   

				Ссылка на класс-компановщик в провайдере:
					View::composer('example', App\View\Composers\ExampleComposer::class); //ссылка на класс-компановщик

				РЕЛАИЗАЦИЯ КОМПОНОВЩИКА В ШАБЛОНЕ:
					@if (isset($composer_data))
						{{'Composer Data: '.$composer_data}}
					@endif
				
			ИТОГО: компановщик стоит использовать, когда нужно передавать дополнительные данные группе шаблонов. 
				Это можно сделать через глобальные переменые, но это бОльшая нагрузка на производительность и больЕЕ ожидание. Так что, когда требуется какая либо информация всего для нескольких шаблонов - профитнее испольозвать компановщик. Глобальные переменные предназначены для более масштабного использования. 
				При создании компановщику нужно: 
					1) Фассад "View::composer" в провайдере с шаблонами получатилями с сылкой на компановщик. 
					2) Сам комановщик с данными, передаваймыми в шаблон.
				
		*/

	echo '<hr><hr><br><h3>Laravel - #6.1 - Шаблоны Blade (День 6)</h3><hr><hr>' . "<br>";
		//!Урок 1: Шаблоны Blade
		/*
			В этом уроке затронем работу с blade шаблонами в laravel. 
			ПЕРЕДАЧА ДАННЫХ В ШАБЛОН:
				Для передачи информации в шаблону задействуется контроллер. Пропишем в нем данные, которые будем передавать в шаблон. 
				Есть два формата передачи данных в шаблон:
				Первый:
					Пропишем данные в контроллере главной страницы и передача дынных в нее через метод "compact".
					Пример:
						public function index_metod (){
							$title = 'Главная страница сайта';
							return view('static/index', compact('title'));
						}
						где, 
						$title	- переменная, с передаваемыми данными 
						compact	- метод передачи данных
						title		- название переменной, которая передается в шаблон 
					Получение данных в шаблоне:
					Пример:
						{{ $title }}
						где, 
						{{ }}	- функциональная часть шаблона в котором омжно было бы записать разные операции. 
						В нем можно прописывать разные операции, условия - в общем php код. 
						{-- --}	- запись комментария, невидимого на экране
				Второй: 
				Помима метода "compact" есть еще метод "with". 
				Пример: 
					public function about_metod (){
						$title = 'О нас';
						return view('static/about')->with('header', $title);
					}
					header			- (необязательный параметр) имя-псевдоним, которое передается шаблону
					$title			- модержимое имени-псевдонима
					{{ $header }}	- вызов содержимого имени-псевдонима внутри шаблона
				
				ПЕРЕДАЧА ДАННЫХ В ШАБЛОН МАССИВА (множество переменных)
					public function about_metod (){
						$data = [
							'title'	=> 'Страница про нас',
							'params'	=> ['BMW', 'Audio', 'Volvo']
						];
						return view('static/about')->with($data); //можно было оформить так: with('header', $data);
					}
					Метод  with принимает только значнеие без псевдоимен ($data). 

					В шаблоне достаочно указать только ключ массива без указания самого массива. 
					Пример: 
						<!--	При псевдоимени достаточно было бы указать $header При массиве же достаточно указать ключ передаваемых данных-->
						{{ $title }} 
					При необходимости вывода всего массива в шаблоне - можно использовать стандартные PHP скобки, но это не лучшая практика. 
					В блейд шаблонах для этого уже заготовлены специальные втсавки без необходимости использования стандартных скобок. 
					Пример: @if, @foreach. 
					@if(count($params) > 0)
						<p>У нас больше чем 0 эллементов:</p>
						<ul>
							@foreach($params as $el)
								<li>{{ $el }}</li>
							@endforeach
						</ul>
						@else
							<p>Передаваемый массив пуст</p>
					@endif
					где, 
					@if		- объявление условия
					@endif	- объявление конца условия
					@foreach	- объявление цикла
					@foreach	- объявление конца цикла
					@include('child', ['data' => ['a' => $a, 'b' => $b]])		- подключение шаблона
					@includeWhen($boolean, 'view.name', ['some' => 'data'])	- подключение шаблона и передача в него данных при выполнении условия
					@includeUnless($boolean, 'view.name', ['some' => 'data'])- подключение шаблона и передача в него данных при не выполнении условия
					Для вывода на экран оператор "echo" не требуется. 	
					
					Пример перевода массива или объекта в JSON-строку
					<script>
						let x = {{ Js::from([1, 2, 3]) }};
					</script>

					TODO ВАЖНО! Такая конструкция написания кода используется для повышения безопстности {{}}, так как она не пропускает теги и скрипты. 
		*/

	echo '<hr><hr><br><h3>Laravel - #7.1-3 - Наследование шаблонов, Создание собственных директив, Компоненты (День 7)</h3><hr><hr>' . "<br>";
		//!Урок 1: Наследование шаблонов
		/*
			На сайте может быть множество одинаковых шаблонов с минимальными отличиями. 
			Чтобы избавиться от постоянного дублирования этих частей в Laravel имеется наследование шаблонов.  
			
			СОЗДАНИЕ СЕКЦИЙ В ШАБЛОНЕ И ИХ ПОДКЛЮЧЕНИЕ
				Для создадим шаблон главной страницы, в которой в зависимости от страницы будет передаваться код. 
				Путь: "resources\views\layout\main.blade.php" создания шаблона главной страницы. 
				Папка "layout" будет содержать весь повторяющийся код. 
				Шаблоны (файлы с расширением blade.php) laravel имеют множество различных директив/функций:
				TODO ВАЖНО! Названия секция не должны повторяться внутри шаблона. 
					Пример: @yield('content') - функция объявления секции в шаблоне. 
					где, 
					@yield		- функция объявления метки-секции для шаблонов наследников
					('content')	- название секции в шаблоне (без спец.символов)
				В шаблоне, который принимает повторяющийся код прописывается функция:
				Пример: @extends('layout\main'), 
					где, 
					@extends				- функция наследования кода от родителя - шаблона
					('layout\main')	- адрес шаблона из которого наследуется код
				После в шаблоне наследнике следует код, который нужно наследовать из секции шаблона-родителя. 
				Пример: 
				@section('content')
					HTML код
				@endsection
				где, 
				@section		- начинающийся тег с содержимым секции
				('content')	- название шаблона, в котоырй передается сдержимое
				@endsection - закрывающийся тег с содержимым секции
				

				Конструкция section отвечает за возможность показывать секцию на главной странице и вносить в нее свои данные дочерним шаблонам.
				section - это только метка, сделанная для наследников, которая может обтображать контент в родтеле, а может и не отображать. 
				Примеры:
					1) Секция отображается и на главной странице и в дочерхних за счет окончания show
					@section('left')
						<div>Основное меню</div> 
					@show
					2) Секция отображается только в наследниках
					@section('left')
						@parent
						<div>Дочерний блок</div> 
					@endsection
					где,
						@parent - метка в секции наследника, которая позволяет дополнять контент родительсокй секции не заменяя его. 

		*/
		//?Задание №7.2 не пройдено:
		//!Урок 2: Создание собственных директив
		/*
			В laravel имеется множество директив в шаблонах blade (например @if), но можно создавать и свои. 
				Новые директивы регистрируются в файле "app\Providers\AppServiceProvider.php" в метода "boot()". 
				Для объавления своей директивы понадобится подключить фассад 'Blade::" - "use Illuminate\Support\Facades\Blade;";
			
			ОБЪЯВЛЕНИЕ ДИРЕКТИВЫ
				public function boot()
				{
					Blade::directive('nameNewDirective', function (str $param) {
						return "<?php echo 'Прописанный текст: <b>$param</b>'; ?>";
					});
				}
				где,
					Blade	- фассад работы с директивами
					directive	- метод объявления новой директивы
					nameNewDirective	- название новой директивы
					function($arg){...}	- collback, срабатывающий при вызове новой директивы
					
				TODO ВАЖНО! Директива по-сути вызывает обычный PHP/HTML код, который можо будет не прописывать в шаблоне
			ВЫЗОВ ДИРЕКТИВЫ:
				@directiveTest(текст);
		*/
		//!Урок 3: Компоненты
		/*
			Кмпоненты позволяют уменьшить дублирование кода - они альтернатива наследования шаблонов. 
			А так же компоненты инкапсулитьвать часть кода инкапсулитьвать для дальнейшего многократного использования. 
				Создано новое текстовое удачное поле в форме, которое хотелось бы использовать во всех формах.
				Но тогда при изменении CSS в поле - придется прбегать все формы и менять стили. Поэтому лучше такие вставки как поле в форме делать в виде компанентов. 
			
			КОМАНДА СОЗДАНИЯ КОМПОНЕНТА:
				php artisan make:component MyInput
			TODO ЗАМЕТКА: не обязательно создавать класс для компанента - коспанент можно создавать вручную, но тогда смысла от него будет не так много. 
			При создании компанента создается и папка хранения компанентов
			МЕСТО ХРАНЕНИЯ КОМПОНЕНТОВ:
				Класс компанента: 
					app\View\Components\MyInput.php
				Компаненты можно использовать и без класса, но более сложные компаненты удобнее использовать в связке с классом. 

				Шаблон компанента:
					resources\views\components\my-input.blade.php

			В шаблоне пишется код, который нужно дублировать множество раз. Например поле input: 
				<input type="text" class="input-text" placeholder="Вызываемое поле из компанента" style="margin-top: 15px;">
			Этот компанент вызывается из blade-шаблона, к которому его нужно прикрепить. 
			Для этого создадим роут с вызовом шаблона, который будет вызывать компонент. 

			ВЫЗОВ КОМПАНЕНТА:
				<p><b>Шаблон с вызовом компанента:</b></p>
				<form action="">
					<input type="text" name="" id="" placeholder="Поле №1" style="margin-top: 10px;"><br>
					<input type="text" name="" id="" placeholder="Поле №2" style="margin-top: 10px;"><br>
					{{-- Вызываемый компонент --}}
					<x-my-input/>
				</form>
				где,
					<x-		- объявление вызова компанента
					my-input	- назавание компанента
					/>			- закрытие компанента
			
			ПЕРЕДАЧА ПАРАМЕРОВ В КОМПАНЕНТ:
				Вызвая компонент  через контроллер-компанент - есть возможность паралельно передавать в него данные/поля, которые будут меняться в зависимости от вызывающего шаблона. 
				Например "тип поля" => private $inputText; И "значение" => private $value;
				В контроллере за составление компанента и передачу данных в него отвечает метод "render";
				Посути вызов компанента это обращение к контроллеру за вызовом компанента. 

				TODO ВАЖНО! Особенностью компанента является то, что при составлении компанента (перед выводом он составляется - рендерится), через метод контроллера "render" - передавать данные в компанент как при вызове обычного шаблона не нужно. Компанента автоматически получает доступ к полям своего контроллер, если его поля в публичном доступе = public.

				Получение параметров в компаненте:
					<input type="{{$inputType}}" class="input-text"  style="margin-top: 15px;" placeholder="Вызываемое поле из компанента" value="{{$valueTest}}">
					где,
						$inputType - новое название атребута для поля
						$valueTest - новое название атребута для поля

			ВЫЗОВ КОМПАНЕНТА С ВОЗМОЖНОСТЬЮ УКАЗАНИЯ ПАРАМЕТРОВ:
				<x-my-input input-type='text' value-test='Переданное значение' />
				где,
					input-type				=> замененное название атрибута (в формат "input-type" могут переводиться поля типа $inputType)
					text						=> введенное значение атребута (при отсутствии - принимает значение переданное при рендеринге в  компанент). 
					value-test				=> замененное название атрибута 
					Переданное значение	=> введенное значение атребута (при отсутствии - принимает значение переданное компанентом). 

				TODO ЗАМЕТКА: в проекте компаненты можгут храниться десятками. Поэтому рекомендуется производить рзабивку компанентов на дериктории. 
					Например: компаненты относящиеся к форме хранятся в папке "resources\views\components\forms\my-input.blade.php". 

			ПРИМЕР ВЫЗОВА КОМПАНЕНТА ИЗ ДИРЕКТОРИИ:
				<x-forms.my-input input-type='text' value-test='Переданное значение' />
			
			ДОБАВЛЕНИЕ ПАРАМЕТРОВ КОМПАНЕНТУ ИЗ ШАБЛОНА
				Если указать в шаблоне дополнительыне атрибуты для компанента - они не отобразятся, если эти атрибуты не указаны в компаненте. 
				Чтобы значение атребутов в компаненте внетри шаблона воспринимались и показавались на экране - нужно в компаненте прописать атребут (например placeholder).
				Т.е. атребуты в компаненте при вызове не получится прописать, если предварительно они не были прописаны в компаненте при объявлении. 
				Если значения атребутов вжескую прописаны при объявлении компанента - заменить их значение при вызове компанента в шаблоне тоже не получится. 
				
				В шаблоне можно прописывать значение атребутов если атребуты были предварительно прописаны в файле компанента и имеет значение примерно:
				placeholder="{{ $attributes['placeholder'] }}"

				Пример:
					<input type="{{$inputType}}" class="input-text"  style="margin-top: 15px;" placeholder="{{ $attributes['placeholder'] }}" value="{{$valueTest}}">
					где, 
						placeholder - название атребута в шаблоне
						$atributes['placeholder'] - масив с метками, в которые вносятся данные, которые могут перекрыть значения самого компанента
						'placeholder' - метка, за внесения данных в копаненте
					
					TODO ВАЖНО! Если не прописать эту запись в компаненте ({{$attributes['placeholder']}}), то записи в заблоне, вызывающем компанент - не будут заменять значения по-умолчанию компанента. 
						Т.е. атребуты в слоте и в компаненте при вызове не получится прописать, если предварительно они не были прописаны в компаненте при объявлении. 
						Если значения атребутов вжескую прописаны при объявлении компанента - заменить их значение при вызове тоже не получится. 

			Вызов компанента можно производить и без привязанного к нему класса при создании компанента. 
			Пример вызова компанента без контроллера:
				Объявление компанента:
					<p style="color:brown;">{{$attributes['message']}}</p>
						или
					<input type="text" name="nama" placeholder="Имя" value="{{$attributes['value-input']}}"></input><br>
						или
					<input class="input-type" type="{{$inputType}}" value="{{$value}}" placeholder="{{$attributes['placeholder']}}">
				
				Вызов компанента:
					<x-error-simple message="сообщение об ошибке"/>
						или
					<x-fitback-form value-input="Имя в поле"/>
						или
					<x-my-input input-type="text" value="Содержимое поля"/><br>
					<x-my-input input-type="text" value="{{$a}}"/><br>
		*/

	echo '<hr><hr><br><h3>Laravel - #8.1-4 - Слоты, Макеты, Объект Request, Объект Response (День 8)</h3><hr><hr>' . "<br>";
		//!Урок 1: Слоты
		/*
		СЛОТ - это механизм, позволяющий внедрять в компанент дополнительный текст или HTML код. В компаненте может находится множество слотов. 
		На основе слотов и компанентов создаются макеты сайтов. Но об этом в следующей теме.  
			Пример:
				Объявление компанента с слотом:
					<div>
						<p style="color: #c00;">{{$slot}}</p>
					</div> 
				Вывод компанента с слотом:
					<x-error-message>
						<i>Выыод ошибки</i>
					</x-error-message>
					где, 
						<i>Выыод ошибки</i> == слот

				TODO ВАЖНО! Слотом в компаненте считается никак не помеченная информация при выводе компанента в шаблоне. 
					Второй и далее слот должет иметь обозначение/название. 
					
				TODO ВАЖНО! Рекомендуется объявлять слот через переменную $slot, только если в макете имеется только один слот. 
					При множестве слотом лучше задавать всем слотам имя (переменную).	
		
		ОБЪЯВЛЕНИЕ СЛОТОВ
		В компаненте может быть множество слотов. 
			Первый слот после объявлении не требует обозначения в шаблоне при вызове. Второй и далее - требует.
			TODO ВАЖНО! Првый слот должен быть прописан в виде переменной $slot в файле компанента. Второй и далее слоты прописываются пролизвольной переменной. 
			Пример объявления 1-го слота в компаненте:
				<p style="color: #c00;">{{$slot}}</p>
				где,
					$slot - переменная, вмещающая содержимое компанента в шаблоне
				
			Пример объявления 2-го слота в компаненте (суммарно 2):
				<h3 class="{{ $header->attributes['class'] }}">{{ $header }}</h3>
				<div>
					<p style="color: #c00;">{{ $slot }}</p>
				</div>
				где,
					$header		- метка + название для второго слота
					$header->	- пометка, что атребут относится к слоту "header"
					['class']	- метка для атребута класс
					attributes	- массив, со списком атребутов слота
				TODO ВАЖНО! Новые атребуты в слоте и компаненте при вызове в шаблона не получится прописать, если предварительно атребуты не были прописаны в файле компанента. 

		ВЫЗОВ КОМПАНЕНТОВ В ШАБЛОНЕ: 
			Вызов второго и далее слота происходит через пропись парного тега "<x-slot></x-slot>"
			<x-error-message>
				<x-slot class="my-class" name="header">
					<p>Хедер</p>
				</x-slot>
				<i>Текст компанента со слотом</i>
			</x-error-message>
			где,
				<x-error-message></x-error-message>	 - вызов компаненте со слотами
				error-message - название вызванного компанента
				<i>Текст компанента со слотом</i>	- содержимое первого слота (так как не имеет пометки с именем слота, то считается по=умолчанию 1-м слотом)
				<x-slot ... ></x-slot> 					- вызов второго слота 
				header										- название второго слота
			TODO ВАЖНО! Второй и далее слот при вызове обязательно должен иметь атребут "name" c названием слота, который помечен переменной в компаненте. 
			TODO ВАЖНО! $slot - глобальная переменная компанента, не требующая обозначения в шаблоне.
		*/
		//!Урок 2: Макеты
		/*
		Макет - это сборник слотов. 
			КОМАНДА СОЗДАНИЯ МАКЕТА:
				php artisan make:component MainLayout

			МЕСТО НАХОЖДЕНИЯ МАКЕТА-КОМПАНЕНТА:
				app\View\Components\MainLayout.php
			Т.е. там же, где и контроллер компанента.

			МЕСТО НАХОЖДЕНИЯ ШАБЛОНА МАКЕТА_КОМПАНЕНТА:
				resources\views\components\main-layout.blade.php
			Т.е. там же, где и сами компаненты.

			Но лучше не смешивать макеты сайта и компоненты, котоыре будут использоваться на сайте в одном месте.
			Шаблоны макета лучше перенести в отдельную созданную вручную папку: 
				"resources\views\layouts\main-layout.blade.php";
			Но тогда в методе контроллера макета нужно поменять путь вызова шаблона:
				"layouts.main-layout"
			Теперь "main-layout" можно подключать через тег. 
			Ранее мы уже создали макет сайта, используя наследование шаблонов через (@yield) и (@section).
			Так как макеты это один из аналогов построения структуры сайта, то создадим похожий обрацез на тот, что ранее создавался через директивы наследование шаблонов 
			(@yield) и (@section).

				МАКЕТ С ДИРЕКТИВАМИ:
					<!DOCTYPE html>
					<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
					<head>
						<title>@yield('title', 'Заголовок страницы')</title>
					</head>
					<body>
						<div>Шапка сайта</div>
						<div>
							@section('left')
								<div>Основное меню</div> 
							@show
						</div>
						<div>@yield('content')</div>
						<div>Подвал</div>
					</body>
					</html>

				МАКЕТ С КОМПАНЕНТАМИ/СЛОТАМИ:   
					<!DOCTYPE html>
					<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
					<head>
						<title>{{$title ?? 'Заголовок страницы'}}</title>
					</head>
					<body>
						<div>Шапка сайта</div>
						<div>
							<div>Основное меню</div> 
							{{$left}}
						</div>
						<div>
							{{$content}}
						</div>
						<div>Подвал</div>
					</body>
					</html>

					ДОЧЕРНЯЯ СТРАНИЦЫ МАКЕТА С НАСЛЕДОВАНИЕМ:
						@extends('extendsview')
						@section('title')
							Главная страницы
						@endsection
						@section('left')
						@parent
							<div><b>Различные банеры - дочерняя секция "extendsview => index"</b></div>
						@endsection
						@section('content')
							<p>Основной конттент страницы</p>
						@endsection

					ДОЧЕРНЯЯ СТРАНИЦЫ МАКЕТА СО СЛОТАМИ:
						<x-main-layout>
							<x-slot name="title">Главная страницы</x-slot>
							<x-slot name="left">
								<div><b>Различные банеры - дочерний компанент "indexlayout => main-layout"</b></div>
							</x-slot>
							<x-slot name="content">
								<p>Основной конттент страницы</p>
							</x-slot>
						</x-main-layout>


			Если коротко вся тема компанентов/слотов/макетов - это аналог сборки страниц через наследование шаблонов (@yield) и селектов (select).
			Выбор того или иного метода построения макета - это дело вкуса. 
		*/
		//!Урок 3: Объект Request
		/*
			Request (запрос) - это объект для работы с запросом.
			Он позволяет проверять параметры на наличие и содержание, выводить заголовок, проверять IP с которого был отправлен запос и т.д.
			Чаще всего request используется при обработки форм. 
			С его помощью передаются данные в БД, но в этом уроке для наглядности будет выводить даныне запроса в контроллере. 

			МЕТОДЫ ОБЪЕКТА REQUEST:
			return $request-> ...
				1) header(); Метод выводит строку в виде заголовка запроса. 
					Аргуметом выступает свойство заголовка запроса. Именно заголовок запроса, а не текстовый заголовок.
					Пример:
						$request->header('Host'); ==  127.0.0.1:8000
				2) method(); Метод выводит тип HTTP запрос, которым были отправлен данный зайпрос. Аргумент у метода отсутствует.
						Пример:
							$request->method(); ==  GET
				3) isMethod(); Метод выводит результат проверки (1 или '') на наличие HTTP метода, которым отправлялся запрос. 
					Аргуметом выступает название проверяемого HTTP метода.
						Пример:
							$request->method('POST'); ==  false
				4) ip(); Метод вывода IP, с которого был отправлен запрос. Аргумент у метода отсутствует.
						Пример:
							$request->ip(); ==  127.0.0.1
				5) path(); Метод выводит информацию о пути запроса. Аргумент у метода отсутствует.
						Пример:
							$request->path(); ==  request
				6) url(); Метод вывода URL кроме параметров запроса. Аргумент у метода отсутствует.
						Пример:
							$request->url(); ==  http://127.0.0.1:8000/request
				7)  fullUrl(); Метод вывода URL вместье с параметрами запроса. Аргумент у метода отсутствует.
						Пример:
							$request->url(); ==  http://127.0.0.1:8000/request?a=12&b=typ
				8)  fullUrlWithQuery(); Метод добавления дополнительных параметров в запрос. 
					Аргумент выступает ассоциативный массив, где ключ - параметр запроса, значение ключа - значение параметра.
						Пример:
							$request->fullUrlWithQuery(['par1' => 'var1']); == http://127.0.0.1:8000/request?a=12&b=typ&par1=var1
				9)  input(); Метод вывода всех параметров запроса.
					Аргумент может выступать параметры или массив параметров, котоыре нужно вывести.
						Пример вывода всех паарметров запроса:
							$request->input() == ['a' => '12', 'b' => 'typ']; 
						Пример вывода конкретного паарметроа запроса:
							$request->input('a') == 12 
						Пример присвоения результата метода е переменной:
							$a = $request->input('a', 0);
								где, 'a' - параметр запроса, 0 - значение переменной в случаи отсутствия параметра. 
						TODO ВАЖНО! ->input() выводит все параметры запроса, но в примере имеются только парамтеры передаваемые через HTTP запрос GET.
				10) query(); Метод вывода параметров запроса, отображенных в адресной строке. Т.е. через HTTP метод GET. Метод query() похож на массив $_GET();
					Аргумент у метода отсутствует.
						Пример:
							$request->query() == ['a' => '12', 'b' => 'typ'];
				11) has(); Метод проверки запроса на наличие парамтера.
					Аргументом выступает проверяемый на наличие параметр в запросе.
						Пример:
							$request->has('par') == true
				12) filled(); Метод проверки параметра в запросе пустоту.
					Аргументом выступает проверяемый на наличие параметр в запросе.
						Пример:
							$par = 'var';
							$request->filled($par) == true

				Это не все методы объекта request, но это наиболее часто использующиеся методу. Особенно "ip", "input", "".

		*/
		//!Урок 4: Объект Response
		/*
			Response (ответ)	- объект возврата ответа. 
				Как в request так и responce хранятся тело запроса/ответа и заголовки. 
					Ответ и запрос состоят из заголовка и тела запроса.
					Заголовок несет в себе дополнительную информацию например в виде статуса и типа ответа, дополнительные команджы например в виде редиректа.
					Заголовок нужен браузеру - это "служебная информация".
					Тело запроса это результат обработанного запроса - обычно в тем хранятся запрашиваемые данные. 
				Статусов запросов бывает множество, но дастаточно понимать в какой группе нахдится запрос: 100, 200, ... 500.

			Примеры вызова Rsaponse:
				1) response(); Метод вызова ответа. Первым агрументом може выступать тело запроса, а вторым статус ответа. 
					Пример:
						response('Тело запроса', 200); == "Сожержимое тела запроса"
						response('Сожержимое тела запроса', 200)->header('Content-type', 'text/plain') == "Сожержимое тела запроса"
						где, 	Тело запроса/Сожержимое тела запроса - это содержимое тела запроса, 
								200 - статус ответа
								->header	- метод присваения новых параметров к запросу
								Content-type	- параметр текста в заголовке
								text/plain		- тип текста, игнорирующий теги

					Так же к запросу можно приписывать метод добавления заголовка. 
					Пример:
						response('Тело запроса', 200)->header('Content-type', 'text/plain');
						где, Content-type - параметр заголовка, text/plain - значение параметра (это параметр с типом текста - т.е. не HTML, т.е. теги не воспринимаются). 
				2) response()-json(); Метод возврата ответа в виде JSON-объекта. 
					Аргументом выступает ассоциативный/многомерный массив. 
					Пример:
						Response::json(['par1' => 'var1', 'par2' => ['var2.1', 'var2.2', 'var2.3'], 'par3' => true]) == {"par1":"var1","par2":["var2.1","var2.2","var2.3"],"par3":true}
					TODO ЗАМЕТКА: можно обращаться к объекту response и через фассад "Response". 
				3) response()->download(); Метод запуска скачивания файла у отправителя запроса. Буть то PDF, архив или иной файл. 
				Аргументом выступает путь к скачиваемому файлу. 
					Пример:
						response()->download('H:\SERVAK\OPEN_SERVER_pgu\OSPanel\domains\Laravel-Rusakov\README.md');
				4) response()->file(); Метод показа содержимого файла без скачивания у отправителя запроса. 
				Аргументом выступает путь к отображаемому файлу. 
					Пример:
						response()->file('H:\SERVAK\OPEN_SERVER_pgu\OSPanel\domains\Laravel-Rusakov\README.md');
		*/

	echo '<hr><hr><br><h3>Laravel - #9.1-3 - Работа с URL, Сессии, Обработка исключений (День 9)</h3><hr><hr>' . "<br>";
		//!Урок 1: Работа с URL
		/*
			В уроке разберем работу с URL. 
			Для работы с URL понадобится функция "url();"
			Так же как и у Request - у url(); тоже есть свой фассад URL::
			Через функцию "url()->" можно вызывать другие функции по работе с URL.
				1) current(); Функция возвратщает текущий URL. 
					Пример:
						url()->current(); == http://127.0.0.1:8000/testurl
				2) full(); Аналог current();
					Пример:
						url()->full(); == http://127.0.0.1:8000/testurl
				3) previous(); Выводит предыдущий открытый URL
					Пример:
						url()->previous(); == http://127.0.0.1:8000/testurl - предпоследняя открытая страница
				4) route(); Вызывает URL, прописанный в роутах с псевдонимом. 
					Аргументом является псевданим ссылки. Например в файле web.php => Route::get('/testurl', ..., '...'])->name('tUrl');
					Пример:
						route('tUrl'); == http://127.0.0.1:8000/testurl
							Если нужно было бы передать в URL параметр.
						route('tUrl', ['url' => 15]); == http://127.0.0.1:8000/testurl/id=15
						где, tUrl - псевданим ссылки
				5) signedRoute(); Метод передачи данных по секретной ссылке. Обычно требуется для передачи данных для подтверждения например почты. 
					URL::signedRoute ссыллается на ссылку/псевданим "activate", которая запускает метод "viewActivate" для проверки подписи.
					Аргументом выстыпает псевданим ссылки и массив с передаваемыми параметрами по ссылке. 
					Пример:
						URL::signedRoute('activate', ['id' => 1]) == http://127.0.0.1:8000/activate?id=1&signature=c29522c6d3ecd3c2e635f4f54900550fa1a5350a8db7ab5aada258ec61c1d2cd
						где, activate - псевданим ссылки в файле web.php;  ['id' => 1] - передаваемые параметры
						Но для надежности нужно прописывать проверку подписи URLa, на то что он подписан нами. 					
						Обычно это проверка пишется в методе на котоырй ссылакется подписываемая ссылка-псевданим. 
					Пример проверки:
						public function viewActivate(Request $request){
							if ($request->hasValidSignature()) {
								return 'Ссылка успешно подписана: '.$request->id;
							}
							abort(401);
						}
						где, 
							viewActivate - метод ссылки - псевданима "activate". 
							$request->hasValidSignature() - проверка ссылки на подленность подписи
							$request->id - вывод переданного параметра в сслыку

						TODO ЗАМЕТКА: для проверки подписей в Laravel есть специальные посредники, которые уопрощают проверку подписей. 
						Пример проверки подписи через мидлвар:
							Route::get('/activate', [App\Http\Controllers\FirstController::class, 'viewActivate'])->middleware('signed')->name('activate');
				6) temporarySignedRoute(); Аналог "signedRoute", но с установкой времени работы подписи. 
					Аргументом является псевдоним ссылки, время работы ссылки, передаваемые параметры по ссылке.
					Пример:
						URL::temporarySignedRoute('activate', now()->addMinutes(5), ['id' => 1]) == 
							где, 
								now()->addMinutes(5) - время работы подписи
								temporarySignedRoute - метод установки времени работы подписи/ссылки
								now() - метод работы со времнеем
								->addMinutes(5) - метод установки минут
		*/
		//!Урок 2: Сессии
		/*
			session()->all() - вывод всех переменных сессии в виде массива
			где,
				session() - функция работы ссессиями
				all()	- функция вывода всех переменных в сессии
			2) exists(); - Функция проверки сессии на наличие переменной.
				Аргументом выступает проверяемая на наличие переменная в сессии. 
				Пример:
					session()->exists('var'); == false/true
			3) has(); - Функция проверки сессии на наличие переменной и ее пустоту (проверка на null).
				Аргументом выступает проверяемая на наличие переменная в сессии. 
				Пример:
					session()->has('var'); == false/true
			4) put(); - Функция добавления к сессии нового значения.
				Первым аргументом выступает название новой переменной, вторым его значение. 
				Пример:
					session()->put('var', 10); == var = 10;
					session('var');
			5) push(); - Функция добавления добавляет новое значение к существующему в сессии массиву.
				Первым аргументом выступает название массива/переменной, вторым его дополнительное значение. 
				Пример:
					session()->push('mass', "var4") == 
					session('var'); || session()->get('var');
			6) pull(); - Функция вывода и удаления существующего в сессии элемента.
				Аргументом выступает удаляемый из сессии элемент
				Пример:
					session()->pull('x');
			7) forget(); - Функция удаления существующего в сессии элемента без вывода.
				Аргументом выступает удаляемый из сессии элемент.
				Пример:
					session()->forget('x');
			8) forget(); - Функция удаления существующего в сессии элемента без вывода.
				Аргументом выступает удаляемый из сессии элемент.
				Пример:
					session()->forget('x');
				
			Пример реализации счетчика посещения страницы:
				$counter = session()->get('counter', 0);
				$counter++;
				session()->put('counter', $counter);
				return $counter;
					ИЛИ
				session()->increment('counter');
				return session()->get('counter');
		*/
		//!Урок 3: Обработка исключений
		/*
			В уроке поговорим о создании и обработке исключений. 
			Исключения нужны для предотвращения выполнения команд, когда того не подразумевает логика с последующим логированием этих ситуаций/кейсов.
			Путь до исключений: "app\Exceptions\Handler.php";
				Этот файл отвечает за прием и обработку исключений. 
				На практике им почти не приходится пользоваться, но знать о нем надо.
				В этом классе чаще всего придется работать с полем "protected $dontReport = [];"
				В этом поле прописываются классы, которые не должны обрабатываться в Laravel. 

				Так же интересен метод "register", перехватывающий все исключения:
					public function register(): void
					{
						$this->reportable(function (Throwable $e) {
						});
					}
					где,  $e - место хранения объекта с исклоючением 
						
				Свои ислючения создаются чреез artisan команду:
					php artisan make:exception NameException

				В созданных исключениях обычно нужно помнить о двух публичных методах: 
					1) context - он возвратщает ассоциативный массив с информацией о сработанном исключении, которая отображается в log-файле.
						Пример:
							public function context(){
								return ['exceptionInfo' => 'инфа о исключении'];
							}
					2) render - метод выполняющийся при срабатывании исключения. 
						Пример:
							public function render(){
								return 'My exception fron file "MyException"';
							}
				Для теста созддим контроллер и выбросим в нем исключение:
					use App\Exceptions\MyException;		
					public function testException(Request $request)
					{
						throw new MyException(); == 'My exception fron file "MyException"'
					}
					где,
						throw - объявление исключения
						new MyException() - создание объекта на основе класса с исключением
						My exception fron file MyException - данные/сообщение, выводимое при срабатывании исключения

					Адрес лог-файла: storage\logs\laravel.log
						Вот сообщение об исключении, отправляемое в логи:
							[2023-05-28 18:17:54] local.ERROR:  {"exceptionInfo":"инфа о исключении","exception":"[object] (App\\Exceptions\\MyException(code: 0):  at H:\\SERVAK\\OPEN_SERVER_pgu\\OSPanel\\domains\\Laravel-Rusakov\\app\\Http\\Controllers\\FirstController.php:105)
		*/


	echo '<hr><hr><br><h3>Laravel - #10.1-2 - Пользовательские страницы ошибок, Логирование (День 10)</h3><hr><hr>' . "<br>";
		//!Урок 1: Пользовательские страницы ошибок
		/*
			В Laravel есть свои шаблоны на случаи ошибок или действий пользовтеля. 
			Однако мы можем заменить эти шаблоны по-умолчанию на свои. 
			Для этого нужно получить доступ к шаблонам через команду artisan:
				php artisan vendor:publish --tag=laravel-errors 
				где,	
					vendor:publish - команда публикации
					--tag= - объявление публикуемых "вещей", как сказал лектор
					laravel-errors - шаблон в laravel
					errors - название дериктории в laravel, ответственной за ошибки
				Эта команда переносит нас в деркторию с шаблонами ошибок laravel:
					=> Copying directory [H:\SERVAK\OPEN_SERVER_pgu\OSPanel\domains\Laravel-Rusakov\vendor\laravel\framework\src\Illuminate\Foundation\Exceptions\views] to [H:\SERVAK\OPEN_SERVER_pgu\OSPanel\domains\Laravel-Rusakov\resources\views\errors]  DONE
				Происходит пренос файлов (перенос дерриктории) из первой дерриктории во вторую.  				
				Это дериктория с шаблонами ошибок.
				TODO ВАЖНО! Если файлы будут названы одинаково в обоих деррикториях, то теперь приоритет чтения будут даваться второй дерриктории. 
				Перепишем шаблон 404 (так как только ее будем редактировать) в новой дерриктории, а остальные файлы в ней удоляем, чтобы они брались из первой дерриктории.
					Возмет только код из файла "minimal.blade.php" и перенесем его в оставшийся файл "404.blade.php". Заменим наслудующие вставки yeld().
					И из шаблона welcome добавм пометку о языке: <html lang="{{ str_replace('_', '-', app()->getLocale()) }}">

		*/
		//!Урок 2: Логирование
		/*
			Логирование - нужно для своевременного отслживани ошибок и ведения их учета. 
				Лиги находятся в файле "config\logging.php".
				В файле размещен набор настроек для логирования. 

				НАСТРОЙКИ РАБОТЫ КАНАЛОВ ЛОГИРОВАНИЯ:
				1. Первая настройка "'default' => env('LOG_CHANNEL', 'stack')" - это канал, который будет использоваться по-умолчанию при попытки добавления сообщения в логи.
					где,
						default - настройка указывающая на дефолтный канал записи. 
						env - файл с главными настройками
						LOG_CHANNEL - парамтр в .env с названием дефолтного канала (если он указан)
						stack - название дефотного канала (запускается, если в .env не указан дефотный кана - по-умолчанию совпадают).

				2. Настройка с выводом предупреждением о использовании устаревших функций
					'deprecations' => [
						'channel' => env('LOG_DEPRECATIONS_CHANNEL', 'null'),
						'trace' => false,
					]
					где,
						null - канал, не обрабатывающий сообщение


			КАНАЛЫ ЛОГИРОВАНИЯ И ИХ НАСТРОЙКИ В ФАЙЛЕ ЛОГИРОВАНИЯ:
			Ниже настроек идет объект "channels" со списком каналов логрования:
				Некоторые параметры каналов могут повторяться, поэтому будут указываться только их основные различия.
				1) stack			- это дрейвер с возможностью передачи сообщения нескольким каналам. Посути это конфиг, как я понял. 
					Настройки канала:
						а) driver - определяет возможность отправки сообщения сразу нескольким каналам
						б) channels	- каналы, которым дополнительно могут отправляться сообщения с канала "stack". Значением выступает массив каналов. 
						а)	ignore_exceptions - игнорирование сообщений от исключений. Содержит булево значение. 
				2) single		- драйвер с путем отправки сообщения в логги. Походу это тоже конфиг. 
						а) path	- содержит функции с аргументом в виде путь до файла логирования. Сюда приходит уведомления об ошибках в логги. 
						б) level	- определяет уровень принимаемых для обработки сообщений. 'level' => env('LOG_LEVEL', 'debug'), где debug - уровень сообщения. 
						TODO ЗАМЕТКА: сообщения в логировании делятся на уровни (о них ниже). 
							Самый важный уровень "Emergency", а  самый низкий уровень приоритета => "debug".
				3) daily			- канал создает отдельные временные файлы для хранения логов, исчезающие через определенный срок, чтобы не хламить место одного файла.  
					а) path - путь до файла логов, который будет иметь название логов+дата создания логов. storage_path('logs/laravel.log'). 
					б) days - время жизни (в днях) созданного файла.
				4) slack			- испольуется для работы в команде, когда нужно, чтобы о какой либо ошибки узнали остальные разработчики. 
				Остальные каналы используются редко: papertrail, stderr, syslog, errorlog, null,  emergency. 
				
				Так же можно создавать и свои каналы. 
				Пример:
					'mychannel' => [
						'driver' => 'single',
						'path' => storage_path('logs/mylog.log'),
						'level' => env('LOG_LEVEL', 'debug'),
					]

			СОЗДАНИЕ УВЕДОБЛЕНИЙ ДЛЯ ЛОГ ФАЙЛА
				Для написания сообщений в логи в laravel есть специальный фассад "Log::"
					Этот фассад имеет методы по числу типов уровней сообщения в логги. О них ниже. 
					Пример отправки сообщения в логи:
						Log::debug('debug-level message'); //все, что в методе - сообщение отправляемое в лог
					Пример сообщения, отображенного в логах:
						[2023-05-29 18:59:03] local.DEBUG: debug-level message 
						где,
							local - локальный сервер
								На боевом сервере будет надпись "production" (прописано в .env(APP_ENV=local)
							DEBUG - уровень сообщения
							debug-level message - сообщение
						TODO ЗАМЕТКА: если хочется поменять слово в логах "production/local" на свое, то в канал "stack" прописывается новый параметр "name" со своим придуманным значением. 
							Пример: 
								'name' => 'СкороВПродакшн'. 						
							Хотя это и не обязательно - так просто можно)
					TODO ВАЖНО! Так как по умолчанию установлен канал "stack", в котором установлен канале "single", в котором указан путь 'path' => storage_path('logs/laravel.log'), то сообщение будет направлено именно в логи по адресу 'storage\logs\laravel.log'.

			ТИПЫ СООБЩЕНИЙ В ФАЙЛ ЛОГ ЧЕРЕЗ ФАССАД "LOG"
				На сайте "https://datatracker.ietf.org/doc/html/rfc5424" в пункте 6.2.1. PRI типы сообщения в логах:
				Перечисляются типы сообщений от самого приоритетному к менее приоритетному: 
				1) Emergency (Аварийная ситуация): system is unusable
						Пример передачии сообщения в контроллере:
							Log::emergency('system is unusable');
				2) Alert (Предупреждение): action must be taken immediately
						Пример передачии сообщения в контроллере:
							Log::alert('action must be taken immediately');
				3) Critical (Критические): critical conditions
						Пример передачии сообщения в контроллере:
							Log::critical('critical conditions');
				4) Error (Ошибка): error conditions
						Пример передачии сообщения в контроллере:
							Log::error('error conditions');
				5) Warning (Предупреждение): warning conditions
						Пример передачии сообщения в контроллере:
							Log::warning('warning conditions');
				6) Notice (Примечание): normal but significant condition
						Пример передачии сообщения в контроллере:
							Log::notice('normal but significant condition');
				7) Informational (Информационный): informational messages
						Пример передачии сообщения в контроллере:
							Log::info('informational messages');
				8) Debug (Отладка): debug-level messages
						Пример передачии сообщения в контроллере:
							Log::debug('debug-level message');

			ПЕРЕДАЧА СООБЩЕНИЯ В ЛОГИ ПО КАНАЛУ НЕ ПО-УМОЛЧАНИЮ (stack):
				Например для записи логов по каналу "daily". Для этого используется метод "channel()".
				Аргументом, которого является существующий канал передачи логов.
				Пример записи логов:
					Log::channel('daily')->info('сообщение по каналу "daily"');
				Пример вывода логов:
					[2023-05-29 19:51:51] local.INFO: Сообщение по каналу "daily"  
				TODO ВАЖНО! При передачи сообщения по каналу "daily" генерируется новый файл с логами к которому в суффикс приписывается время создания -  сообщения в нем.
				В следующий день передачи соосбщения через канал "daily" создается новый файл. 
				TODO ЗАМЕТКА: некоторые разработчики говорят, что больше предпочитают использовать канал "daily" для логирования. 
				Пример нового адреса с логами: 
					"storage\logs\laravel-2023-05-29.log"

				Пример передачи сообщения в логи по созданному вручную кналу:
				TODO ЗАМЕТКА: в логи можно передавать не только сообщение, но и данные, помещенные в массив. 
				TODO ЗАМЕТКА: если передачть сообщение с несуществующем файлом-логом, то при передаче сообщения он создатся автоматически.
				Пример:
					Log::channel('mychannel')->info('Сообщение по созданному вручную каналу "mychannel"', ['data' => 'значение массива с передаваемыми данными']);
				Пример вывода логов:	
					[2023-05-29 20:09:29] local.INFO: Сообщение по созданному вручную каналу "mychannel" {"data":"значение массива с передаваемыми данными"} 
			
			
		*/
